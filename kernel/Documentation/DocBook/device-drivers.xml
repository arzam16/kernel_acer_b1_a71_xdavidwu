<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE book PUBLIC "-//OASIS//DTD DocBook XML V4.1.2//EN"
	"http://www.oasis-open.org/docbook/xml/4.1.2/docbookx.dtd" []>

<book id="LinuxDriversAPI">
 <bookinfo>
  <title>Linux Device Drivers</title>

  <legalnotice>
   <para>
     This documentation is free software; you can redistribute
     it and/or modify it under the terms of the GNU General Public
     License as published by the Free Software Foundation; either
     version 2 of the License, or (at your option) any later
     version.
   </para>

   <para>
     This program is distributed in the hope that it will be
     useful, but WITHOUT ANY WARRANTY; without even the implied
     warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
     See the GNU General Public License for more details.
   </para>

   <para>
     You should have received a copy of the GNU General Public
     License along with this program; if not, write to the Free
     Software Foundation, Inc., 59 Temple Place, Suite 330, Boston,
     MA 02111-1307 USA
   </para>

   <para>
     For more details see the file COPYING in the source
     distribution of Linux.
   </para>
  </legalnotice>
 </bookinfo>

<toc></toc>

  <chapter id="Basics">
     <title>Driver Basics</title>
     <sect1><title>Driver Entry and Exit points</title>
<!-- include/linux/init.h -->
<refentry id="API-module-init">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>July 2015</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>module_init</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.4.104</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>module_init</refname>
 <refpurpose>
  driver initialization entry point
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef> <function>module_init </function></funcdef>
   <paramdef> <parameter>x</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>x</parameter></term>
   <listitem>
    <para>
     function to be run at kernel boot time or module insertion
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
<title>Description</title>
<para>
   <function>module_init</function> will either be called during <function>do_initcalls</function> (if
   builtin) or at module insertion time (if a module).  There can only
   be one per module.
</para>
</refsect1>
</refentry>

<refentry id="API-module-exit">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>July 2015</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>module_exit</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.4.104</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>module_exit</refname>
 <refpurpose>
     driver exit entry point
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef> <function>module_exit </function></funcdef>
   <paramdef> <parameter>x</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>x</parameter></term>
   <listitem>
    <para>
     function to be run when driver is removed
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
<title>Description</title>
<para>
   <function>module_exit</function> will wrap the driver clean-up code
   with <function>cleanup_module</function> when used with rmmod when
   the driver is a module.  If the driver is statically
   compiled into the kernel, <function>module_exit</function> has no effect.
   There can only be one per module.
</para>
</refsect1>
</refentry>

     </sect1>

     <sect1><title>Atomic and pointer manipulation</title>
<!-- arch/x86/include/asm/atomic.h -->
<refentry id="API-atomic-read">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>July 2015</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>atomic_read</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.4.104</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>atomic_read</refname>
 <refpurpose>
  read atomic variable
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>int <function>atomic_read </function></funcdef>
   <paramdef>const atomic_t * <parameter>v</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>v</parameter></term>
   <listitem>
    <para>
     pointer of type atomic_t
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
<title>Description</title>
<para>
   Atomically reads the value of <parameter>v</parameter>.
</para>
</refsect1>
</refentry>

<refentry id="API-atomic-set">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>July 2015</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>atomic_set</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.4.104</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>atomic_set</refname>
 <refpurpose>
     set atomic variable
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>void <function>atomic_set </function></funcdef>
   <paramdef>atomic_t * <parameter>v</parameter></paramdef>
   <paramdef>int <parameter>i</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>v</parameter></term>
   <listitem>
    <para>
     pointer of type atomic_t
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>i</parameter></term>
   <listitem>
    <para>
     required value
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
<title>Description</title>
<para>
   Atomically sets the value of <parameter>v</parameter> to <parameter>i</parameter>.
</para>
</refsect1>
</refentry>

<refentry id="API-atomic-add">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>July 2015</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>atomic_add</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.4.104</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>atomic_add</refname>
 <refpurpose>
     add integer to atomic variable
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>void <function>atomic_add </function></funcdef>
   <paramdef>int <parameter>i</parameter></paramdef>
   <paramdef>atomic_t * <parameter>v</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>i</parameter></term>
   <listitem>
    <para>
     integer value to add
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>v</parameter></term>
   <listitem>
    <para>
     pointer of type atomic_t
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
<title>Description</title>
<para>
   Atomically adds <parameter>i</parameter> to <parameter>v</parameter>.
</para>
</refsect1>
</refentry>

<refentry id="API-atomic-sub">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>July 2015</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>atomic_sub</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.4.104</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>atomic_sub</refname>
 <refpurpose>
     subtract integer from atomic variable
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>void <function>atomic_sub </function></funcdef>
   <paramdef>int <parameter>i</parameter></paramdef>
   <paramdef>atomic_t * <parameter>v</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>i</parameter></term>
   <listitem>
    <para>
     integer value to subtract
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>v</parameter></term>
   <listitem>
    <para>
     pointer of type atomic_t
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
<title>Description</title>
<para>
   Atomically subtracts <parameter>i</parameter> from <parameter>v</parameter>.
</para>
</refsect1>
</refentry>

<refentry id="API-atomic-sub-and-test">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>July 2015</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>atomic_sub_and_test</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.4.104</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>atomic_sub_and_test</refname>
 <refpurpose>
     subtract value from variable and test result
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>int <function>atomic_sub_and_test </function></funcdef>
   <paramdef>int <parameter>i</parameter></paramdef>
   <paramdef>atomic_t * <parameter>v</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>i</parameter></term>
   <listitem>
    <para>
     integer value to subtract
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>v</parameter></term>
   <listitem>
    <para>
     pointer of type atomic_t
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
<title>Description</title>
<para>
   Atomically subtracts <parameter>i</parameter> from <parameter>v</parameter> and returns
   true if the result is zero, or false for all
   other cases.
</para>
</refsect1>
</refentry>

<refentry id="API-atomic-inc">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>July 2015</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>atomic_inc</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.4.104</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>atomic_inc</refname>
 <refpurpose>
     increment atomic variable
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>void <function>atomic_inc </function></funcdef>
   <paramdef>atomic_t * <parameter>v</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>v</parameter></term>
   <listitem>
    <para>
     pointer of type atomic_t
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
<title>Description</title>
<para>
   Atomically increments <parameter>v</parameter> by 1.
</para>
</refsect1>
</refentry>

<refentry id="API-atomic-dec">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>July 2015</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>atomic_dec</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.4.104</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>atomic_dec</refname>
 <refpurpose>
     decrement atomic variable
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>void <function>atomic_dec </function></funcdef>
   <paramdef>atomic_t * <parameter>v</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>v</parameter></term>
   <listitem>
    <para>
     pointer of type atomic_t
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
<title>Description</title>
<para>
   Atomically decrements <parameter>v</parameter> by 1.
</para>
</refsect1>
</refentry>

<refentry id="API-atomic-dec-and-test">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>July 2015</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>atomic_dec_and_test</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.4.104</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>atomic_dec_and_test</refname>
 <refpurpose>
     decrement and test
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>int <function>atomic_dec_and_test </function></funcdef>
   <paramdef>atomic_t * <parameter>v</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>v</parameter></term>
   <listitem>
    <para>
     pointer of type atomic_t
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
<title>Description</title>
<para>
   Atomically decrements <parameter>v</parameter> by 1 and
   returns true if the result is 0, or false for all other
   cases.
</para>
</refsect1>
</refentry>

<refentry id="API-atomic-inc-and-test">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>July 2015</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>atomic_inc_and_test</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.4.104</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>atomic_inc_and_test</refname>
 <refpurpose>
     increment and test
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>int <function>atomic_inc_and_test </function></funcdef>
   <paramdef>atomic_t * <parameter>v</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>v</parameter></term>
   <listitem>
    <para>
     pointer of type atomic_t
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
<title>Description</title>
<para>
   Atomically increments <parameter>v</parameter> by 1
   and returns true if the result is zero, or false for all
   other cases.
</para>
</refsect1>
</refentry>

<refentry id="API-atomic-add-negative">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>July 2015</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>atomic_add_negative</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.4.104</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>atomic_add_negative</refname>
 <refpurpose>
     add and test if negative
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>int <function>atomic_add_negative </function></funcdef>
   <paramdef>int <parameter>i</parameter></paramdef>
   <paramdef>atomic_t * <parameter>v</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>i</parameter></term>
   <listitem>
    <para>
     integer value to add
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>v</parameter></term>
   <listitem>
    <para>
     pointer of type atomic_t
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
<title>Description</title>
<para>
   Atomically adds <parameter>i</parameter> to <parameter>v</parameter> and returns true
   if the result is negative, or false when
   result is greater than or equal to zero.
</para>
</refsect1>
</refentry>

<refentry id="API-atomic-add-return">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>July 2015</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>atomic_add_return</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.4.104</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>atomic_add_return</refname>
 <refpurpose>
     add integer and return
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>int <function>atomic_add_return </function></funcdef>
   <paramdef>int <parameter>i</parameter></paramdef>
   <paramdef>atomic_t * <parameter>v</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>i</parameter></term>
   <listitem>
    <para>
     integer value to add
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>v</parameter></term>
   <listitem>
    <para>
     pointer of type atomic_t
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
<title>Description</title>
<para>
   Atomically adds <parameter>i</parameter> to <parameter>v</parameter> and returns <parameter>i</parameter> + <parameter>v</parameter>
</para>
</refsect1>
</refentry>

<refentry id="API-atomic-sub-return">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>July 2015</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>atomic_sub_return</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.4.104</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>atomic_sub_return</refname>
 <refpurpose>
     subtract integer and return
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>int <function>atomic_sub_return </function></funcdef>
   <paramdef>int <parameter>i</parameter></paramdef>
   <paramdef>atomic_t * <parameter>v</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>i</parameter></term>
   <listitem>
    <para>
     integer value to subtract
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>v</parameter></term>
   <listitem>
    <para>
     pointer of type atomic_t
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
<title>Description</title>
<para>
   Atomically subtracts <parameter>i</parameter> from <parameter>v</parameter> and returns <parameter>v</parameter> - <parameter>i</parameter>
</para>
</refsect1>
</refentry>

<refentry id="API---atomic-add-unless">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>July 2015</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>__atomic_add_unless</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.4.104</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>__atomic_add_unless</refname>
 <refpurpose>
     add unless the number is already a given value
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>int <function>__atomic_add_unless </function></funcdef>
   <paramdef>atomic_t * <parameter>v</parameter></paramdef>
   <paramdef>int <parameter>a</parameter></paramdef>
   <paramdef>int <parameter>u</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>v</parameter></term>
   <listitem>
    <para>
     pointer of type atomic_t
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>a</parameter></term>
   <listitem>
    <para>
     the amount to add to v...
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>u</parameter></term>
   <listitem>
    <para>
     ...unless v is equal to u.
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
<title>Description</title>
<para>
   Atomically adds <parameter>a</parameter> to <parameter>v</parameter>, so long as <parameter>v</parameter> was not already <parameter>u</parameter>.
   Returns the old value of <parameter>v</parameter>.
</para>
</refsect1>
</refentry>

<refentry id="API-atomic-inc-short">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>July 2015</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>atomic_inc_short</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.4.104</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>atomic_inc_short</refname>
 <refpurpose>
     increment of a short integer
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>short int <function>atomic_inc_short </function></funcdef>
   <paramdef>short int * <parameter>v</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>v</parameter></term>
   <listitem>
    <para>
     pointer to type int
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
<title>Description</title>
<para>
   Atomically adds 1 to <parameter>v</parameter>
   Returns the new value of <parameter>u</parameter>
</para>
</refsect1>
</refentry>

<refentry id="API-atomic-or-long">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>July 2015</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>atomic_or_long</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.4.104</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>atomic_or_long</refname>
 <refpurpose>
     OR of two long integers
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>void <function>atomic_or_long </function></funcdef>
   <paramdef>unsigned long * <parameter>v1</parameter></paramdef>
   <paramdef>unsigned long <parameter>v2</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>v1</parameter></term>
   <listitem>
    <para>
     pointer to type unsigned long
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>v2</parameter></term>
   <listitem>
    <para>
     pointer to type unsigned long
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
<title>Description</title>
<para>
   Atomically ORs <parameter>v1</parameter> and <parameter>v2</parameter>
   Returns the result of the OR
</para>
</refsect1>
</refentry>

     </sect1>

     <sect1><title>Delaying, scheduling, and timer routines</title>
<!-- include/linux/sched.h -->
<refentry id="API-struct-task-cputime">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>July 2015</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>struct task_cputime</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.4.104</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>struct task_cputime</refname>
 <refpurpose>
  collected CPU time counts
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <programlisting>
struct task_cputime {
  cputime_t utime;
  cputime_t stime;
  unsigned long long sum_exec_runtime;
};  </programlisting>
</refsynopsisdiv>
 <refsect1>
  <title>Members</title>
  <variablelist>
    <varlistentry>      <term>utime</term>
      <listitem><para>
time spent in user mode, in <structname>cputime_t</structname> units
      </para></listitem>
    </varlistentry>
    <varlistentry>      <term>stime</term>
      <listitem><para>
time spent in kernel mode, in <structname>cputime_t</structname> units
      </para></listitem>
    </varlistentry>
    <varlistentry>      <term>sum_exec_runtime</term>
      <listitem><para>
total time spent on the CPU, in nanoseconds
      </para></listitem>
    </varlistentry>
  </variablelist>
 </refsect1>
<refsect1>
<title>Description</title>
<para>
   This structure groups together three kinds of CPU time that are
   tracked for threads and thread groups.  Most things considering
   CPU time want to group these counts together and treat all three
   of them in parallel.
</para>
</refsect1>
</refentry>

<refentry id="API-struct-thread-group-cputimer">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>July 2015</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>struct thread_group_cputimer</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.4.104</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>struct thread_group_cputimer</refname>
 <refpurpose>
     thread group interval timer counts
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <programlisting>
struct thread_group_cputimer {
  struct task_cputime cputime;
  int running;
  raw_spinlock_t lock;
};  </programlisting>
</refsynopsisdiv>
 <refsect1>
  <title>Members</title>
  <variablelist>
    <varlistentry>      <term>cputime</term>
      <listitem><para>
   thread group interval timers.
      </para></listitem>
    </varlistentry>
    <varlistentry>      <term>running</term>
      <listitem><para>
   non-zero when there are timers running and
   <parameter>cputime</parameter> receives updates.
      </para></listitem>
    </varlistentry>
    <varlistentry>      <term>lock</term>
      <listitem><para>
   lock for fields in this struct.
      </para></listitem>
    </varlistentry>
  </variablelist>
 </refsect1>
<refsect1>
<title>Description</title>
<para>
   This structure contains the version of task_cputime, above, that is
   used for thread group CPU timer calculations.
</para>
</refsect1>
</refentry>

<refentry id="API-group-first-cpu">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>July 2015</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>group_first_cpu</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.4.104</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>group_first_cpu</refname>
 <refpurpose>
     Returns the first cpu in the cpumask of a sched_group.
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>unsigned int <function>group_first_cpu </function></funcdef>
   <paramdef>struct sched_group * <parameter>group</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>group</parameter></term>
   <listitem>
    <para>
     The group whose first cpu is to be returned.
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
</refentry>

<refentry id="API-pid-alive">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>July 2015</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>pid_alive</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.4.104</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>pid_alive</refname>
 <refpurpose>
     check that a task structure is not stale
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>int <function>pid_alive </function></funcdef>
   <paramdef>struct task_struct * <parameter>p</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>p</parameter></term>
   <listitem>
    <para>
     Task structure to be checked.
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
<title>Description</title>
<para>
   Test if a process is not yet dead (at most zombie state)
   If pid_alive fails, then pointers within the task structure
   can be stale and must not be dereferenced.
</para>
</refsect1>
</refentry>

<refentry id="API-is-global-init">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>July 2015</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>is_global_init</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.4.104</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>is_global_init</refname>
 <refpurpose>
     check if a task structure is init
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>int <function>is_global_init </function></funcdef>
   <paramdef>struct task_struct * <parameter>tsk</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>tsk</parameter></term>
   <listitem>
    <para>
     Task structure to be checked.
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
<title>Description</title>
<para>
   Check if a task structure is the first user space task the kernel created.
</para>
</refsect1>
</refentry>

<refentry id="API-is-idle-task">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>July 2015</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>is_idle_task</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.4.104</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>is_idle_task</refname>
 <refpurpose>
     is the specified task an idle task?
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>bool <function>is_idle_task </function></funcdef>
   <paramdef>const struct task_struct * <parameter>p</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>p</parameter></term>
   <listitem>
    <para>
     the task in question.
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
</refentry>

<refentry id="API-threadgroup-lock">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>July 2015</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>threadgroup_lock</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.4.104</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>threadgroup_lock</refname>
 <refpurpose>
     lock threadgroup
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>void <function>threadgroup_lock </function></funcdef>
   <paramdef>struct task_struct * <parameter>tsk</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>tsk</parameter></term>
   <listitem>
    <para>
     member task of the threadgroup to lock
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
<title>Description</title>
<para>
   Lock the threadgroup <parameter>tsk</parameter> belongs to.  No new task is allowed to enter
   and member tasks aren't allowed to exit (as indicated by PF_EXITING) or
   change -&gt;group_leader/pid.  This is useful for cases where the threadgroup
   needs to stay stable across blockable operations.
   </para><para>

   fork and exit paths explicitly call threadgroup_change_{begin|end}() for
   synchronization.  While held, no new task will be added to threadgroup
   and no existing live task will have its PF_EXITING set.
   </para><para>

   <function>de_thread</function> does threadgroup_change_{begin|end}() when a non-leader
   sub-thread becomes a new leader.
</para>
</refsect1>
</refentry>

<refentry id="API-threadgroup-unlock">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>July 2015</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>threadgroup_unlock</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.4.104</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>threadgroup_unlock</refname>
 <refpurpose>
     unlock threadgroup
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>void <function>threadgroup_unlock </function></funcdef>
   <paramdef>struct task_struct * <parameter>tsk</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>tsk</parameter></term>
   <listitem>
    <para>
     member task of the threadgroup to unlock
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
<title>Description</title>
<para>
   Reverse <function>threadgroup_lock</function>.
</para>
</refsect1>
</refentry>

<!-- kernel/sched/core.c -->
<refentry id="API-wake-up-process">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>July 2015</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>wake_up_process</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.4.104</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>wake_up_process</refname>
 <refpurpose>
  Wake up a specific process
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>int <function>wake_up_process </function></funcdef>
   <paramdef>struct task_struct * <parameter>p</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>p</parameter></term>
   <listitem>
    <para>
     The process to be woken up.
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
<title>Description</title>
<para>
   Attempt to wake up the nominated process and move it to the set of runnable
   processes.  Returns 1 if the process was woken up, 0 if it was already
   running.
   </para><para>

   It may be assumed that this function implies a write memory barrier before
   changing the task state if and only if any tasks are woken up.
</para>
</refsect1>
</refentry>

<refentry id="API-preempt-notifier-register">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>July 2015</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>preempt_notifier_register</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.4.104</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>preempt_notifier_register</refname>
 <refpurpose>
     tell me when current is being preempted &amp; rescheduled
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>void <function>preempt_notifier_register </function></funcdef>
   <paramdef>struct preempt_notifier * <parameter>notifier</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>notifier</parameter></term>
   <listitem>
    <para>
     notifier struct to register
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
</refentry>

<refentry id="API-preempt-notifier-unregister">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>July 2015</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>preempt_notifier_unregister</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.4.104</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>preempt_notifier_unregister</refname>
 <refpurpose>
     no longer interested in preemption notifications
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>void <function>preempt_notifier_unregister </function></funcdef>
   <paramdef>struct preempt_notifier * <parameter>notifier</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>notifier</parameter></term>
   <listitem>
    <para>
     notifier struct to unregister
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
<title>Description</title>
<para>
   This is safe to call from within a preemption notifier.
</para>
</refsect1>
</refentry>

<refentry id="API---wake-up">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>July 2015</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>__wake_up</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.4.104</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>__wake_up</refname>
 <refpurpose>
     wake up threads blocked on a waitqueue.
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>void <function>__wake_up </function></funcdef>
   <paramdef>wait_queue_head_t * <parameter>q</parameter></paramdef>
   <paramdef>unsigned int <parameter>mode</parameter></paramdef>
   <paramdef>int <parameter>nr_exclusive</parameter></paramdef>
   <paramdef>void * <parameter>key</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>q</parameter></term>
   <listitem>
    <para>
     the waitqueue
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>mode</parameter></term>
   <listitem>
    <para>
     which threads
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>nr_exclusive</parameter></term>
   <listitem>
    <para>
     how many wake-one or wake-many threads to wake up
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>key</parameter></term>
   <listitem>
    <para>
     is directly passed to the wakeup function
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
<title>Description</title>
<para>
   It may be assumed that this function implies a write memory barrier before
   changing the task state if and only if any tasks are woken up.
</para>
</refsect1>
</refentry>

<refentry id="API---wake-up-sync-key">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>July 2015</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>__wake_up_sync_key</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.4.104</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>__wake_up_sync_key</refname>
 <refpurpose>
     wake up threads blocked on a waitqueue.
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>void <function>__wake_up_sync_key </function></funcdef>
   <paramdef>wait_queue_head_t * <parameter>q</parameter></paramdef>
   <paramdef>unsigned int <parameter>mode</parameter></paramdef>
   <paramdef>int <parameter>nr_exclusive</parameter></paramdef>
   <paramdef>void * <parameter>key</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>q</parameter></term>
   <listitem>
    <para>
     the waitqueue
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>mode</parameter></term>
   <listitem>
    <para>
     which threads
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>nr_exclusive</parameter></term>
   <listitem>
    <para>
     how many wake-one or wake-many threads to wake up
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>key</parameter></term>
   <listitem>
    <para>
     opaque value to be passed to wakeup targets
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
<title>Description</title>
<para>
   The sync wakeup differs that the waker knows that it will schedule
   away soon, so while the target thread will be woken up, it will not
   be migrated to another CPU - ie. the two threads are 'synchronized'
   with each other. This can prevent needless bouncing between CPUs.
   </para><para>

   On UP it can prevent extra preemption.
   </para><para>

   It may be assumed that this function implies a write memory barrier before
   changing the task state if and only if any tasks are woken up.
</para>
</refsect1>
</refentry>

<refentry id="API-complete">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>July 2015</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>complete</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.4.104</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>complete</refname>
 <refpurpose>
     signals a single thread waiting on this completion
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>void <function>complete </function></funcdef>
   <paramdef>struct completion * <parameter>x</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>x</parameter></term>
   <listitem>
    <para>
     holds the state of this particular completion
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
<title>Description</title>
<para>
   This will wake up a single thread waiting on this completion. Threads will be
   awakened in the same order in which they were queued.
   </para><para>

   See also <function>complete_all</function>, <function>wait_for_completion</function> and related routines.
   </para><para>

   It may be assumed that this function implies a write memory barrier before
   changing the task state if and only if any tasks are woken up.
</para>
</refsect1>
</refentry>

<refentry id="API-complete-all">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>July 2015</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>complete_all</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.4.104</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>complete_all</refname>
 <refpurpose>
     signals all threads waiting on this completion
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>void <function>complete_all </function></funcdef>
   <paramdef>struct completion * <parameter>x</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>x</parameter></term>
   <listitem>
    <para>
     holds the state of this particular completion
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
<title>Description</title>
<para>
   This will wake up all threads waiting on this particular completion event.
   </para><para>

   It may be assumed that this function implies a write memory barrier before
   changing the task state if and only if any tasks are woken up.
</para>
</refsect1>
</refentry>

<refentry id="API-wait-for-completion">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>July 2015</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>wait_for_completion</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.4.104</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>wait_for_completion</refname>
 <refpurpose>
     waits for completion of a task
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>void __sched <function>wait_for_completion </function></funcdef>
   <paramdef>struct completion * <parameter>x</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>x</parameter></term>
   <listitem>
    <para>
     holds the state of this particular completion
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
<title>Description</title>
<para>
   This waits to be signaled for completion of a specific task. It is NOT
   interruptible and there is no timeout.
   </para><para>

   See also similar routines (i.e. <function>wait_for_completion_timeout</function>) with timeout
   and interrupt capability. Also see <function>complete</function>.
</para>
</refsect1>
</refentry>

<refentry id="API-wait-for-completion-timeout">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>July 2015</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>wait_for_completion_timeout</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.4.104</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>wait_for_completion_timeout</refname>
 <refpurpose>
     waits for completion of a task (w/timeout)
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>unsigned long __sched <function>wait_for_completion_timeout </function></funcdef>
   <paramdef>struct completion * <parameter>x</parameter></paramdef>
   <paramdef>unsigned long <parameter>timeout</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>x</parameter></term>
   <listitem>
    <para>
     holds the state of this particular completion
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>timeout</parameter></term>
   <listitem>
    <para>
     timeout value in jiffies
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
<title>Description</title>
<para>
   This waits for either a completion of a specific task to be signaled or for a
   specified timeout to expire. The timeout is in jiffies. It is not
   interruptible.
   </para><para>

   The return value is 0 if timed out, and positive (at least 1, or number of
   jiffies left till timeout) if completed.
</para>
</refsect1>
</refentry>

<refentry id="API-wait-for-completion-interruptible">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>July 2015</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>wait_for_completion_interruptible</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.4.104</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>wait_for_completion_interruptible</refname>
 <refpurpose>
     waits for completion of a task (w/intr)
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>int __sched <function>wait_for_completion_interruptible </function></funcdef>
   <paramdef>struct completion * <parameter>x</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>x</parameter></term>
   <listitem>
    <para>
     holds the state of this particular completion
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
<title>Description</title>
<para>
   This waits for completion of a specific task to be signaled. It is
   interruptible.
   </para><para>

   The return value is -ERESTARTSYS if interrupted, 0 if completed.
</para>
</refsect1>
</refentry>

<refentry id="API-wait-for-completion-interruptible-timeout">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>July 2015</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>wait_for_completion_interruptible_timeout</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.4.104</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>wait_for_completion_interruptible_timeout</refname>
 <refpurpose>
     waits for completion (w/(to,intr))
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>long __sched <function>wait_for_completion_interruptible_timeout </function></funcdef>
   <paramdef>struct completion * <parameter>x</parameter></paramdef>
   <paramdef>unsigned long <parameter>timeout</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>x</parameter></term>
   <listitem>
    <para>
     holds the state of this particular completion
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>timeout</parameter></term>
   <listitem>
    <para>
     timeout value in jiffies
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
<title>Description</title>
<para>
   This waits for either a completion of a specific task to be signaled or for a
   specified timeout to expire. It is interruptible. The timeout is in jiffies.
   </para><para>

   The return value is -ERESTARTSYS if interrupted, 0 if timed out,
   positive (at least 1, or number of jiffies left till timeout) if completed.
</para>
</refsect1>
</refentry>

<refentry id="API-wait-for-completion-killable">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>July 2015</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>wait_for_completion_killable</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.4.104</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>wait_for_completion_killable</refname>
 <refpurpose>
     waits for completion of a task (killable)
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>int __sched <function>wait_for_completion_killable </function></funcdef>
   <paramdef>struct completion * <parameter>x</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>x</parameter></term>
   <listitem>
    <para>
     holds the state of this particular completion
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
<title>Description</title>
<para>
   This waits to be signaled for completion of a specific task. It can be
   interrupted by a kill signal.
   </para><para>

   The return value is -ERESTARTSYS if interrupted, 0 if completed.
</para>
</refsect1>
</refentry>

<refentry id="API-wait-for-completion-killable-timeout">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>July 2015</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>wait_for_completion_killable_timeout</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.4.104</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>wait_for_completion_killable_timeout</refname>
 <refpurpose>
     waits for completion of a task (w/(to,killable))
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>long __sched <function>wait_for_completion_killable_timeout </function></funcdef>
   <paramdef>struct completion * <parameter>x</parameter></paramdef>
   <paramdef>unsigned long <parameter>timeout</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>x</parameter></term>
   <listitem>
    <para>
     holds the state of this particular completion
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>timeout</parameter></term>
   <listitem>
    <para>
     timeout value in jiffies
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
<title>Description</title>
<para>
   This waits for either a completion of a specific task to be
   signaled or for a specified timeout to expire. It can be
   interrupted by a kill signal. The timeout is in jiffies.
   </para><para>

   The return value is -ERESTARTSYS if interrupted, 0 if timed out,
   positive (at least 1, or number of jiffies left till timeout) if completed.
</para>
</refsect1>
</refentry>

<refentry id="API-try-wait-for-completion">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>July 2015</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>try_wait_for_completion</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.4.104</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>try_wait_for_completion</refname>
 <refpurpose>
     try to decrement a completion without blocking
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>bool <function>try_wait_for_completion </function></funcdef>
   <paramdef>struct completion * <parameter>x</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>x</parameter></term>
   <listitem>
    <para>
     completion structure
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
<title>Returns</title>
<para>
   0 if a decrement cannot be done without blocking
   1 if a decrement succeeded.
   </para><para>

   If a completion is being used as a counting completion,
   attempt to decrement the counter without blocking. This
   enables us to avoid waiting if the resource the completion
   is protecting is not available.
</para>
</refsect1>
</refentry>

<refentry id="API-completion-done">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>July 2015</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>completion_done</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.4.104</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>completion_done</refname>
 <refpurpose>
     Test to see if a completion has any waiters
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>bool <function>completion_done </function></funcdef>
   <paramdef>struct completion * <parameter>x</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>x</parameter></term>
   <listitem>
    <para>
     completion structure
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
<title>Returns</title>
<para>
   0 if there are waiters (<function>wait_for_completion</function> in progress)
   1 if there are no waiters.
</para>
</refsect1>
</refentry>

<refentry id="API-task-nice">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>July 2015</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>task_nice</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.4.104</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>task_nice</refname>
 <refpurpose>
     return the nice value of a given task.
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>int <function>task_nice </function></funcdef>
   <paramdef>const struct task_struct * <parameter>p</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>p</parameter></term>
   <listitem>
    <para>
     the task in question.
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
</refentry>

<refentry id="API-sched-setscheduler">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>July 2015</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>sched_setscheduler</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.4.104</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>sched_setscheduler</refname>
 <refpurpose>
     change the scheduling policy and/or RT priority of a thread.
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>int <function>sched_setscheduler </function></funcdef>
   <paramdef>struct task_struct * <parameter>p</parameter></paramdef>
   <paramdef>int <parameter>policy</parameter></paramdef>
   <paramdef>const struct sched_param * <parameter>param</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>p</parameter></term>
   <listitem>
    <para>
     the task in question.
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>policy</parameter></term>
   <listitem>
    <para>
     new policy.
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>param</parameter></term>
   <listitem>
    <para>
     structure containing the new RT priority.
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
<title>Description</title>
<para>
   NOTE that the task may be already dead.
</para>
</refsect1>
</refentry>

<refentry id="API-yield">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>July 2015</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>yield</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.4.104</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>yield</refname>
 <refpurpose>
     yield the current processor to other threads.
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>void __sched <function>yield </function></funcdef>
   <paramdef> <parameter>void</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>void</parameter></term>
   <listitem>
    <para>
     no arguments
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
<title>Description</title>
<para>
   </para><para>

   Do not ever use this function, there's a 99% chance you're doing it wrong.
   </para><para>

   The scheduler is at all times free to pick the calling task as the most
   eligible task to run, if removing the <function>yield</function> call from your code breaks
   it, its already broken.
</para>
</refsect1>
<refsect1>
<title>Typical broken usage is</title>
<para>
   </para><para>

   while (!event)
   <function>yield</function>;
   </para><para>

   where one assumes that <function>yield</function> will let 'the other' process run that will
   make event true. If the current task is a SCHED_FIFO task that will never
   happen. Never use <function>yield</function> as a progress guarantee!!
   </para><para>

   If you want to use <function>yield</function> to wait for something, use <function>wait_event</function>.
   If you want to use <function>yield</function> to be 'nice' for others, use <function>cond_resched</function>.
   If you still want to use <function>yield</function>, do not!
</para>
</refsect1>
</refentry>

<refentry id="API-yield-to">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>July 2015</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>yield_to</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.4.104</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>yield_to</refname>
 <refpurpose>
     yield the current processor to another thread in your thread group, or accelerate that thread toward the processor it's on.
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>bool __sched <function>yield_to </function></funcdef>
   <paramdef>struct task_struct * <parameter>p</parameter></paramdef>
   <paramdef>bool <parameter>preempt</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>p</parameter></term>
   <listitem>
    <para>
     target task
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>preempt</parameter></term>
   <listitem>
    <para>
     whether task preemption is allowed or not
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
<title>Description</title>
<para>
   It's the caller's job to ensure that the target task struct
   can't go away on us before we can do any checks.
   </para><para>

   Returns true if we indeed boosted the target task.
</para>
</refsect1>
</refentry>

<!-- kernel/sched/cpupri.c -->
<refentry id="API-cpupri-find">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>July 2015</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>cpupri_find</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.4.104</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>cpupri_find</refname>
 <refpurpose>
  find the best (lowest-pri) CPU in the system
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>int <function>cpupri_find </function></funcdef>
   <paramdef>struct cpupri * <parameter>cp</parameter></paramdef>
   <paramdef>struct task_struct * <parameter>p</parameter></paramdef>
   <paramdef>struct cpumask * <parameter>lowest_mask</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>cp</parameter></term>
   <listitem>
    <para>
     The cpupri context
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>p</parameter></term>
   <listitem>
    <para>
     The task
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>lowest_mask</parameter></term>
   <listitem>
    <para>
     A mask to fill in with selected CPUs (or NULL)
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
<title>Note</title>
<para>
   This function returns the recommended CPUs as calculated during the
   current invocation.  By the time the call returns, the CPUs may have in
   fact changed priorities any number of times.  While not ideal, it is not
   an issue of correctness since the normal rebalancer logic will correct
   any discrepancies created by racing against the uncertainty of the current
   priority configuration.
</para>
</refsect1>
<refsect1>
<title>Returns</title>
<para>
   (int)bool - CPUs were found
</para>
</refsect1>
</refentry>

<refentry id="API-cpupri-set">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>July 2015</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>cpupri_set</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.4.104</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>cpupri_set</refname>
 <refpurpose>
     update the cpu priority setting
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>void <function>cpupri_set </function></funcdef>
   <paramdef>struct cpupri * <parameter>cp</parameter></paramdef>
   <paramdef>int <parameter>cpu</parameter></paramdef>
   <paramdef>int <parameter>newpri</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>cp</parameter></term>
   <listitem>
    <para>
     The cpupri context
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>cpu</parameter></term>
   <listitem>
    <para>
     The target cpu
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>newpri</parameter></term>
   <listitem>
    <para>
     The priority (INVALID-RT99) to assign to this CPU
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
<title>Note</title>
<para>
   Assumes cpu_rq(cpu)-&gt;lock is locked
</para>
</refsect1>
<refsect1>
<title>Returns</title>
<para>
   (void)
</para>
</refsect1>
</refentry>

<refentry id="API-cpupri-init">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>July 2015</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>cpupri_init</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.4.104</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>cpupri_init</refname>
 <refpurpose>
     initialize the cpupri structure
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>int <function>cpupri_init </function></funcdef>
   <paramdef>struct cpupri * <parameter>cp</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>cp</parameter></term>
   <listitem>
    <para>
     The cpupri context
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
<title>Returns</title>
<para>
   -ENOMEM if memory fails.
</para>
</refsect1>
</refentry>

<refentry id="API-cpupri-cleanup">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>July 2015</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>cpupri_cleanup</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.4.104</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>cpupri_cleanup</refname>
 <refpurpose>
     clean up the cpupri structure
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>void <function>cpupri_cleanup </function></funcdef>
   <paramdef>struct cpupri * <parameter>cp</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>cp</parameter></term>
   <listitem>
    <para>
     The cpupri context
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
</refentry>

<!-- kernel/sched/fair.c -->
<refentry id="API-get-sd-load-idx">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>July 2015</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>get_sd_load_idx</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.4.104</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>get_sd_load_idx</refname>
 <refpurpose>
  Obtain the load index for a given sched domain.
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>int <function>get_sd_load_idx </function></funcdef>
   <paramdef>struct sched_domain * <parameter>sd</parameter></paramdef>
   <paramdef>enum cpu_idle_type <parameter>idle</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>sd</parameter></term>
   <listitem>
    <para>
     The sched_domain whose load_idx is to be obtained.
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>idle</parameter></term>
   <listitem>
    <para>
     The Idle status of the CPU for whose sd load_icx is obtained.
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
</refentry>

<refentry id="API-init-sd-power-savings-stats">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>July 2015</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>init_sd_power_savings_stats</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.4.104</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>init_sd_power_savings_stats</refname>
 <refpurpose>
     Initialize power savings statistics for the given sched_domain, during load balancing.
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>void <function>init_sd_power_savings_stats </function></funcdef>
   <paramdef>struct sched_domain * <parameter>sd</parameter></paramdef>
   <paramdef>struct sd_lb_stats * <parameter>sds</parameter></paramdef>
   <paramdef>enum cpu_idle_type <parameter>idle</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>sd</parameter></term>
   <listitem>
    <para>
     Sched domain whose power-savings statistics are to be initialized.
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>sds</parameter></term>
   <listitem>
    <para>
     Variable containing the statistics for sd.
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>idle</parameter></term>
   <listitem>
    <para>
     Idle status of the CPU at which we're performing load-balancing.
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
</refentry>

<refentry id="API-update-sd-power-savings-stats">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>July 2015</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>update_sd_power_savings_stats</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.4.104</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>update_sd_power_savings_stats</refname>
 <refpurpose>
     Update the power saving stats for a sched_domain while performing load balancing.
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>void <function>update_sd_power_savings_stats </function></funcdef>
   <paramdef>struct sched_group * <parameter>group</parameter></paramdef>
   <paramdef>struct sd_lb_stats * <parameter>sds</parameter></paramdef>
   <paramdef>int <parameter>local_group</parameter></paramdef>
   <paramdef>struct sg_lb_stats * <parameter>sgs</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>group</parameter></term>
   <listitem>
    <para>
     sched_group belonging to the sched_domain under consideration.
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>sds</parameter></term>
   <listitem>
    <para>
     Variable containing the statistics of the sched_domain
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>local_group</parameter></term>
   <listitem>
    <para>
     Does group contain the CPU for which we're performing
     load balancing ?
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>sgs</parameter></term>
   <listitem>
    <para>
     Variable containing the statistics of the group.
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
</refentry>

<refentry id="API-check-power-save-busiest-group">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>July 2015</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>check_power_save_busiest_group</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.4.104</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>check_power_save_busiest_group</refname>
 <refpurpose>
     see if there is potential for some power-savings balance
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>int <function>check_power_save_busiest_group </function></funcdef>
   <paramdef>struct sd_lb_stats * <parameter>sds</parameter></paramdef>
   <paramdef>int <parameter>this_cpu</parameter></paramdef>
   <paramdef>unsigned long * <parameter>imbalance</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>sds</parameter></term>
   <listitem>
    <para>
     Variable containing the statistics of the sched_domain
     under consideration.
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>this_cpu</parameter></term>
   <listitem>
    <para>
     Cpu at which we're currently performing load-balancing.
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>imbalance</parameter></term>
   <listitem>
    <para>
     Variable to store the imbalance.
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
<title>Description</title>
<para>
   Check if we have potential to perform some power-savings balance.
   If yes, set the busiest group to be the least loaded group in the
   sched_domain, so that it's CPUs can be put to idle.
   </para><para>

   Returns 1 if there is potential to perform power-savings balance.
   Else returns 0.
</para>
</refsect1>
</refentry>

<refentry id="API-update-sg-lb-stats">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>July 2015</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>update_sg_lb_stats</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.4.104</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>update_sg_lb_stats</refname>
 <refpurpose>
     Update sched_group's statistics for load balancing.
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>void <function>update_sg_lb_stats </function></funcdef>
   <paramdef>struct sched_domain * <parameter>sd</parameter></paramdef>
   <paramdef>struct sched_group * <parameter>group</parameter></paramdef>
   <paramdef>int <parameter>this_cpu</parameter></paramdef>
   <paramdef>enum cpu_idle_type <parameter>idle</parameter></paramdef>
   <paramdef>int <parameter>load_idx</parameter></paramdef>
   <paramdef>int <parameter>local_group</parameter></paramdef>
   <paramdef>const struct cpumask * <parameter>cpus</parameter></paramdef>
   <paramdef>int * <parameter>balance</parameter></paramdef>
   <paramdef>struct sg_lb_stats * <parameter>sgs</parameter></paramdef>
   <paramdef>struct lb_env * <parameter>env</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>sd</parameter></term>
   <listitem>
    <para>
     The sched_domain whose statistics are to be updated.
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>group</parameter></term>
   <listitem>
    <para>
     sched_group whose statistics are to be updated.
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>this_cpu</parameter></term>
   <listitem>
    <para>
     Cpu for which load balance is currently performed.
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>idle</parameter></term>
   <listitem>
    <para>
     Idle status of this_cpu
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>load_idx</parameter></term>
   <listitem>
    <para>
     Load index of sched_domain of this_cpu for load calc.
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>local_group</parameter></term>
   <listitem>
    <para>
     Does group contain this_cpu.
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>cpus</parameter></term>
   <listitem>
    <para>
     Set of cpus considered for load balancing.
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>balance</parameter></term>
   <listitem>
    <para>
     Should we balance.
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>sgs</parameter></term>
   <listitem>
    <para>
     variable to hold the statistics for this group.
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>env</parameter></term>
   <listitem>
    <para>
     -- undescribed --
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
</refentry>

<refentry id="API-update-sd-pick-busiest">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>July 2015</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>update_sd_pick_busiest</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.4.104</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>update_sd_pick_busiest</refname>
 <refpurpose>
     return 1 on busiest group
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>bool <function>update_sd_pick_busiest </function></funcdef>
   <paramdef>struct sched_domain * <parameter>sd</parameter></paramdef>
   <paramdef>struct sd_lb_stats * <parameter>sds</parameter></paramdef>
   <paramdef>struct sched_group * <parameter>sg</parameter></paramdef>
   <paramdef>struct sg_lb_stats * <parameter>sgs</parameter></paramdef>
   <paramdef>int <parameter>this_cpu</parameter></paramdef>
   <paramdef>struct lb_env * <parameter>env</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>sd</parameter></term>
   <listitem>
    <para>
     sched_domain whose statistics are to be checked
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>sds</parameter></term>
   <listitem>
    <para>
     sched_domain statistics
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>sg</parameter></term>
   <listitem>
    <para>
     sched_group candidate to be checked for being the busiest
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>sgs</parameter></term>
   <listitem>
    <para>
     sched_group statistics
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>this_cpu</parameter></term>
   <listitem>
    <para>
     the current cpu
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>env</parameter></term>
   <listitem>
    <para>
     -- undescribed --
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
<title>Description</title>
<para>
   Determine if <parameter>sg</parameter> is a busier group than the previously selected
   busiest group.
</para>
</refsect1>
</refentry>

<refentry id="API-update-sd-lb-stats">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>July 2015</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>update_sd_lb_stats</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.4.104</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>update_sd_lb_stats</refname>
 <refpurpose>
     Update sched_domain's statistics for load balancing.
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>void <function>update_sd_lb_stats </function></funcdef>
   <paramdef>struct sched_domain * <parameter>sd</parameter></paramdef>
   <paramdef>int <parameter>this_cpu</parameter></paramdef>
   <paramdef>enum cpu_idle_type <parameter>idle</parameter></paramdef>
   <paramdef>const struct cpumask * <parameter>cpus</parameter></paramdef>
   <paramdef>int * <parameter>balance</parameter></paramdef>
   <paramdef>struct sd_lb_stats * <parameter>sds</parameter></paramdef>
   <paramdef>struct lb_env * <parameter>env</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>sd</parameter></term>
   <listitem>
    <para>
     sched_domain whose statistics are to be updated.
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>this_cpu</parameter></term>
   <listitem>
    <para>
     Cpu for which load balance is currently performed.
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>idle</parameter></term>
   <listitem>
    <para>
     Idle status of this_cpu
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>cpus</parameter></term>
   <listitem>
    <para>
     Set of cpus considered for load balancing.
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>balance</parameter></term>
   <listitem>
    <para>
     Should we balance.
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>sds</parameter></term>
   <listitem>
    <para>
     variable to hold the statistics for this sched_domain.
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>env</parameter></term>
   <listitem>
    <para>
     -- undescribed --
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
</refentry>

<refentry id="API-check-asym-packing">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>July 2015</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>check_asym_packing</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.4.104</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>check_asym_packing</refname>
 <refpurpose>
     Check to see if the group is packed into the sched doman.
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>int <function>check_asym_packing </function></funcdef>
   <paramdef>struct sched_domain * <parameter>sd</parameter></paramdef>
   <paramdef>struct sd_lb_stats * <parameter>sds</parameter></paramdef>
   <paramdef>int <parameter>this_cpu</parameter></paramdef>
   <paramdef>unsigned long * <parameter>imbalance</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>sd</parameter></term>
   <listitem>
    <para>
     The sched_domain whose packing is to be checked.
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>sds</parameter></term>
   <listitem>
    <para>
     Statistics of the sched_domain which is to be packed
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>this_cpu</parameter></term>
   <listitem>
    <para>
     The cpu at whose sched_domain we're performing load-balance.
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>imbalance</parameter></term>
   <listitem>
    <para>
     returns amount of imbalanced due to packing.
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
<title>Description</title>
<para>
   </para><para>

   This is primarily intended to used at the sibling level.  Some
   cores like POWER7 prefer to use lower numbered SMT threads.  In the
   case of POWER7, it can move to lower SMT modes only when higher
   threads are idle.  When in lower SMT modes, the threads will
   perform better since they share less core resources.  Hence when we
   have idle threads, we want them to be the higher ones.
   </para><para>

   This packing function is run on idle threads.  It checks to see if
   the busiest CPU in this domain (core in the P7 case) has a higher
   CPU number than the packing function is being run on.  Here we are
   assuming lower CPU number will be equivalent to lower a SMT thread
   number.
   </para><para>

   Returns 1 when packing is required and a task should be moved to
   this CPU.  The amount of the imbalance is returned in *imbalance.
</para>
</refsect1>
</refentry>

<refentry id="API-fix-small-imbalance">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>July 2015</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>fix_small_imbalance</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.4.104</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>fix_small_imbalance</refname>
 <refpurpose>
     Calculate the minor imbalance that exists amongst the groups of a sched_domain, during load balancing.
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>void <function>fix_small_imbalance </function></funcdef>
   <paramdef>struct sd_lb_stats * <parameter>sds</parameter></paramdef>
   <paramdef>int <parameter>this_cpu</parameter></paramdef>
   <paramdef>unsigned long * <parameter>imbalance</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>sds</parameter></term>
   <listitem>
    <para>
     Statistics of the sched_domain whose imbalance is to be calculated.
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>this_cpu</parameter></term>
   <listitem>
    <para>
     The cpu at whose sched_domain we're performing load-balance.
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>imbalance</parameter></term>
   <listitem>
    <para>
     Variable to store the imbalance.
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
</refentry>

<refentry id="API-calculate-imbalance">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>July 2015</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>calculate_imbalance</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.4.104</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>calculate_imbalance</refname>
 <refpurpose>
     Calculate the amount of imbalance present within the groups of a given sched_domain during load balance.
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>void <function>calculate_imbalance </function></funcdef>
   <paramdef>struct sd_lb_stats * <parameter>sds</parameter></paramdef>
   <paramdef>int <parameter>this_cpu</parameter></paramdef>
   <paramdef>unsigned long * <parameter>imbalance</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>sds</parameter></term>
   <listitem>
    <para>
     statistics of the sched_domain whose imbalance is to be calculated.
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>this_cpu</parameter></term>
   <listitem>
    <para>
     Cpu for which currently load balance is being performed.
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>imbalance</parameter></term>
   <listitem>
    <para>
     The variable to store the imbalance.
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
</refentry>

<refentry id="API-find-busiest-group">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>July 2015</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>find_busiest_group</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.4.104</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>find_busiest_group</refname>
 <refpurpose>
     Returns the busiest group within the sched_domain if there is an imbalance. If there isn't an imbalance, and the user has opted for power-savings, it returns a group whose CPUs can be put to idle by rebalancing those tasks elsewhere, if such a group exists.
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>struct sched_group * <function>find_busiest_group </function></funcdef>
   <paramdef>struct sched_domain * <parameter>sd</parameter></paramdef>
   <paramdef>int <parameter>this_cpu</parameter></paramdef>
   <paramdef>unsigned long * <parameter>imbalance</parameter></paramdef>
   <paramdef>enum cpu_idle_type <parameter>idle</parameter></paramdef>
   <paramdef>const struct cpumask * <parameter>cpus</parameter></paramdef>
   <paramdef>int * <parameter>balance</parameter></paramdef>
   <paramdef>struct lb_env * <parameter>env</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>sd</parameter></term>
   <listitem>
    <para>
     The sched_domain whose busiest group is to be returned.
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>this_cpu</parameter></term>
   <listitem>
    <para>
     The cpu for which load balancing is currently being performed.
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>imbalance</parameter></term>
   <listitem>
    <para>
     Variable which stores amount of weighted load which should
     be moved to restore balance/put a group to idle.
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>idle</parameter></term>
   <listitem>
    <para>
     The idle status of this_cpu.
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>cpus</parameter></term>
   <listitem>
    <para>
     The set of CPUs under consideration for load-balancing.
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>balance</parameter></term>
   <listitem>
    <para>
     Pointer to a variable indicating if this_cpu
     is the appropriate cpu to perform load balancing at this_level.
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>env</parameter></term>
   <listitem>
    <para>
     -- undescribed --
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
<title>Description</title>
<para>
   </para><para>

   Also calculates the amount of weighted load which should be moved
   to restore balance.
</para>
</refsect1>
<refsect1>
<title>Returns</title>
<para>
   - the busiest group if imbalance exists.
   - If no imbalance and user has opted for power-savings balance,
   return the least loaded group whose CPUs can be
   put to idle by rebalancing its tasks onto our group.
</para>
</refsect1>
</refentry>

<refentry id="API-lowest-flag-domain">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>July 2015</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>lowest_flag_domain</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.4.104</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>lowest_flag_domain</refname>
 <refpurpose>
     Return lowest sched_domain containing flag.
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>struct sched_domain * <function>lowest_flag_domain </function></funcdef>
   <paramdef>int <parameter>cpu</parameter></paramdef>
   <paramdef>int <parameter>flag</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>cpu</parameter></term>
   <listitem>
    <para>
     The cpu whose lowest level of sched domain is to
     be returned.
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>flag</parameter></term>
   <listitem>
    <para>
     The flag to check for the lowest sched_domain
     for the given cpu.
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
<title>Description</title>
<para>
   Returns the lowest sched_domain of a cpu which contains the given flag.
</para>
</refsect1>
</refentry>

<refentry id="API-for-each-flag-domain">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>July 2015</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>for_each_flag_domain</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.4.104</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>for_each_flag_domain</refname>
 <refpurpose>
     Iterates over sched_domains containing the flag.
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef> <function>for_each_flag_domain </function></funcdef>
   <paramdef> <parameter>cpu</parameter></paramdef>
   <paramdef> <parameter>sd</parameter></paramdef>
   <paramdef> <parameter>flag</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>cpu</parameter></term>
   <listitem>
    <para>
     The cpu whose domains we're iterating over.
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>sd</parameter></term>
   <listitem>
    <para>
     variable holding the value of the power_savings_sd
     for cpu.
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>flag</parameter></term>
   <listitem>
    <para>
     The flag to filter the sched_domains to be iterated.
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
<title>Description</title>
<para>
   Iterates over all the scheduler domains for a given cpu that has the 'flag'
   set, starting from the lowest sched_domain to the highest.
</para>
</refsect1>
</refentry>

<refentry id="API-find-new-ilb">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>July 2015</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>find_new_ilb</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.4.104</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>find_new_ilb</refname>
 <refpurpose>
     Finds the optimum idle load balancer for nomination.
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>int <function>find_new_ilb </function></funcdef>
   <paramdef>int <parameter>cpu</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>cpu</parameter></term>
   <listitem>
    <para>
     The cpu which is nominating a new idle_load_balancer.
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
<title>Returns</title>
<para>
   Returns the id of the idle load balancer if it exists,
   Else, returns &gt;= nr_cpu_ids.
   </para><para>

   This algorithm picks the idle load balancer such that it belongs to a
   semi-idle powersavings sched_domain. The idea is to try and avoid
   completely idle packages/cores just for the purpose of idle load balancing
   when there are other idle cpu's which are better suited for that job.
</para>
</refsect1>
</refentry>

<!-- include/linux/completion.h -->
<refentry id="API-DECLARE-COMPLETION">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>July 2015</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>DECLARE_COMPLETION</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.4.104</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>DECLARE_COMPLETION</refname>
 <refpurpose>
  declare and initialize a completion structure
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef> <function>DECLARE_COMPLETION </function></funcdef>
   <paramdef> <parameter>work</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>work</parameter></term>
   <listitem>
    <para>
     identifier for the completion structure
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
<title>Description</title>
<para>
   This macro declares and initializes a completion structure. Generally used
   for static declarations. You should use the _ONSTACK variant for automatic
   variables.
</para>
</refsect1>
</refentry>

<refentry id="API-DECLARE-COMPLETION-ONSTACK">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>July 2015</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>DECLARE_COMPLETION_ONSTACK</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.4.104</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>DECLARE_COMPLETION_ONSTACK</refname>
 <refpurpose>
     declare and initialize a completion structure
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef> <function>DECLARE_COMPLETION_ONSTACK </function></funcdef>
   <paramdef> <parameter>work</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>work</parameter></term>
   <listitem>
    <para>
     identifier for the completion structure
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
<title>Description</title>
<para>
   This macro declares and initializes a completion structure on the kernel
   stack.
</para>
</refsect1>
</refentry>

<refentry id="API-init-completion">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>July 2015</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>init_completion</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.4.104</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>init_completion</refname>
 <refpurpose>
     Initialize a dynamically allocated completion
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>void <function>init_completion </function></funcdef>
   <paramdef>struct completion * <parameter>x</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>x</parameter></term>
   <listitem>
    <para>
     completion structure that is to be initialized
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
<title>Description</title>
<para>
   This inline function will initialize a dynamically created completion
   structure.
</para>
</refsect1>
</refentry>

<refentry id="API-INIT-COMPLETION">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>July 2015</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>INIT_COMPLETION</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.4.104</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>INIT_COMPLETION</refname>
 <refpurpose>
     reinitialize a completion structure
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef> <function>INIT_COMPLETION </function></funcdef>
   <paramdef> <parameter>x</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>x</parameter></term>
   <listitem>
    <para>
     completion structure to be reinitialized
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
<title>Description</title>
<para>
   This macro should be used to reinitialize a completion structure so it can
   be reused. This is especially important after <function>complete_all</function> is used.
</para>
</refsect1>
</refentry>

<!-- kernel/timer.c -->
<refentry id="API---round-jiffies">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>July 2015</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>__round_jiffies</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.4.104</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>__round_jiffies</refname>
 <refpurpose>
  function to round jiffies to a full second
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>unsigned long <function>__round_jiffies </function></funcdef>
   <paramdef>unsigned long <parameter>j</parameter></paramdef>
   <paramdef>int <parameter>cpu</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>j</parameter></term>
   <listitem>
    <para>
     the time in (absolute) jiffies that should be rounded
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>cpu</parameter></term>
   <listitem>
    <para>
     the processor number on which the timeout will happen
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
<title>Description</title>
<para>
   <function>__round_jiffies</function> rounds an absolute time in the future (in jiffies)
   up or down to (approximately) full seconds. This is useful for timers
   for which the exact time they fire does not matter too much, as long as
   they fire approximately every X seconds.
   </para><para>

   By rounding these timers to whole seconds, all such timers will fire
   at the same time, rather than at various times spread out. The goal
   of this is to have the CPU wake up less, which saves power.
   </para><para>

   The exact rounding is skewed for each processor to avoid all
   processors firing at the exact same time, which could lead
   to lock contention or spurious cache line bouncing.
   </para><para>

   The return value is the rounded version of the <parameter>j</parameter> parameter.
</para>
</refsect1>
</refentry>

<refentry id="API---round-jiffies-relative">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>July 2015</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>__round_jiffies_relative</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.4.104</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>__round_jiffies_relative</refname>
 <refpurpose>
     function to round jiffies to a full second
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>unsigned long <function>__round_jiffies_relative </function></funcdef>
   <paramdef>unsigned long <parameter>j</parameter></paramdef>
   <paramdef>int <parameter>cpu</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>j</parameter></term>
   <listitem>
    <para>
     the time in (relative) jiffies that should be rounded
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>cpu</parameter></term>
   <listitem>
    <para>
     the processor number on which the timeout will happen
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
<title>Description</title>
<para>
   <function>__round_jiffies_relative</function> rounds a time delta  in the future (in jiffies)
   up or down to (approximately) full seconds. This is useful for timers
   for which the exact time they fire does not matter too much, as long as
   they fire approximately every X seconds.
   </para><para>

   By rounding these timers to whole seconds, all such timers will fire
   at the same time, rather than at various times spread out. The goal
   of this is to have the CPU wake up less, which saves power.
   </para><para>

   The exact rounding is skewed for each processor to avoid all
   processors firing at the exact same time, which could lead
   to lock contention or spurious cache line bouncing.
   </para><para>

   The return value is the rounded version of the <parameter>j</parameter> parameter.
</para>
</refsect1>
</refentry>

<refentry id="API-round-jiffies">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>July 2015</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>round_jiffies</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.4.104</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>round_jiffies</refname>
 <refpurpose>
     function to round jiffies to a full second
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>unsigned long <function>round_jiffies </function></funcdef>
   <paramdef>unsigned long <parameter>j</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>j</parameter></term>
   <listitem>
    <para>
     the time in (absolute) jiffies that should be rounded
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
<title>Description</title>
<para>
   <function>round_jiffies</function> rounds an absolute time in the future (in jiffies)
   up or down to (approximately) full seconds. This is useful for timers
   for which the exact time they fire does not matter too much, as long as
   they fire approximately every X seconds.
   </para><para>

   By rounding these timers to whole seconds, all such timers will fire
   at the same time, rather than at various times spread out. The goal
   of this is to have the CPU wake up less, which saves power.
   </para><para>

   The return value is the rounded version of the <parameter>j</parameter> parameter.
</para>
</refsect1>
</refentry>

<refentry id="API-round-jiffies-relative">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>July 2015</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>round_jiffies_relative</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.4.104</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>round_jiffies_relative</refname>
 <refpurpose>
     function to round jiffies to a full second
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>unsigned long <function>round_jiffies_relative </function></funcdef>
   <paramdef>unsigned long <parameter>j</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>j</parameter></term>
   <listitem>
    <para>
     the time in (relative) jiffies that should be rounded
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
<title>Description</title>
<para>
   <function>round_jiffies_relative</function> rounds a time delta  in the future (in jiffies)
   up or down to (approximately) full seconds. This is useful for timers
   for which the exact time they fire does not matter too much, as long as
   they fire approximately every X seconds.
   </para><para>

   By rounding these timers to whole seconds, all such timers will fire
   at the same time, rather than at various times spread out. The goal
   of this is to have the CPU wake up less, which saves power.
   </para><para>

   The return value is the rounded version of the <parameter>j</parameter> parameter.
</para>
</refsect1>
</refentry>

<refentry id="API---round-jiffies-up">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>July 2015</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>__round_jiffies_up</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.4.104</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>__round_jiffies_up</refname>
 <refpurpose>
     function to round jiffies up to a full second
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>unsigned long <function>__round_jiffies_up </function></funcdef>
   <paramdef>unsigned long <parameter>j</parameter></paramdef>
   <paramdef>int <parameter>cpu</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>j</parameter></term>
   <listitem>
    <para>
     the time in (absolute) jiffies that should be rounded
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>cpu</parameter></term>
   <listitem>
    <para>
     the processor number on which the timeout will happen
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
<title>Description</title>
<para>
   This is the same as <function>__round_jiffies</function> except that it will never
   round down.  This is useful for timeouts for which the exact time
   of firing does not matter too much, as long as they don't fire too
   early.
</para>
</refsect1>
</refentry>

<refentry id="API---round-jiffies-up-relative">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>July 2015</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>__round_jiffies_up_relative</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.4.104</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>__round_jiffies_up_relative</refname>
 <refpurpose>
     function to round jiffies up to a full second
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>unsigned long <function>__round_jiffies_up_relative </function></funcdef>
   <paramdef>unsigned long <parameter>j</parameter></paramdef>
   <paramdef>int <parameter>cpu</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>j</parameter></term>
   <listitem>
    <para>
     the time in (relative) jiffies that should be rounded
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>cpu</parameter></term>
   <listitem>
    <para>
     the processor number on which the timeout will happen
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
<title>Description</title>
<para>
   This is the same as <function>__round_jiffies_relative</function> except that it will never
   round down.  This is useful for timeouts for which the exact time
   of firing does not matter too much, as long as they don't fire too
   early.
</para>
</refsect1>
</refentry>

<refentry id="API-round-jiffies-up">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>July 2015</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>round_jiffies_up</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.4.104</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>round_jiffies_up</refname>
 <refpurpose>
     function to round jiffies up to a full second
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>unsigned long <function>round_jiffies_up </function></funcdef>
   <paramdef>unsigned long <parameter>j</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>j</parameter></term>
   <listitem>
    <para>
     the time in (absolute) jiffies that should be rounded
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
<title>Description</title>
<para>
   This is the same as <function>round_jiffies</function> except that it will never
   round down.  This is useful for timeouts for which the exact time
   of firing does not matter too much, as long as they don't fire too
   early.
</para>
</refsect1>
</refentry>

<refentry id="API-round-jiffies-up-relative">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>July 2015</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>round_jiffies_up_relative</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.4.104</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>round_jiffies_up_relative</refname>
 <refpurpose>
     function to round jiffies up to a full second
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>unsigned long <function>round_jiffies_up_relative </function></funcdef>
   <paramdef>unsigned long <parameter>j</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>j</parameter></term>
   <listitem>
    <para>
     the time in (relative) jiffies that should be rounded
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
<title>Description</title>
<para>
   This is the same as <function>round_jiffies_relative</function> except that it will never
   round down.  This is useful for timeouts for which the exact time
   of firing does not matter too much, as long as they don't fire too
   early.
</para>
</refsect1>
</refentry>

<refentry id="API-set-timer-slack">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>July 2015</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>set_timer_slack</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.4.104</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>set_timer_slack</refname>
 <refpurpose>
     set the allowed slack for a timer
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>void <function>set_timer_slack </function></funcdef>
   <paramdef>struct timer_list * <parameter>timer</parameter></paramdef>
   <paramdef>int <parameter>slack_hz</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>timer</parameter></term>
   <listitem>
    <para>
     the timer to be modified
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>slack_hz</parameter></term>
   <listitem>
    <para>
     the amount of time (in jiffies) allowed for rounding
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
<title>Description</title>
<para>
   Set the amount of time, in jiffies, that a certain timer has
   in terms of slack. By setting this value, the timer subsystem
   will schedule the actual timer somewhere between
   the time <function>mod_timer</function> asks for, and that time plus the slack.
   </para><para>

   By setting the slack to -1, a percentage of the delay is used
   instead.
</para>
</refsect1>
</refentry>

<refentry id="API-init-timer-key">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>July 2015</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>init_timer_key</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.4.104</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>init_timer_key</refname>
 <refpurpose>
     initialize a timer
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>void <function>init_timer_key </function></funcdef>
   <paramdef>struct timer_list * <parameter>timer</parameter></paramdef>
   <paramdef>const char * <parameter>name</parameter></paramdef>
   <paramdef>struct lock_class_key * <parameter>key</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>timer</parameter></term>
   <listitem>
    <para>
     the timer to be initialized
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>name</parameter></term>
   <listitem>
    <para>
     name of the timer
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>key</parameter></term>
   <listitem>
    <para>
     lockdep class key of the fake lock used for tracking timer
     sync lock dependencies
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
<title>Description</title>
<para>
   <function>init_timer_key</function> must be done to a timer prior calling *any* of the
   other timer functions.
</para>
</refsect1>
</refentry>

<refentry id="API-mod-timer-pending">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>July 2015</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>mod_timer_pending</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.4.104</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>mod_timer_pending</refname>
 <refpurpose>
     modify a pending timer's timeout
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>int <function>mod_timer_pending </function></funcdef>
   <paramdef>struct timer_list * <parameter>timer</parameter></paramdef>
   <paramdef>unsigned long <parameter>expires</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>timer</parameter></term>
   <listitem>
    <para>
     the pending timer to be modified
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>expires</parameter></term>
   <listitem>
    <para>
     new timeout in jiffies
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
<title>Description</title>
<para>
   <function>mod_timer_pending</function> is the same for pending timers as <function>mod_timer</function>,
   but will not re-activate and modify already deleted timers.
   </para><para>

   It is useful for unserialized use of timers.
</para>
</refsect1>
</refentry>

<refentry id="API-mod-timer">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>July 2015</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>mod_timer</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.4.104</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>mod_timer</refname>
 <refpurpose>
     modify a timer's timeout
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>int <function>mod_timer </function></funcdef>
   <paramdef>struct timer_list * <parameter>timer</parameter></paramdef>
   <paramdef>unsigned long <parameter>expires</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>timer</parameter></term>
   <listitem>
    <para>
     the timer to be modified
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>expires</parameter></term>
   <listitem>
    <para>
     new timeout in jiffies
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
<title>Description</title>
<para>
   <function>mod_timer</function> is a more efficient way to update the expire field of an
   active timer (if the timer is inactive it will be activated)
   </para><para>

   mod_timer(timer, expires) is equivalent to:
   </para><para>

   del_timer(timer); timer-&gt;expires = expires; add_timer(timer);
   </para><para>

   Note that if there are multiple unserialized concurrent users of the
   same timer, then <function>mod_timer</function> is the only safe way to modify the timeout,
   since <function>add_timer</function> cannot modify an already running timer.
   </para><para>

   The function returns whether it has modified a pending timer or not.
   (ie. <function>mod_timer</function> of an inactive timer returns 0, <function>mod_timer</function> of an
   active timer returns 1.)
</para>
</refsect1>
</refentry>

<refentry id="API-mod-timer-pinned">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>July 2015</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>mod_timer_pinned</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.4.104</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>mod_timer_pinned</refname>
 <refpurpose>
     modify a timer's timeout
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>int <function>mod_timer_pinned </function></funcdef>
   <paramdef>struct timer_list * <parameter>timer</parameter></paramdef>
   <paramdef>unsigned long <parameter>expires</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>timer</parameter></term>
   <listitem>
    <para>
     the timer to be modified
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>expires</parameter></term>
   <listitem>
    <para>
     new timeout in jiffies
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
<title>Description</title>
<para>
   <function>mod_timer_pinned</function> is a way to update the expire field of an
   active timer (if the timer is inactive it will be activated)
   and not allow the timer to be migrated to a different CPU.
   </para><para>

   mod_timer_pinned(timer, expires) is equivalent to:
   </para><para>

   del_timer(timer); timer-&gt;expires = expires; add_timer(timer);
</para>
</refsect1>
</refentry>

<refentry id="API-add-timer">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>July 2015</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>add_timer</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.4.104</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>add_timer</refname>
 <refpurpose>
     start a timer
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>void <function>add_timer </function></funcdef>
   <paramdef>struct timer_list * <parameter>timer</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>timer</parameter></term>
   <listitem>
    <para>
     the timer to be added
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
<title>Description</title>
<para>
   The kernel will do a -&gt;function(-&gt;data) callback from the
   timer interrupt at the -&gt;expires point in the future. The
   current time is 'jiffies'.
   </para><para>

   The timer's -&gt;expires, -&gt;function (and if the handler uses it, -&gt;data)
   fields must be set prior calling this function.
   </para><para>

   Timers with an -&gt;expires field in the past will be executed in the next
   timer tick.
</para>
</refsect1>
</refentry>

<refentry id="API-add-timer-on">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>July 2015</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>add_timer_on</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.4.104</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>add_timer_on</refname>
 <refpurpose>
     start a timer on a particular CPU
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>void <function>add_timer_on </function></funcdef>
   <paramdef>struct timer_list * <parameter>timer</parameter></paramdef>
   <paramdef>int <parameter>cpu</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>timer</parameter></term>
   <listitem>
    <para>
     the timer to be added
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>cpu</parameter></term>
   <listitem>
    <para>
     the CPU to start it on
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
<title>Description</title>
<para>
   This is not very scalable on SMP. Double adds are not possible.
</para>
</refsect1>
</refentry>

<refentry id="API-del-timer">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>July 2015</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>del_timer</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.4.104</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>del_timer</refname>
 <refpurpose>
     deactive a timer.
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>int <function>del_timer </function></funcdef>
   <paramdef>struct timer_list * <parameter>timer</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>timer</parameter></term>
   <listitem>
    <para>
     the timer to be deactivated
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
<title>Description</title>
<para>
   <function>del_timer</function> deactivates a timer - this works on both active and inactive
   timers.
   </para><para>

   The function returns whether it has deactivated a pending timer or not.
   (ie. <function>del_timer</function> of an inactive timer returns 0, <function>del_timer</function> of an
   active timer returns 1.)
</para>
</refsect1>
</refentry>

<refentry id="API-try-to-del-timer-sync">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>July 2015</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>try_to_del_timer_sync</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.4.104</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>try_to_del_timer_sync</refname>
 <refpurpose>
     Try to deactivate a timer
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>int <function>try_to_del_timer_sync </function></funcdef>
   <paramdef>struct timer_list * <parameter>timer</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>timer</parameter></term>
   <listitem>
    <para>
     timer do del
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
<title>Description</title>
<para>
   This function tries to deactivate a timer. Upon successful (ret &gt;= 0)
   exit the timer is not queued and the handler is not running on any CPU.
</para>
</refsect1>
</refentry>

<refentry id="API-del-timer-sync">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>July 2015</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>del_timer_sync</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.4.104</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>del_timer_sync</refname>
 <refpurpose>
     deactivate a timer and wait for the handler to finish.
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>int <function>del_timer_sync </function></funcdef>
   <paramdef>struct timer_list * <parameter>timer</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>timer</parameter></term>
   <listitem>
    <para>
     the timer to be deactivated
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
<title>Description</title>
<para>
   This function only differs from <function>del_timer</function> on SMP: besides deactivating
   the timer it also makes sure the handler has finished executing on other
   CPUs.
</para>
</refsect1>
<refsect1>
<title>Synchronization rules</title>
<para>
   Callers must prevent restarting of the timer,
   otherwise this function is meaningless. It must not be called from
   interrupt contexts. The caller must not hold locks which would prevent
   completion of the timer's handler. The timer's handler must not call
   <function>add_timer_on</function>. Upon exit the timer is not queued and the handler is
   not running on any CPU.
</para>
</refsect1>
<refsect1>
<title>Note</title>
<para>
   You must not hold locks that are held in interrupt context
   while calling this function. Even if the lock has nothing to do
   with the timer in question.  Here's why:
   </para><para>

   CPU0                             CPU1
   ----                             ----
   &lt;SOFTIRQ&gt;
   <function>call_timer_fn</function>;
   base-&gt;running_timer = mytimer;
   spin_lock_irq(somelock);
   &lt;IRQ&gt;
   spin_lock(somelock);
   del_timer_sync(mytimer);
   while (base-&gt;running_timer == mytimer);
   </para><para>

   Now <function>del_timer_sync</function> will never return and never release somelock.
   The interrupt on the other CPU is waiting to grab somelock but
   it has interrupted the softirq that CPU0 is waiting to finish.
   </para><para>

   The function returns whether it has deactivated a pending timer or not.
</para>
</refsect1>
</refentry>

<refentry id="API-schedule-timeout">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>July 2015</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>schedule_timeout</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.4.104</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>schedule_timeout</refname>
 <refpurpose>
     sleep until timeout
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>signed long __sched <function>schedule_timeout </function></funcdef>
   <paramdef>signed long <parameter>timeout</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>timeout</parameter></term>
   <listitem>
    <para>
     timeout value in jiffies
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
<title>Description</title>
<para>
   Make the current task sleep until <parameter>timeout</parameter> jiffies have
   elapsed. The routine will return immediately unless
   the current task state has been set (see <function>set_current_state</function>).
   </para><para>

   You can set the task state as follows -
   </para><para>

   <constant>TASK_UNINTERRUPTIBLE</constant> - at least <parameter>timeout</parameter> jiffies are guaranteed to
   pass before the routine returns. The routine will return 0
   </para><para>

   <constant>TASK_INTERRUPTIBLE</constant> - the routine may return early if a signal is
   delivered to the current task. In this case the remaining time
   in jiffies will be returned, or 0 if the timer expired in time
   </para><para>

   The current task state is guaranteed to be TASK_RUNNING when this
   routine returns.
   </para><para>

   Specifying a <parameter>timeout</parameter> value of <constant>MAX_SCHEDULE_TIMEOUT</constant> will schedule
   the CPU away without a bound on the timeout. In this case the return
   value will be <constant>MAX_SCHEDULE_TIMEOUT</constant>.
   </para><para>

   In all cases the return value is guaranteed to be non-negative.
</para>
</refsect1>
</refentry>

<refentry id="API-msleep">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>July 2015</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>msleep</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.4.104</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>msleep</refname>
 <refpurpose>
     sleep safely even with waitqueue interruptions
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>void <function>msleep </function></funcdef>
   <paramdef>unsigned int <parameter>msecs</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>msecs</parameter></term>
   <listitem>
    <para>
     Time in milliseconds to sleep for
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
</refentry>

<refentry id="API-msleep-interruptible">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>July 2015</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>msleep_interruptible</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.4.104</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>msleep_interruptible</refname>
 <refpurpose>
     sleep waiting for signals
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>unsigned long <function>msleep_interruptible </function></funcdef>
   <paramdef>unsigned int <parameter>msecs</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>msecs</parameter></term>
   <listitem>
    <para>
     Time in milliseconds to sleep for
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
</refentry>

<refentry id="API-usleep-range">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>July 2015</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>usleep_range</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.4.104</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>usleep_range</refname>
 <refpurpose>
     Drop in replacement for udelay where wakeup is flexible
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>void <function>usleep_range </function></funcdef>
   <paramdef>unsigned long <parameter>min</parameter></paramdef>
   <paramdef>unsigned long <parameter>max</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>min</parameter></term>
   <listitem>
    <para>
     Minimum time in usecs to sleep
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>max</parameter></term>
   <listitem>
    <para>
     Maximum time in usecs to sleep
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
</refentry>

     </sect1>
     <sect1><title>Wait queues and Wake events</title>
<!-- include/linux/wait.h -->
<refentry id="API-wait-event">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>July 2015</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>wait_event</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.4.104</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>wait_event</refname>
 <refpurpose>
  sleep until a condition gets true
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef> <function>wait_event </function></funcdef>
   <paramdef> <parameter>wq</parameter></paramdef>
   <paramdef> <parameter>condition</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>wq</parameter></term>
   <listitem>
    <para>
     the waitqueue to wait on
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>condition</parameter></term>
   <listitem>
    <para>
     a C expression for the event to wait for
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
<title>Description</title>
<para>
   The process is put to sleep (TASK_UNINTERRUPTIBLE) until the
   <parameter>condition</parameter> evaluates to true. The <parameter>condition</parameter> is checked each time
   the waitqueue <parameter>wq</parameter> is woken up.
   </para><para>

   <function>wake_up</function> has to be called after changing any variable that could
   change the result of the wait condition.
</para>
</refsect1>
</refentry>

<refentry id="API-wait-event-timeout">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>July 2015</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>wait_event_timeout</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.4.104</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>wait_event_timeout</refname>
 <refpurpose>
     sleep until a condition gets true or a timeout elapses
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef> <function>wait_event_timeout </function></funcdef>
   <paramdef> <parameter>wq</parameter></paramdef>
   <paramdef> <parameter>condition</parameter></paramdef>
   <paramdef> <parameter>timeout</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>wq</parameter></term>
   <listitem>
    <para>
     the waitqueue to wait on
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>condition</parameter></term>
   <listitem>
    <para>
     a C expression for the event to wait for
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>timeout</parameter></term>
   <listitem>
    <para>
     timeout, in jiffies
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
<title>Description</title>
<para>
   The process is put to sleep (TASK_UNINTERRUPTIBLE) until the
   <parameter>condition</parameter> evaluates to true. The <parameter>condition</parameter> is checked each time
   the waitqueue <parameter>wq</parameter> is woken up.
   </para><para>

   <function>wake_up</function> has to be called after changing any variable that could
   change the result of the wait condition.
   </para><para>

   The function returns 0 if the <parameter>timeout</parameter> elapsed, or the remaining
   jiffies (at least 1) if the <parameter>condition</parameter> evaluated to <constant>true</constant> before
   the <parameter>timeout</parameter> elapsed.
</para>
</refsect1>
</refentry>

<refentry id="API-wait-event-interruptible">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>July 2015</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>wait_event_interruptible</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.4.104</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>wait_event_interruptible</refname>
 <refpurpose>
     sleep until a condition gets true
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef> <function>wait_event_interruptible </function></funcdef>
   <paramdef> <parameter>wq</parameter></paramdef>
   <paramdef> <parameter>condition</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>wq</parameter></term>
   <listitem>
    <para>
     the waitqueue to wait on
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>condition</parameter></term>
   <listitem>
    <para>
     a C expression for the event to wait for
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
<title>Description</title>
<para>
   The process is put to sleep (TASK_INTERRUPTIBLE) until the
   <parameter>condition</parameter> evaluates to true or a signal is received.
   The <parameter>condition</parameter> is checked each time the waitqueue <parameter>wq</parameter> is woken up.
   </para><para>

   <function>wake_up</function> has to be called after changing any variable that could
   change the result of the wait condition.
   </para><para>

   The function will return -ERESTARTSYS if it was interrupted by a
   signal and 0 if <parameter>condition</parameter> evaluated to true.
</para>
</refsect1>
</refentry>

<refentry id="API-wait-event-interruptible-timeout">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>July 2015</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>wait_event_interruptible_timeout</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.4.104</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>wait_event_interruptible_timeout</refname>
 <refpurpose>
     sleep until a condition gets true or a timeout elapses
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef> <function>wait_event_interruptible_timeout </function></funcdef>
   <paramdef> <parameter>wq</parameter></paramdef>
   <paramdef> <parameter>condition</parameter></paramdef>
   <paramdef> <parameter>timeout</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>wq</parameter></term>
   <listitem>
    <para>
     the waitqueue to wait on
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>condition</parameter></term>
   <listitem>
    <para>
     a C expression for the event to wait for
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>timeout</parameter></term>
   <listitem>
    <para>
     timeout, in jiffies
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
<title>Description</title>
<para>
   The process is put to sleep (TASK_INTERRUPTIBLE) until the
   <parameter>condition</parameter> evaluates to true or a signal is received.
   The <parameter>condition</parameter> is checked each time the waitqueue <parameter>wq</parameter> is woken up.
   </para><para>

   <function>wake_up</function> has to be called after changing any variable that could
   change the result of the wait condition.
</para>
</refsect1>
<refsect1>
<title>Returns</title>
<para>
   0 if the <parameter>timeout</parameter> elapsed, -<constant>ERESTARTSYS</constant> if it was interrupted by
   a signal, or the remaining jiffies (at least 1) if the <parameter>condition</parameter>
   evaluated to <constant>true</constant> before the <parameter>timeout</parameter> elapsed.
</para>
</refsect1>
</refentry>

<refentry id="API-wait-event-interruptible-locked">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>July 2015</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>wait_event_interruptible_locked</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.4.104</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>wait_event_interruptible_locked</refname>
 <refpurpose>
     sleep until a condition gets true
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef> <function>wait_event_interruptible_locked </function></funcdef>
   <paramdef> <parameter>wq</parameter></paramdef>
   <paramdef> <parameter>condition</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>wq</parameter></term>
   <listitem>
    <para>
     the waitqueue to wait on
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>condition</parameter></term>
   <listitem>
    <para>
     a C expression for the event to wait for
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
<title>Description</title>
<para>
   The process is put to sleep (TASK_INTERRUPTIBLE) until the
   <parameter>condition</parameter> evaluates to true or a signal is received.
   The <parameter>condition</parameter> is checked each time the waitqueue <parameter>wq</parameter> is woken up.
   </para><para>

   It must be called with wq.lock being held.  This spinlock is
   unlocked while sleeping but <parameter>condition</parameter> testing is done while lock
   is held and when this macro exits the lock is held.
   </para><para>

   The lock is locked/unlocked using <function>spin_lock</function>/<function>spin_unlock</function>
   functions which must match the way they are locked/unlocked outside
   of this macro.
   </para><para>

   <function>wake_up_locked</function> has to be called after changing any variable that could
   change the result of the wait condition.
   </para><para>

   The function will return -ERESTARTSYS if it was interrupted by a
   signal and 0 if <parameter>condition</parameter> evaluated to true.
</para>
</refsect1>
</refentry>

<refentry id="API-wait-event-interruptible-locked-irq">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>July 2015</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>wait_event_interruptible_locked_irq</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.4.104</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>wait_event_interruptible_locked_irq</refname>
 <refpurpose>
     sleep until a condition gets true
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef> <function>wait_event_interruptible_locked_irq </function></funcdef>
   <paramdef> <parameter>wq</parameter></paramdef>
   <paramdef> <parameter>condition</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>wq</parameter></term>
   <listitem>
    <para>
     the waitqueue to wait on
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>condition</parameter></term>
   <listitem>
    <para>
     a C expression for the event to wait for
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
<title>Description</title>
<para>
   The process is put to sleep (TASK_INTERRUPTIBLE) until the
   <parameter>condition</parameter> evaluates to true or a signal is received.
   The <parameter>condition</parameter> is checked each time the waitqueue <parameter>wq</parameter> is woken up.
   </para><para>

   It must be called with wq.lock being held.  This spinlock is
   unlocked while sleeping but <parameter>condition</parameter> testing is done while lock
   is held and when this macro exits the lock is held.
   </para><para>

   The lock is locked/unlocked using <function>spin_lock_irq</function>/<function>spin_unlock_irq</function>
   functions which must match the way they are locked/unlocked outside
   of this macro.
   </para><para>

   <function>wake_up_locked</function> has to be called after changing any variable that could
   change the result of the wait condition.
   </para><para>

   The function will return -ERESTARTSYS if it was interrupted by a
   signal and 0 if <parameter>condition</parameter> evaluated to true.
</para>
</refsect1>
</refentry>

<refentry id="API-wait-event-interruptible-exclusive-locked">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>July 2015</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>wait_event_interruptible_exclusive_locked</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.4.104</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>wait_event_interruptible_exclusive_locked</refname>
 <refpurpose>
     sleep exclusively until a condition gets true
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef> <function>wait_event_interruptible_exclusive_locked </function></funcdef>
   <paramdef> <parameter>wq</parameter></paramdef>
   <paramdef> <parameter>condition</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>wq</parameter></term>
   <listitem>
    <para>
     the waitqueue to wait on
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>condition</parameter></term>
   <listitem>
    <para>
     a C expression for the event to wait for
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
<title>Description</title>
<para>
   The process is put to sleep (TASK_INTERRUPTIBLE) until the
   <parameter>condition</parameter> evaluates to true or a signal is received.
   The <parameter>condition</parameter> is checked each time the waitqueue <parameter>wq</parameter> is woken up.
   </para><para>

   It must be called with wq.lock being held.  This spinlock is
   unlocked while sleeping but <parameter>condition</parameter> testing is done while lock
   is held and when this macro exits the lock is held.
   </para><para>

   The lock is locked/unlocked using <function>spin_lock</function>/<function>spin_unlock</function>
   functions which must match the way they are locked/unlocked outside
   of this macro.
   </para><para>

   The process is put on the wait queue with an WQ_FLAG_EXCLUSIVE flag
   set thus when other process waits process on the list if this
   process is awaken further processes are not considered.
   </para><para>

   <function>wake_up_locked</function> has to be called after changing any variable that could
   change the result of the wait condition.
   </para><para>

   The function will return -ERESTARTSYS if it was interrupted by a
   signal and 0 if <parameter>condition</parameter> evaluated to true.
</para>
</refsect1>
</refentry>

<refentry id="API-wait-event-interruptible-exclusive-locked-irq">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>July 2015</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>wait_event_interruptible_exclusive_locked_irq</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.4.104</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>wait_event_interruptible_exclusive_locked_irq</refname>
 <refpurpose>
     sleep until a condition gets true
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef> <function>wait_event_interruptible_exclusive_locked_irq </function></funcdef>
   <paramdef> <parameter>wq</parameter></paramdef>
   <paramdef> <parameter>condition</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>wq</parameter></term>
   <listitem>
    <para>
     the waitqueue to wait on
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>condition</parameter></term>
   <listitem>
    <para>
     a C expression for the event to wait for
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
<title>Description</title>
<para>
   The process is put to sleep (TASK_INTERRUPTIBLE) until the
   <parameter>condition</parameter> evaluates to true or a signal is received.
   The <parameter>condition</parameter> is checked each time the waitqueue <parameter>wq</parameter> is woken up.
   </para><para>

   It must be called with wq.lock being held.  This spinlock is
   unlocked while sleeping but <parameter>condition</parameter> testing is done while lock
   is held and when this macro exits the lock is held.
   </para><para>

   The lock is locked/unlocked using <function>spin_lock_irq</function>/<function>spin_unlock_irq</function>
   functions which must match the way they are locked/unlocked outside
   of this macro.
   </para><para>

   The process is put on the wait queue with an WQ_FLAG_EXCLUSIVE flag
   set thus when other process waits process on the list if this
   process is awaken further processes are not considered.
   </para><para>

   <function>wake_up_locked</function> has to be called after changing any variable that could
   change the result of the wait condition.
   </para><para>

   The function will return -ERESTARTSYS if it was interrupted by a
   signal and 0 if <parameter>condition</parameter> evaluated to true.
</para>
</refsect1>
</refentry>

<refentry id="API-wait-event-interruptible-lock-irq-timeout">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>July 2015</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>wait_event_interruptible_lock_irq_timeout</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.4.104</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>wait_event_interruptible_lock_irq_timeout</refname>
 <refpurpose>
     sleep until a condition gets true or a timeout elapses. The condition is checked under the lock. This is expected to be called with the lock taken.
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef> <function>wait_event_interruptible_lock_irq_timeout </function></funcdef>
   <paramdef> <parameter>wq</parameter></paramdef>
   <paramdef> <parameter>condition</parameter></paramdef>
   <paramdef> <parameter>lock</parameter></paramdef>
   <paramdef> <parameter>timeout</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>wq</parameter></term>
   <listitem>
    <para>
     the waitqueue to wait on
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>condition</parameter></term>
   <listitem>
    <para>
     a C expression for the event to wait for
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>lock</parameter></term>
   <listitem>
    <para>
     a locked spinlock_t, which will be released before <function>schedule</function>
     and reacquired afterwards.
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>timeout</parameter></term>
   <listitem>
    <para>
     timeout, in jiffies
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
<title>Description</title>
<para>
   The process is put to sleep (TASK_INTERRUPTIBLE) until the
   <parameter>condition</parameter> evaluates to true or signal is received. The <parameter>condition</parameter> is
   checked each time the waitqueue <parameter>wq</parameter> is woken up.
   </para><para>

   <function>wake_up</function> has to be called after changing any variable that could
   change the result of the wait condition.
   </para><para>

   This is supposed to be called while holding the lock. The lock is
   dropped before going to sleep and is reacquired afterwards.
   </para><para>

   The function returns 0 if the <parameter>timeout</parameter> elapsed, -ERESTARTSYS if it
   was interrupted by a signal, and the remaining jiffies otherwise
   if the condition evaluated to true before the timeout elapsed.
</para>
</refsect1>
</refentry>

<refentry id="API-wait-event-killable">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>July 2015</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>wait_event_killable</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.4.104</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>wait_event_killable</refname>
 <refpurpose>
     sleep until a condition gets true
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef> <function>wait_event_killable </function></funcdef>
   <paramdef> <parameter>wq</parameter></paramdef>
   <paramdef> <parameter>condition</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>wq</parameter></term>
   <listitem>
    <para>
     the waitqueue to wait on
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>condition</parameter></term>
   <listitem>
    <para>
     a C expression for the event to wait for
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
<title>Description</title>
<para>
   The process is put to sleep (TASK_KILLABLE) until the
   <parameter>condition</parameter> evaluates to true or a signal is received.
   The <parameter>condition</parameter> is checked each time the waitqueue <parameter>wq</parameter> is woken up.
   </para><para>

   <function>wake_up</function> has to be called after changing any variable that could
   change the result of the wait condition.
   </para><para>

   The function will return -ERESTARTSYS if it was interrupted by a
   signal and 0 if <parameter>condition</parameter> evaluated to true.
</para>
</refsect1>
</refentry>

<refentry id="API-wait-on-bit">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>July 2015</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>wait_on_bit</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.4.104</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>wait_on_bit</refname>
 <refpurpose>
     wait for a bit to be cleared
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>int <function>wait_on_bit </function></funcdef>
   <paramdef>void * <parameter>word</parameter></paramdef>
   <paramdef>int <parameter>bit</parameter></paramdef>
   <paramdef>int (*<parameter>action</parameter>)
     <funcparams>void *</funcparams></paramdef>
   <paramdef>unsigned <parameter>mode</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>word</parameter></term>
   <listitem>
    <para>
     the word being waited on, a kernel virtual address
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>bit</parameter></term>
   <listitem>
    <para>
     the bit of the word being waited on
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>action</parameter></term>
   <listitem>
    <para>
     the function used to sleep, which may take special actions
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>mode</parameter></term>
   <listitem>
    <para>
     the task state to sleep in
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
<title>Description</title>
<para>
   There is a standard hashed waitqueue table for generic use. This
   is the part of the hashtable's accessor API that waits on a bit.
   For instance, if one were to have waiters on a bitflag, one would
   call <function>wait_on_bit</function> in threads waiting for the bit to clear.
   One uses <function>wait_on_bit</function> where one is waiting for the bit to clear,
   but has no intention of setting it.
</para>
</refsect1>
</refentry>

<refentry id="API-wait-on-bit-lock">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>July 2015</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>wait_on_bit_lock</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.4.104</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>wait_on_bit_lock</refname>
 <refpurpose>
     wait for a bit to be cleared, when wanting to set it
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>int <function>wait_on_bit_lock </function></funcdef>
   <paramdef>void * <parameter>word</parameter></paramdef>
   <paramdef>int <parameter>bit</parameter></paramdef>
   <paramdef>int (*<parameter>action</parameter>)
     <funcparams>void *</funcparams></paramdef>
   <paramdef>unsigned <parameter>mode</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>word</parameter></term>
   <listitem>
    <para>
     the word being waited on, a kernel virtual address
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>bit</parameter></term>
   <listitem>
    <para>
     the bit of the word being waited on
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>action</parameter></term>
   <listitem>
    <para>
     the function used to sleep, which may take special actions
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>mode</parameter></term>
   <listitem>
    <para>
     the task state to sleep in
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
<title>Description</title>
<para>
   There is a standard hashed waitqueue table for generic use. This
   is the part of the hashtable's accessor API that waits on a bit
   when one intends to set it, for instance, trying to lock bitflags.
   For instance, if one were to have waiters trying to set bitflag
   and waiting for it to clear before setting it, one would call
   <function>wait_on_bit</function> in threads waiting to be able to set the bit.
   One uses <function>wait_on_bit_lock</function> where one is waiting for the bit to
   clear with the intention of setting it, and when done, clearing it.
</para>
</refsect1>
</refentry>

<!-- kernel/wait.c -->
<refentry id="API-finish-wait">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>July 2015</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>finish_wait</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.4.104</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>finish_wait</refname>
 <refpurpose>
  clean up after waiting in a queue
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>void <function>finish_wait </function></funcdef>
   <paramdef>wait_queue_head_t * <parameter>q</parameter></paramdef>
   <paramdef>wait_queue_t * <parameter>wait</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>q</parameter></term>
   <listitem>
    <para>
     waitqueue waited on
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>wait</parameter></term>
   <listitem>
    <para>
     wait descriptor
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
<title>Description</title>
<para>
   Sets current thread back to running state and removes
   the wait descriptor from the given waitqueue if still
   queued.
</para>
</refsect1>
</refentry>

<refentry id="API-abort-exclusive-wait">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>July 2015</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>abort_exclusive_wait</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.4.104</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>abort_exclusive_wait</refname>
 <refpurpose>
     abort exclusive waiting in a queue
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>void <function>abort_exclusive_wait </function></funcdef>
   <paramdef>wait_queue_head_t * <parameter>q</parameter></paramdef>
   <paramdef>wait_queue_t * <parameter>wait</parameter></paramdef>
   <paramdef>unsigned int <parameter>mode</parameter></paramdef>
   <paramdef>void * <parameter>key</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>q</parameter></term>
   <listitem>
    <para>
     waitqueue waited on
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>wait</parameter></term>
   <listitem>
    <para>
     wait descriptor
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>mode</parameter></term>
   <listitem>
    <para>
     runstate of the waiter to be woken
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>key</parameter></term>
   <listitem>
    <para>
     key to identify a wait bit queue or <constant>NULL</constant>
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
<title>Description</title>
<para>
   Sets current thread back to running state and removes
   the wait descriptor from the given waitqueue if still
   queued.
   </para><para>

   Wakes up the next waiter if the caller is concurrently
   woken up through the queue.
   </para><para>

   This prevents waiter starvation where an exclusive waiter
   aborts and is woken up concurrently and no one wakes up
   the next waiter.
</para>
</refsect1>
</refentry>

<refentry id="API-wake-up-bit">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>July 2015</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>wake_up_bit</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.4.104</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>wake_up_bit</refname>
 <refpurpose>
     wake up a waiter on a bit
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>void <function>wake_up_bit </function></funcdef>
   <paramdef>void * <parameter>word</parameter></paramdef>
   <paramdef>int <parameter>bit</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>word</parameter></term>
   <listitem>
    <para>
     the word being waited on, a kernel virtual address
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>bit</parameter></term>
   <listitem>
    <para>
     the bit of the word being waited on
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
<title>Description</title>
<para>
   There is a standard hashed waitqueue table for generic use. This
   is the part of the hashtable's accessor API that wakes up waiters
   on a bit. For instance, if one were to have waiters on a bitflag,
   one would call <function>wake_up_bit</function> after clearing the bit.
   </para><para>

   In order for this to function properly, as it uses <function>waitqueue_active</function>
   internally, some kind of memory barrier must be done prior to calling
   this. Typically, this will be <function>smp_mb__after_clear_bit</function>, but in some
   cases where bitflags are manipulated non-atomically under a lock, one
   may need to use a less regular barrier, such fs/inode.c's <function>smp_mb</function>,
   because <function>spin_unlock</function> does not guarantee a memory barrier.
</para>
</refsect1>
</refentry>

     </sect1>
     <sect1><title>High-resolution timers</title>
<!-- include/linux/ktime.h -->
<refentry id="API-ktime-set">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>July 2015</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>ktime_set</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.4.104</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>ktime_set</refname>
 <refpurpose>
  Set a ktime_t variable from a seconds/nanoseconds value
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>ktime_t <function>ktime_set </function></funcdef>
   <paramdef>const long <parameter>secs</parameter></paramdef>
   <paramdef>const unsigned long <parameter>nsecs</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>secs</parameter></term>
   <listitem>
    <para>
     seconds to set
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>nsecs</parameter></term>
   <listitem>
    <para>
     nanoseconds to set
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
<title>Description</title>
<para>
   Return the ktime_t representation of the value
</para>
</refsect1>
</refentry>

<refentry id="API-ktime-sub">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>July 2015</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>ktime_sub</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.4.104</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>ktime_sub</refname>
 <refpurpose>
     subtract two ktime_t variables
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>ktime_t <function>ktime_sub </function></funcdef>
   <paramdef>const ktime_t <parameter>lhs</parameter></paramdef>
   <paramdef>const ktime_t <parameter>rhs</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>lhs</parameter></term>
   <listitem>
    <para>
     minuend
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>rhs</parameter></term>
   <listitem>
    <para>
     subtrahend
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
<title>Description</title>
<para>
   Returns the remainder of the subtraction
</para>
</refsect1>
</refentry>

<refentry id="API-ktime-add">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>July 2015</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>ktime_add</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.4.104</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>ktime_add</refname>
 <refpurpose>
     add two ktime_t variables
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>ktime_t <function>ktime_add </function></funcdef>
   <paramdef>const ktime_t <parameter>add1</parameter></paramdef>
   <paramdef>const ktime_t <parameter>add2</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>add1</parameter></term>
   <listitem>
    <para>
     addend1
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>add2</parameter></term>
   <listitem>
    <para>
     addend2
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
<title>Description</title>
<para>
   Returns the sum of <parameter>add1</parameter> and <parameter>add2</parameter>.
</para>
</refsect1>
</refentry>

<refentry id="API-timespec-to-ktime">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>July 2015</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>timespec_to_ktime</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.4.104</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>timespec_to_ktime</refname>
 <refpurpose>
     convert a timespec to ktime_t format
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>ktime_t <function>timespec_to_ktime </function></funcdef>
   <paramdef>const struct timespec <parameter>ts</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>ts</parameter></term>
   <listitem>
    <para>
     the timespec variable to convert
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
<title>Description</title>
<para>
   Returns a ktime_t variable with the converted timespec value
</para>
</refsect1>
</refentry>

<refentry id="API-timeval-to-ktime">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>July 2015</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>timeval_to_ktime</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.4.104</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>timeval_to_ktime</refname>
 <refpurpose>
     convert a timeval to ktime_t format
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>ktime_t <function>timeval_to_ktime </function></funcdef>
   <paramdef>const struct timeval <parameter>tv</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>tv</parameter></term>
   <listitem>
    <para>
     the timeval variable to convert
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
<title>Description</title>
<para>
   Returns a ktime_t variable with the converted timeval value
</para>
</refsect1>
</refentry>

<refentry id="API-ktime-to-timespec">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>July 2015</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>ktime_to_timespec</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.4.104</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>ktime_to_timespec</refname>
 <refpurpose>
     convert a ktime_t variable to timespec format
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>struct timespec <function>ktime_to_timespec </function></funcdef>
   <paramdef>const ktime_t <parameter>kt</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>kt</parameter></term>
   <listitem>
    <para>
     the ktime_t variable to convert
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
<title>Description</title>
<para>
   Returns the timespec representation of the ktime value
</para>
</refsect1>
</refentry>

<refentry id="API-ktime-to-timeval">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>July 2015</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>ktime_to_timeval</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.4.104</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>ktime_to_timeval</refname>
 <refpurpose>
     convert a ktime_t variable to timeval format
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>struct timeval <function>ktime_to_timeval </function></funcdef>
   <paramdef>const ktime_t <parameter>kt</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>kt</parameter></term>
   <listitem>
    <para>
     the ktime_t variable to convert
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
<title>Description</title>
<para>
   Returns the timeval representation of the ktime value
</para>
</refsect1>
</refentry>

<refentry id="API-ktime-to-ns">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>July 2015</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>ktime_to_ns</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.4.104</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>ktime_to_ns</refname>
 <refpurpose>
     convert a ktime_t variable to scalar nanoseconds
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>s64 <function>ktime_to_ns </function></funcdef>
   <paramdef>const ktime_t <parameter>kt</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>kt</parameter></term>
   <listitem>
    <para>
     the ktime_t variable to convert
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
<title>Description</title>
<para>
   Returns the scalar nanoseconds representation of <parameter>kt</parameter>
</para>
</refsect1>
</refentry>

<refentry id="API-ktime-equal">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>July 2015</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>ktime_equal</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.4.104</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>ktime_equal</refname>
 <refpurpose>
     Compares two ktime_t variables to see if they are equal
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>int <function>ktime_equal </function></funcdef>
   <paramdef>const ktime_t <parameter>cmp1</parameter></paramdef>
   <paramdef>const ktime_t <parameter>cmp2</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>cmp1</parameter></term>
   <listitem>
    <para>
     comparable1
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>cmp2</parameter></term>
   <listitem>
    <para>
     comparable2
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
<title>Description</title>
<para>
   Compare two ktime_t variables, returns 1 if equal
</para>
</refsect1>
</refentry>

<!-- include/linux/hrtimer.h -->
<refentry id="API-struct-hrtimer">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>July 2015</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>struct hrtimer</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.4.104</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>struct hrtimer</refname>
 <refpurpose>
  the basic hrtimer structure
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <programlisting>
struct hrtimer {
  struct timerqueue_node node;
  ktime_t _softexpires;
  enum hrtimer_restart		(* function) (struct hrtimer *);
  struct hrtimer_clock_base * base;
  unsigned long state;
#ifdef CONFIG_TIMER_STATS
  int start_pid;
  void * start_site;
  char start_comm[16];
#endif
};  </programlisting>
</refsynopsisdiv>
 <refsect1>
  <title>Members</title>
  <variablelist>
    <varlistentry>      <term>node</term>
      <listitem><para>
timerqueue node, which also manages node.expires,
the absolute expiry time in the hrtimers internal
representation. The time is related to the clock on
which the timer is based. Is setup by adding
slack to the _softexpires value. For non range timers
identical to _softexpires.
      </para></listitem>
    </varlistentry>
    <varlistentry>      <term>_softexpires</term>
      <listitem><para>
the absolute earliest expiry time of the hrtimer.
The time which was given as expiry time when the timer
was armed.
      </para></listitem>
    </varlistentry>
    <varlistentry>      <term>function</term>
      <listitem><para>
timer expiry callback function
      </para></listitem>
    </varlistentry>
    <varlistentry>      <term>base</term>
      <listitem><para>
pointer to the timer base (per cpu and per clock)
      </para></listitem>
    </varlistentry>
    <varlistentry>      <term>state</term>
      <listitem><para>
state information (See bit values above)
      </para></listitem>
    </varlistentry>
    <varlistentry>      <term>start_pid</term>
      <listitem><para>
timer statistics field to store the pid of the task which
started the timer
      </para></listitem>
    </varlistentry>
    <varlistentry>      <term>start_site</term>
      <listitem><para>
timer statistics field to store the site where the timer
was started
      </para></listitem>
    </varlistentry>
    <varlistentry>      <term>start_comm[16]</term>
      <listitem><para>
timer statistics field to store the name of the process which
started the timer
      </para></listitem>
    </varlistentry>
  </variablelist>
 </refsect1>
<refsect1>
<title>Description</title>
<para>
   The hrtimer structure must be initialized by <function>hrtimer_init</function>
</para>
</refsect1>
</refentry>

<refentry id="API-struct-hrtimer-sleeper">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>July 2015</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>struct hrtimer_sleeper</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.4.104</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>struct hrtimer_sleeper</refname>
 <refpurpose>
     simple sleeper structure
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <programlisting>
struct hrtimer_sleeper {
  struct hrtimer timer;
  struct task_struct * task;
};  </programlisting>
</refsynopsisdiv>
 <refsect1>
  <title>Members</title>
  <variablelist>
    <varlistentry>      <term>timer</term>
      <listitem><para>
   embedded timer structure
      </para></listitem>
    </varlistentry>
    <varlistentry>      <term>task</term>
      <listitem><para>
   task to wake up
      </para></listitem>
    </varlistentry>
  </variablelist>
 </refsect1>
<refsect1>
<title>Description</title>
<para>
   task is set to NULL, when the timer expires.
</para>
</refsect1>
</refentry>

<refentry id="API-struct-hrtimer-clock-base">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>July 2015</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>struct hrtimer_clock_base</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.4.104</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>struct hrtimer_clock_base</refname>
 <refpurpose>
     the timer base for a specific clock
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <programlisting>
struct hrtimer_clock_base {
  struct hrtimer_cpu_base * cpu_base;
  int index;
  clockid_t clockid;
  struct timerqueue_head active;
  ktime_t resolution;
  ktime_t (* get_time) (void);
  ktime_t softirq_time;
  ktime_t offset;
};  </programlisting>
</refsynopsisdiv>
 <refsect1>
  <title>Members</title>
  <variablelist>
    <varlistentry>      <term>cpu_base</term>
      <listitem><para>
   per cpu clock base
      </para></listitem>
    </varlistentry>
    <varlistentry>      <term>index</term>
      <listitem><para>
   clock type index for per_cpu support when moving a
   timer to a base on another cpu.
      </para></listitem>
    </varlistentry>
    <varlistentry>      <term>clockid</term>
      <listitem><para>
   clock id for per_cpu support
      </para></listitem>
    </varlistentry>
    <varlistentry>      <term>active</term>
      <listitem><para>
   red black tree root node for the active timers
      </para></listitem>
    </varlistentry>
    <varlistentry>      <term>resolution</term>
      <listitem><para>
   the resolution of the clock, in nanoseconds
      </para></listitem>
    </varlistentry>
    <varlistentry>      <term>get_time</term>
      <listitem><para>
   function to retrieve the current time of the clock
      </para></listitem>
    </varlistentry>
    <varlistentry>      <term>softirq_time</term>
      <listitem><para>
   the time when running the hrtimer queue in the softirq
      </para></listitem>
    </varlistentry>
    <varlistentry>      <term>offset</term>
      <listitem><para>
   offset of this clock to the monotonic base
      </para></listitem>
    </varlistentry>
  </variablelist>
 </refsect1>
</refentry>

<!-- kernel/hrtimer.c -->
<refentry id="API-ktime-add-ns">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>July 2015</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>ktime_add_ns</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.4.104</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>ktime_add_ns</refname>
 <refpurpose>
  Add a scalar nanoseconds value to a ktime_t variable
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>ktime_t <function>ktime_add_ns </function></funcdef>
   <paramdef>const ktime_t <parameter>kt</parameter></paramdef>
   <paramdef>u64 <parameter>nsec</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>kt</parameter></term>
   <listitem>
    <para>
     addend
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>nsec</parameter></term>
   <listitem>
    <para>
     the scalar nsec value to add
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
<title>Description</title>
<para>
   Returns the sum of kt and nsec in ktime_t format
</para>
</refsect1>
</refentry>

<refentry id="API-ktime-sub-ns">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>July 2015</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>ktime_sub_ns</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.4.104</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>ktime_sub_ns</refname>
 <refpurpose>
     Subtract a scalar nanoseconds value from a ktime_t variable
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>ktime_t <function>ktime_sub_ns </function></funcdef>
   <paramdef>const ktime_t <parameter>kt</parameter></paramdef>
   <paramdef>u64 <parameter>nsec</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>kt</parameter></term>
   <listitem>
    <para>
     minuend
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>nsec</parameter></term>
   <listitem>
    <para>
     the scalar nsec value to subtract
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
<title>Description</title>
<para>
   Returns the subtraction of <parameter>nsec</parameter> from <parameter>kt</parameter> in ktime_t format
</para>
</refsect1>
</refentry>

<refentry id="API-hrtimer-forward">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>July 2015</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>hrtimer_forward</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.4.104</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>hrtimer_forward</refname>
 <refpurpose>
     forward the timer expiry
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>u64 <function>hrtimer_forward </function></funcdef>
   <paramdef>struct hrtimer * <parameter>timer</parameter></paramdef>
   <paramdef>ktime_t <parameter>now</parameter></paramdef>
   <paramdef>ktime_t <parameter>interval</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>timer</parameter></term>
   <listitem>
    <para>
     hrtimer to forward
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>now</parameter></term>
   <listitem>
    <para>
     forward past this time
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>interval</parameter></term>
   <listitem>
    <para>
     the interval to forward
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
<title>Description</title>
<para>
   Forward the timer expiry so it will expire in the future.
   Returns the number of overruns.
</para>
</refsect1>
</refentry>

<refentry id="API-hrtimer-start-range-ns">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>July 2015</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>hrtimer_start_range_ns</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.4.104</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>hrtimer_start_range_ns</refname>
 <refpurpose>
     (re)start an hrtimer on the current CPU
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>int <function>hrtimer_start_range_ns </function></funcdef>
   <paramdef>struct hrtimer * <parameter>timer</parameter></paramdef>
   <paramdef>ktime_t <parameter>tim</parameter></paramdef>
   <paramdef>unsigned long <parameter>delta_ns</parameter></paramdef>
   <paramdef>const enum hrtimer_mode <parameter>mode</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>timer</parameter></term>
   <listitem>
    <para>
     the timer to be added
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>tim</parameter></term>
   <listitem>
    <para>
     expiry time
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>delta_ns</parameter></term>
   <listitem>
    <para>
     "slack" range for the timer
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>mode</parameter></term>
   <listitem>
    <para>
     expiry mode: absolute (HRTIMER_ABS) or relative (HRTIMER_REL)
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
<title>Returns</title>
<para>
   0 on success
   1 when the timer was active
</para>
</refsect1>
</refentry>

<refentry id="API-hrtimer-start">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>July 2015</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>hrtimer_start</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.4.104</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>hrtimer_start</refname>
 <refpurpose>
     (re)start an hrtimer on the current CPU
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>int <function>hrtimer_start </function></funcdef>
   <paramdef>struct hrtimer * <parameter>timer</parameter></paramdef>
   <paramdef>ktime_t <parameter>tim</parameter></paramdef>
   <paramdef>const enum hrtimer_mode <parameter>mode</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>timer</parameter></term>
   <listitem>
    <para>
     the timer to be added
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>tim</parameter></term>
   <listitem>
    <para>
     expiry time
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>mode</parameter></term>
   <listitem>
    <para>
     expiry mode: absolute (HRTIMER_ABS) or relative (HRTIMER_REL)
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
<title>Returns</title>
<para>
   0 on success
   1 when the timer was active
</para>
</refsect1>
</refentry>

<refentry id="API-hrtimer-try-to-cancel">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>July 2015</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>hrtimer_try_to_cancel</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.4.104</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>hrtimer_try_to_cancel</refname>
 <refpurpose>
     try to deactivate a timer
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>int <function>hrtimer_try_to_cancel </function></funcdef>
   <paramdef>struct hrtimer * <parameter>timer</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>timer</parameter></term>
   <listitem>
    <para>
     hrtimer to stop
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
<title>Returns</title>
<para>
   0 when the timer was not active
   1 when the timer was active
   -1 when the timer is currently excuting the callback function and
   cannot be stopped
</para>
</refsect1>
</refentry>

<refentry id="API-hrtimer-cancel">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>July 2015</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>hrtimer_cancel</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.4.104</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>hrtimer_cancel</refname>
 <refpurpose>
     cancel a timer and wait for the handler to finish.
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>int <function>hrtimer_cancel </function></funcdef>
   <paramdef>struct hrtimer * <parameter>timer</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>timer</parameter></term>
   <listitem>
    <para>
     the timer to be cancelled
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
<title>Returns</title>
<para>
   0 when the timer was not active
   1 when the timer was active
</para>
</refsect1>
</refentry>

<refentry id="API-hrtimer-get-remaining">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>July 2015</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>hrtimer_get_remaining</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.4.104</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>hrtimer_get_remaining</refname>
 <refpurpose>
     get remaining time for the timer
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>ktime_t <function>hrtimer_get_remaining </function></funcdef>
   <paramdef>const struct hrtimer * <parameter>timer</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>timer</parameter></term>
   <listitem>
    <para>
     the timer to read
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
</refentry>

<refentry id="API-hrtimer-init">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>July 2015</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>hrtimer_init</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.4.104</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>hrtimer_init</refname>
 <refpurpose>
     initialize a timer to the given clock
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>void <function>hrtimer_init </function></funcdef>
   <paramdef>struct hrtimer * <parameter>timer</parameter></paramdef>
   <paramdef>clockid_t <parameter>clock_id</parameter></paramdef>
   <paramdef>enum hrtimer_mode <parameter>mode</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>timer</parameter></term>
   <listitem>
    <para>
     the timer to be initialized
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>clock_id</parameter></term>
   <listitem>
    <para>
     the clock to be used
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>mode</parameter></term>
   <listitem>
    <para>
     timer mode abs/rel
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
</refentry>

<refentry id="API-hrtimer-get-res">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>July 2015</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>hrtimer_get_res</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.4.104</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>hrtimer_get_res</refname>
 <refpurpose>
     get the timer resolution for a clock
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>int <function>hrtimer_get_res </function></funcdef>
   <paramdef>const clockid_t <parameter>which_clock</parameter></paramdef>
   <paramdef>struct timespec * <parameter>tp</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>which_clock</parameter></term>
   <listitem>
    <para>
     which clock to query
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>tp</parameter></term>
   <listitem>
    <para>
     pointer to timespec variable to store the resolution
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
<title>Description</title>
<para>
   Store the resolution of the clock selected by <parameter>which_clock</parameter> in the
   variable pointed to by <parameter>tp</parameter>.
</para>
</refsect1>
</refentry>

<refentry id="API-schedule-hrtimeout-range">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>July 2015</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>schedule_hrtimeout_range</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.4.104</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>schedule_hrtimeout_range</refname>
 <refpurpose>
     sleep until timeout
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>int __sched <function>schedule_hrtimeout_range </function></funcdef>
   <paramdef>ktime_t * <parameter>expires</parameter></paramdef>
   <paramdef>unsigned long <parameter>delta</parameter></paramdef>
   <paramdef>const enum hrtimer_mode <parameter>mode</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>expires</parameter></term>
   <listitem>
    <para>
     timeout value (ktime_t)
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>delta</parameter></term>
   <listitem>
    <para>
     slack in expires timeout (ktime_t)
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>mode</parameter></term>
   <listitem>
    <para>
     timer mode, HRTIMER_MODE_ABS or HRTIMER_MODE_REL
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
<title>Description</title>
<para>
   Make the current task sleep until the given expiry time has
   elapsed. The routine will return immediately unless
   the current task state has been set (see <function>set_current_state</function>).
   </para><para>

   The <parameter>delta</parameter> argument gives the kernel the freedom to schedule the
   actual wakeup to a time that is both power and performance friendly.
   The kernel give the normal best effort behavior for "<parameter>expires</parameter>+<parameter>delta</parameter>",
   but may decide to fire the timer earlier, but no earlier than <parameter>expires</parameter>.
   </para><para>

   You can set the task state as follows -
   </para><para>

   <constant>TASK_UNINTERRUPTIBLE</constant> - at least <parameter>timeout</parameter> time is guaranteed to
   pass before the routine returns.
   </para><para>

   <constant>TASK_INTERRUPTIBLE</constant> - the routine may return early if a signal is
   delivered to the current task.
   </para><para>

   The current task state is guaranteed to be TASK_RUNNING when this
   routine returns.
   </para><para>

   Returns 0 when the timer has expired otherwise -EINTR
</para>
</refsect1>
</refentry>

<refentry id="API-schedule-hrtimeout">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>July 2015</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>schedule_hrtimeout</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.4.104</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>schedule_hrtimeout</refname>
 <refpurpose>
     sleep until timeout
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>int __sched <function>schedule_hrtimeout </function></funcdef>
   <paramdef>ktime_t * <parameter>expires</parameter></paramdef>
   <paramdef>const enum hrtimer_mode <parameter>mode</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>expires</parameter></term>
   <listitem>
    <para>
     timeout value (ktime_t)
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>mode</parameter></term>
   <listitem>
    <para>
     timer mode, HRTIMER_MODE_ABS or HRTIMER_MODE_REL
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
<title>Description</title>
<para>
   Make the current task sleep until the given expiry time has
   elapsed. The routine will return immediately unless
   the current task state has been set (see <function>set_current_state</function>).
   </para><para>

   You can set the task state as follows -
   </para><para>

   <constant>TASK_UNINTERRUPTIBLE</constant> - at least <parameter>timeout</parameter> time is guaranteed to
   pass before the routine returns.
   </para><para>

   <constant>TASK_INTERRUPTIBLE</constant> - the routine may return early if a signal is
   delivered to the current task.
   </para><para>

   The current task state is guaranteed to be TASK_RUNNING when this
   routine returns.
   </para><para>

   Returns 0 when the timer has expired otherwise -EINTR
</para>
</refsect1>
</refentry>

     </sect1>
     <sect1><title>Workqueues and Kevents</title>
<!-- kernel/workqueue.c -->
<refentry id="API-queue-work">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>July 2015</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>queue_work</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.4.104</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>queue_work</refname>
 <refpurpose>
  queue work on a workqueue
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>int <function>queue_work </function></funcdef>
   <paramdef>struct workqueue_struct * <parameter>wq</parameter></paramdef>
   <paramdef>struct work_struct * <parameter>work</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>wq</parameter></term>
   <listitem>
    <para>
     workqueue to use
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>work</parameter></term>
   <listitem>
    <para>
     work to queue
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
<title>Description</title>
<para>
   Returns 0 if <parameter>work</parameter> was already on a queue, non-zero otherwise.
   </para><para>

   We queue the work to the CPU on which it was submitted, but if the CPU dies
   it can be processed by another CPU.
</para>
</refsect1>
</refentry>

<refentry id="API-queue-work-on">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>July 2015</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>queue_work_on</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.4.104</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>queue_work_on</refname>
 <refpurpose>
     queue work on specific cpu
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>int <function>queue_work_on </function></funcdef>
   <paramdef>int <parameter>cpu</parameter></paramdef>
   <paramdef>struct workqueue_struct * <parameter>wq</parameter></paramdef>
   <paramdef>struct work_struct * <parameter>work</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>cpu</parameter></term>
   <listitem>
    <para>
     CPU number to execute work on
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>wq</parameter></term>
   <listitem>
    <para>
     workqueue to use
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>work</parameter></term>
   <listitem>
    <para>
     work to queue
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
<title>Description</title>
<para>
   Returns 0 if <parameter>work</parameter> was already on a queue, non-zero otherwise.
   </para><para>

   We queue the work to a specific CPU, the caller must ensure it
   can't go away.
</para>
</refsect1>
</refentry>

<refentry id="API-queue-delayed-work">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>July 2015</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>queue_delayed_work</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.4.104</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>queue_delayed_work</refname>
 <refpurpose>
     queue work on a workqueue after delay
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>int <function>queue_delayed_work </function></funcdef>
   <paramdef>struct workqueue_struct * <parameter>wq</parameter></paramdef>
   <paramdef>struct delayed_work * <parameter>dwork</parameter></paramdef>
   <paramdef>unsigned long <parameter>delay</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>wq</parameter></term>
   <listitem>
    <para>
     workqueue to use
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>dwork</parameter></term>
   <listitem>
    <para>
     delayable work to queue
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>delay</parameter></term>
   <listitem>
    <para>
     number of jiffies to wait before queueing
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
<title>Description</title>
<para>
   Returns 0 if <parameter>work</parameter> was already on a queue, non-zero otherwise.
</para>
</refsect1>
</refentry>

<refentry id="API-queue-delayed-work-on">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>July 2015</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>queue_delayed_work_on</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.4.104</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>queue_delayed_work_on</refname>
 <refpurpose>
     queue work on specific CPU after delay
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>int <function>queue_delayed_work_on </function></funcdef>
   <paramdef>int <parameter>cpu</parameter></paramdef>
   <paramdef>struct workqueue_struct * <parameter>wq</parameter></paramdef>
   <paramdef>struct delayed_work * <parameter>dwork</parameter></paramdef>
   <paramdef>unsigned long <parameter>delay</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>cpu</parameter></term>
   <listitem>
    <para>
     CPU number to execute work on
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>wq</parameter></term>
   <listitem>
    <para>
     workqueue to use
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>dwork</parameter></term>
   <listitem>
    <para>
     work to queue
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>delay</parameter></term>
   <listitem>
    <para>
     number of jiffies to wait before queueing
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
<title>Description</title>
<para>
   Returns 0 if <parameter>work</parameter> was already on a queue, non-zero otherwise.
</para>
</refsect1>
</refentry>

<refentry id="API-flush-workqueue">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>July 2015</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>flush_workqueue</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.4.104</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>flush_workqueue</refname>
 <refpurpose>
     ensure that any scheduled work has run to completion.
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>void <function>flush_workqueue </function></funcdef>
   <paramdef>struct workqueue_struct * <parameter>wq</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>wq</parameter></term>
   <listitem>
    <para>
     workqueue to flush
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
<title>Description</title>
<para>
   Forces execution of the workqueue and blocks until its completion.
   This is typically used in driver shutdown handlers.
   </para><para>

   We sleep until all works which were queued on entry have been handled,
   but we are not livelocked by new incoming ones.
</para>
</refsect1>
</refentry>

<refentry id="API-drain-workqueue">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>July 2015</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>drain_workqueue</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.4.104</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>drain_workqueue</refname>
 <refpurpose>
     drain a workqueue
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>void <function>drain_workqueue </function></funcdef>
   <paramdef>struct workqueue_struct * <parameter>wq</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>wq</parameter></term>
   <listitem>
    <para>
     workqueue to drain
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
<title>Description</title>
<para>
   Wait until the workqueue becomes empty.  While draining is in progress,
   only chain queueing is allowed.  IOW, only currently pending or running
   work items on <parameter>wq</parameter> can queue further work items on it.  <parameter>wq</parameter> is flushed
   repeatedly until it becomes empty.  The number of flushing is detemined
   by the depth of chaining and should be relatively short.  Whine if it
   takes too long.
</para>
</refsect1>
</refentry>

<refentry id="API-flush-work">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>July 2015</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>flush_work</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.4.104</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>flush_work</refname>
 <refpurpose>
     wait for a work to finish executing the last queueing instance
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>bool <function>flush_work </function></funcdef>
   <paramdef>struct work_struct * <parameter>work</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>work</parameter></term>
   <listitem>
    <para>
     the work to flush
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
<title>Description</title>
<para>
   Wait until <parameter>work</parameter> has finished execution.  This function considers
   only the last queueing instance of <parameter>work</parameter>.  If <parameter>work</parameter> has been
   enqueued across different CPUs on a non-reentrant workqueue or on
   multiple workqueues, <parameter>work</parameter> might still be executing on return on
   some of the CPUs from earlier queueing.
   </para><para>

   If <parameter>work</parameter> was queued only on a non-reentrant, ordered or unbound
   workqueue, <parameter>work</parameter> is guaranteed to be idle on return if it hasn't
   been requeued since flush started.
</para>
</refsect1>
<refsect1>
<title>RETURNS</title>
<para>
   <constant>true</constant> if <function>flush_work</function> waited for the work to finish execution,
   <constant>false</constant> if it was already idle.
</para>
</refsect1>
</refentry>

<refentry id="API-flush-work-sync">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>July 2015</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>flush_work_sync</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.4.104</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>flush_work_sync</refname>
 <refpurpose>
     wait until a work has finished execution
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>bool <function>flush_work_sync </function></funcdef>
   <paramdef>struct work_struct * <parameter>work</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>work</parameter></term>
   <listitem>
    <para>
     the work to flush
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
<title>Description</title>
<para>
   Wait until <parameter>work</parameter> has finished execution.  On return, it's
   guaranteed that all queueing instances of <parameter>work</parameter> which happened
   before this function is called are finished.  In other words, if
   <parameter>work</parameter> hasn't been requeued since this function was called, <parameter>work</parameter> is
   guaranteed to be idle on return.
</para>
</refsect1>
<refsect1>
<title>RETURNS</title>
<para>
   <constant>true</constant> if <function>flush_work_sync</function> waited for the work to finish execution,
   <constant>false</constant> if it was already idle.
</para>
</refsect1>
</refentry>

<refentry id="API-cancel-work-sync">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>July 2015</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>cancel_work_sync</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.4.104</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>cancel_work_sync</refname>
 <refpurpose>
     cancel a work and wait for it to finish
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>bool <function>cancel_work_sync </function></funcdef>
   <paramdef>struct work_struct * <parameter>work</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>work</parameter></term>
   <listitem>
    <para>
     the work to cancel
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
<title>Description</title>
<para>
   Cancel <parameter>work</parameter> and wait for its execution to finish.  This function
   can be used even if the work re-queues itself or migrates to
   another workqueue.  On return from this function, <parameter>work</parameter> is
   guaranteed to be not pending or executing on any CPU.
   </para><para>

   cancel_work_sync(<structname>delayed_work</structname>-&gt;work) must not be used for
   delayed_work's.  Use <function>cancel_delayed_work_sync</function> instead.
   </para><para>

   The caller must ensure that the workqueue on which <parameter>work</parameter> was last
   queued can't be destroyed before this function returns.
</para>
</refsect1>
<refsect1>
<title>RETURNS</title>
<para>
   <constant>true</constant> if <parameter>work</parameter> was pending, <constant>false</constant> otherwise.
</para>
</refsect1>
</refentry>

<refentry id="API-flush-delayed-work">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>July 2015</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>flush_delayed_work</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.4.104</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>flush_delayed_work</refname>
 <refpurpose>
     wait for a dwork to finish executing the last queueing
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>bool <function>flush_delayed_work </function></funcdef>
   <paramdef>struct delayed_work * <parameter>dwork</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>dwork</parameter></term>
   <listitem>
    <para>
     the delayed work to flush
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
<title>Description</title>
<para>
   Delayed timer is cancelled and the pending work is queued for
   immediate execution.  Like <function>flush_work</function>, this function only
   considers the last queueing instance of <parameter>dwork</parameter>.
</para>
</refsect1>
<refsect1>
<title>RETURNS</title>
<para>
   <constant>true</constant> if <function>flush_work</function> waited for the work to finish execution,
   <constant>false</constant> if it was already idle.
</para>
</refsect1>
</refentry>

<refentry id="API-flush-delayed-work-sync">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>July 2015</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>flush_delayed_work_sync</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.4.104</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>flush_delayed_work_sync</refname>
 <refpurpose>
     wait for a dwork to finish
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>bool <function>flush_delayed_work_sync </function></funcdef>
   <paramdef>struct delayed_work * <parameter>dwork</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>dwork</parameter></term>
   <listitem>
    <para>
     the delayed work to flush
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
<title>Description</title>
<para>
   Delayed timer is cancelled and the pending work is queued for
   execution immediately.  Other than timer handling, its behavior
   is identical to <function>flush_work_sync</function>.
</para>
</refsect1>
<refsect1>
<title>RETURNS</title>
<para>
   <constant>true</constant> if <function>flush_work_sync</function> waited for the work to finish execution,
   <constant>false</constant> if it was already idle.
</para>
</refsect1>
</refentry>

<refentry id="API-cancel-delayed-work-sync">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>July 2015</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>cancel_delayed_work_sync</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.4.104</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>cancel_delayed_work_sync</refname>
 <refpurpose>
     cancel a delayed work and wait for it to finish
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>bool <function>cancel_delayed_work_sync </function></funcdef>
   <paramdef>struct delayed_work * <parameter>dwork</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>dwork</parameter></term>
   <listitem>
    <para>
     the delayed work cancel
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
<title>Description</title>
<para>
   This is <function>cancel_work_sync</function> for delayed works.
</para>
</refsect1>
<refsect1>
<title>RETURNS</title>
<para>
   <constant>true</constant> if <parameter>dwork</parameter> was pending, <constant>false</constant> otherwise.
</para>
</refsect1>
</refentry>

<refentry id="API-schedule-work">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>July 2015</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>schedule_work</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.4.104</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>schedule_work</refname>
 <refpurpose>
     put work task in global workqueue
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>int <function>schedule_work </function></funcdef>
   <paramdef>struct work_struct * <parameter>work</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>work</parameter></term>
   <listitem>
    <para>
     job to be done
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
<title>Description</title>
<para>
   Returns zero if <parameter>work</parameter> was already on the kernel-global workqueue and
   non-zero otherwise.
   </para><para>

   This puts a job in the kernel-global workqueue if it was not already
   queued and leaves it in the same position on the kernel-global
   workqueue otherwise.
</para>
</refsect1>
</refentry>

<refentry id="API-schedule-delayed-work">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>July 2015</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>schedule_delayed_work</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.4.104</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>schedule_delayed_work</refname>
 <refpurpose>
     put work task in global workqueue after delay
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>int <function>schedule_delayed_work </function></funcdef>
   <paramdef>struct delayed_work * <parameter>dwork</parameter></paramdef>
   <paramdef>unsigned long <parameter>delay</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>dwork</parameter></term>
   <listitem>
    <para>
     job to be done
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>delay</parameter></term>
   <listitem>
    <para>
     number of jiffies to wait or 0 for immediate execution
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
<title>Description</title>
<para>
   After waiting for a given time this puts a job in the kernel-global
   workqueue.
</para>
</refsect1>
</refentry>

<refentry id="API-schedule-delayed-work-on">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>July 2015</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>schedule_delayed_work_on</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.4.104</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>schedule_delayed_work_on</refname>
 <refpurpose>
     queue work in global workqueue on CPU after delay
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>int <function>schedule_delayed_work_on </function></funcdef>
   <paramdef>int <parameter>cpu</parameter></paramdef>
   <paramdef>struct delayed_work * <parameter>dwork</parameter></paramdef>
   <paramdef>unsigned long <parameter>delay</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>cpu</parameter></term>
   <listitem>
    <para>
     cpu to use
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>dwork</parameter></term>
   <listitem>
    <para>
     job to be done
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>delay</parameter></term>
   <listitem>
    <para>
     number of jiffies to wait
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
<title>Description</title>
<para>
   After waiting for a given time this puts a job in the kernel-global
   workqueue on the specified CPU.
</para>
</refsect1>
</refentry>

<refentry id="API-flush-scheduled-work">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>July 2015</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>flush_scheduled_work</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.4.104</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>flush_scheduled_work</refname>
 <refpurpose>
     ensure that any scheduled work has run to completion.
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>void <function>flush_scheduled_work </function></funcdef>
   <paramdef> <parameter>void</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>void</parameter></term>
   <listitem>
    <para>
     no arguments
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
<title>Description</title>
<para>
   </para><para>

   Forces execution of the kernel-global workqueue and blocks until its
   completion.
   </para><para>

   Think twice before calling this function!  It's very easy to get into
   trouble if you don't take great care.  Either of the following situations
</para>
</refsect1>
<refsect1>
<title>will lead to deadlock</title>
<para>
   </para><para>

   One of the work items currently on the workqueue needs to acquire
   a lock held by your code or its caller.
   </para><para>

   Your code is running in the context of a work routine.
   </para><para>

   They will be detected by lockdep when they occur, but the first might not
   occur very often.  It depends on what work items are on the workqueue and
   what locks they need, which you have no control over.
   </para><para>

   In most situations flushing the entire workqueue is overkill; you merely
   need to know that a particular work item isn't queued and isn't running.
   In such cases you should use <function>cancel_delayed_work_sync</function> or
   <function>cancel_work_sync</function> instead.
</para>
</refsect1>
</refentry>

<refentry id="API-execute-in-process-context">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>July 2015</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>execute_in_process_context</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.4.104</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>execute_in_process_context</refname>
 <refpurpose>
     reliably execute the routine with user context
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>int <function>execute_in_process_context </function></funcdef>
   <paramdef>work_func_t <parameter>fn</parameter></paramdef>
   <paramdef>struct execute_work * <parameter>ew</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>fn</parameter></term>
   <listitem>
    <para>
     the function to execute
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>ew</parameter></term>
   <listitem>
    <para>
     guaranteed storage for the execute work structure (must
     be available when the work executes)
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
<title>Description</title>
<para>
   Executes the function immediately if process context is available,
   otherwise schedules the function for delayed execution.
</para>
</refsect1>
<refsect1>
<title>Returns</title>
<para>
   0 - function was executed
   1 - function was scheduled for execution
</para>
</refsect1>
</refentry>

<refentry id="API-destroy-workqueue">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>July 2015</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>destroy_workqueue</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.4.104</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>destroy_workqueue</refname>
 <refpurpose>
     safely terminate a workqueue
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>void <function>destroy_workqueue </function></funcdef>
   <paramdef>struct workqueue_struct * <parameter>wq</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>wq</parameter></term>
   <listitem>
    <para>
     target workqueue
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
<title>Description</title>
<para>
   Safely destroy a workqueue. All work currently pending will be done first.
</para>
</refsect1>
</refentry>

<refentry id="API-workqueue-set-max-active">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>July 2015</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>workqueue_set_max_active</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.4.104</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>workqueue_set_max_active</refname>
 <refpurpose>
     adjust max_active of a workqueue
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>void <function>workqueue_set_max_active </function></funcdef>
   <paramdef>struct workqueue_struct * <parameter>wq</parameter></paramdef>
   <paramdef>int <parameter>max_active</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>wq</parameter></term>
   <listitem>
    <para>
     target workqueue
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>max_active</parameter></term>
   <listitem>
    <para>
     new max_active value.
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
<title>Description</title>
<para>
   Set max_active of <parameter>wq</parameter> to <parameter>max_active</parameter>.
</para>
</refsect1>
<refsect1>
<title>CONTEXT</title>
<para>
   Don't call from IRQ context.
</para>
</refsect1>
</refentry>

<refentry id="API-workqueue-congested">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>July 2015</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>workqueue_congested</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.4.104</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>workqueue_congested</refname>
 <refpurpose>
     test whether a workqueue is congested
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>bool <function>workqueue_congested </function></funcdef>
   <paramdef>unsigned int <parameter>cpu</parameter></paramdef>
   <paramdef>struct workqueue_struct * <parameter>wq</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>cpu</parameter></term>
   <listitem>
    <para>
     CPU in question
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>wq</parameter></term>
   <listitem>
    <para>
     target workqueue
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
<title>Description</title>
<para>
   Test whether <parameter>wq</parameter>'s cpu workqueue for <parameter>cpu</parameter> is congested.  There is
   no synchronization around this function and the test result is
   unreliable and only useful as advisory hints or for debugging.
</para>
</refsect1>
<refsect1>
<title>RETURNS</title>
<para>
   <constant>true</constant> if congested, <constant>false</constant> otherwise.
</para>
</refsect1>
</refentry>

<refentry id="API-work-cpu">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>July 2015</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>work_cpu</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.4.104</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>work_cpu</refname>
 <refpurpose>
     return the last known associated cpu for <parameter>work</parameter>
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>unsigned int <function>work_cpu </function></funcdef>
   <paramdef>struct work_struct * <parameter>work</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>work</parameter></term>
   <listitem>
    <para>
     the work of interest
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
<title>RETURNS</title>
<para>
   CPU number if <parameter>work</parameter> was ever queued.  WORK_CPU_NONE otherwise.
</para>
</refsect1>
</refentry>

<refentry id="API-work-busy">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>July 2015</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>work_busy</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.4.104</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>work_busy</refname>
 <refpurpose>
     test whether a work is currently pending or running
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>unsigned int <function>work_busy </function></funcdef>
   <paramdef>struct work_struct * <parameter>work</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>work</parameter></term>
   <listitem>
    <para>
     the work to be tested
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
<title>Description</title>
<para>
   Test whether <parameter>work</parameter> is currently pending or running.  There is no
   synchronization around this function and the test result is
   unreliable and only useful as advisory hints or for debugging.
   Especially for reentrant wqs, the pending state might hide the
   running state.
</para>
</refsect1>
<refsect1>
<title>RETURNS</title>
<para>
   OR'd bitmask of WORK_BUSY_* bits.
</para>
</refsect1>
</refentry>

<refentry id="API-work-on-cpu">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>July 2015</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>work_on_cpu</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.4.104</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>work_on_cpu</refname>
 <refpurpose>
     run a function in user context on a particular cpu
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>long <function>work_on_cpu </function></funcdef>
   <paramdef>unsigned int <parameter>cpu</parameter></paramdef>
   <paramdef>long (*<parameter>fn</parameter>)
     <funcparams>void *</funcparams></paramdef>
   <paramdef>void * <parameter>arg</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>cpu</parameter></term>
   <listitem>
    <para>
     the cpu to run on
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>fn</parameter></term>
   <listitem>
    <para>
     the function to run
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>arg</parameter></term>
   <listitem>
    <para>
     the function arg
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
<title>Description</title>
<para>
   This will return the value <parameter>fn</parameter> returns.
   It is up to the caller to ensure that the cpu doesn't go offline.
   The caller must not hold any locks which would prevent <parameter>fn</parameter> from completing.
</para>
</refsect1>
</refentry>

     </sect1>
     <sect1><title>Internal Functions</title>
<!-- kernel/exit.c -->
<refentry id="API-reparent-to-kthreadd">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>July 2015</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>reparent_to_kthreadd</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.4.104</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>reparent_to_kthreadd</refname>
 <refpurpose>
  Reparent the calling kernel thread to kthreadd
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>void <function>reparent_to_kthreadd </function></funcdef>
   <paramdef> <parameter>void</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>void</parameter></term>
   <listitem>
    <para>
     no arguments
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
<title>Description</title>
<para>
   </para><para>

   If a kernel thread is launched as a result of a system call, or if
   it ever exits, it should generally reparent itself to kthreadd so it
   isn't in the way of other processes and is correctly cleaned up on exit.
   </para><para>

   The various task state such as scheduling policy and priority may have
   been inherited from a user process, so we reset them to sane values here.
   </para><para>

   NOTE that <function>reparent_to_kthreadd</function> gives the caller full capabilities.
</para>
</refsect1>
</refentry>

<refentry id="API-wait-task-stopped">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>July 2015</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>wait_task_stopped</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.4.104</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>wait_task_stopped</refname>
 <refpurpose>
     Wait for <constant>TASK_STOPPED</constant> or <constant>TASK_TRACED</constant>
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>int <function>wait_task_stopped </function></funcdef>
   <paramdef>struct wait_opts * <parameter>wo</parameter></paramdef>
   <paramdef>int <parameter>ptrace</parameter></paramdef>
   <paramdef>struct task_struct * <parameter>p</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>wo</parameter></term>
   <listitem>
    <para>
     wait options
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>ptrace</parameter></term>
   <listitem>
    <para>
     is the wait for ptrace
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>p</parameter></term>
   <listitem>
    <para>
     task to wait for
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
<title>Description</title>
<para>
   Handle <function>sys_wait4</function> work for <constant>p</constant> in state <constant>TASK_STOPPED</constant> or <constant>TASK_TRACED</constant>.
</para>
</refsect1>
<refsect1>
<title>CONTEXT</title>
<para>
   read_lock(<structname>tasklist_lock</structname>), which is released if return value is
   non-zero.  Also, grabs and releases <parameter>p</parameter>-&gt;sighand-&gt;siglock.
</para>
</refsect1>
<refsect1>
<title>RETURNS</title>
<para>
   0 if wait condition didn't exist and search for other wait conditions
   should continue.  Non-zero return, -errno on failure and <parameter>p</parameter>'s pid on
   success, implies that tasklist_lock is released and wait condition
   search should terminate.
</para>
</refsect1>
</refentry>

<!-- kernel/signal.c -->
<refentry id="API-task-set-jobctl-pending">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>July 2015</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>task_set_jobctl_pending</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.4.104</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>task_set_jobctl_pending</refname>
 <refpurpose>
  set jobctl pending bits
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>bool <function>task_set_jobctl_pending </function></funcdef>
   <paramdef>struct task_struct * <parameter>task</parameter></paramdef>
   <paramdef>unsigned int <parameter>mask</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>task</parameter></term>
   <listitem>
    <para>
     target task
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>mask</parameter></term>
   <listitem>
    <para>
     pending bits to set
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
<title>Description</title>
<para>
   Clear <parameter>mask</parameter> from <parameter>task</parameter>-&gt;jobctl.  <parameter>mask</parameter> must be subset of
   <constant>JOBCTL_PENDING_MASK</constant> | <constant>JOBCTL_STOP_CONSUME</constant> | <constant>JOBCTL_STOP_SIGMASK</constant> |
   <constant>JOBCTL_TRAPPING</constant>.  If stop signo is being set, the existing signo is
   cleared.  If <parameter>task</parameter> is already being killed or exiting, this function
   becomes noop.
</para>
</refsect1>
<refsect1>
<title>CONTEXT</title>
<para>
   Must be called with <parameter>task</parameter>-&gt;sighand-&gt;siglock held.
</para>
</refsect1>
<refsect1>
<title>RETURNS</title>
<para>
   <constant>true</constant> if <parameter>mask</parameter> is set, <constant>false</constant> if made noop because <parameter>task</parameter> was dying.
</para>
</refsect1>
</refentry>

<refentry id="API-task-clear-jobctl-trapping">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>July 2015</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>task_clear_jobctl_trapping</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.4.104</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>task_clear_jobctl_trapping</refname>
 <refpurpose>
     clear jobctl trapping bit
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>void <function>task_clear_jobctl_trapping </function></funcdef>
   <paramdef>struct task_struct * <parameter>task</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>task</parameter></term>
   <listitem>
    <para>
     target task
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
<title>Description</title>
<para>
   If JOBCTL_TRAPPING is set, a ptracer is waiting for us to enter TRACED.
   Clear it and wake up the ptracer.  Note that we don't need any further
   locking.  <parameter>task</parameter>-&gt;siglock guarantees that <parameter>task</parameter>-&gt;parent points to the
   ptracer.
</para>
</refsect1>
<refsect1>
<title>CONTEXT</title>
<para>
   Must be called with <parameter>task</parameter>-&gt;sighand-&gt;siglock held.
</para>
</refsect1>
</refentry>

<refentry id="API-task-clear-jobctl-pending">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>July 2015</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>task_clear_jobctl_pending</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.4.104</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>task_clear_jobctl_pending</refname>
 <refpurpose>
     clear jobctl pending bits
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>void <function>task_clear_jobctl_pending </function></funcdef>
   <paramdef>struct task_struct * <parameter>task</parameter></paramdef>
   <paramdef>unsigned int <parameter>mask</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>task</parameter></term>
   <listitem>
    <para>
     target task
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>mask</parameter></term>
   <listitem>
    <para>
     pending bits to clear
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
<title>Description</title>
<para>
   Clear <parameter>mask</parameter> from <parameter>task</parameter>-&gt;jobctl.  <parameter>mask</parameter> must be subset of
   <constant>JOBCTL_PENDING_MASK</constant>.  If <constant>JOBCTL_STOP_PENDING</constant> is being cleared, other
   STOP bits are cleared together.
   </para><para>

   If clearing of <parameter>mask</parameter> leaves no stop or trap pending, this function calls
   <function>task_clear_jobctl_trapping</function>.
</para>
</refsect1>
<refsect1>
<title>CONTEXT</title>
<para>
   Must be called with <parameter>task</parameter>-&gt;sighand-&gt;siglock held.
</para>
</refsect1>
</refentry>

<refentry id="API-task-participate-group-stop">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>July 2015</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>task_participate_group_stop</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.4.104</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>task_participate_group_stop</refname>
 <refpurpose>
     participate in a group stop
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>bool <function>task_participate_group_stop </function></funcdef>
   <paramdef>struct task_struct * <parameter>task</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>task</parameter></term>
   <listitem>
    <para>
     task participating in a group stop
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
<title>Description</title>
<para>
   <parameter>task</parameter> has <constant>JOBCTL_STOP_PENDING</constant> set and is participating in a group stop.
   Group stop states are cleared and the group stop count is consumed if
   <constant>JOBCTL_STOP_CONSUME</constant> was set.  If the consumption completes the group
   stop, the appropriate <constant>SIGNAL_</constant>* flags are set.
</para>
</refsect1>
<refsect1>
<title>CONTEXT</title>
<para>
   Must be called with <parameter>task</parameter>-&gt;sighand-&gt;siglock held.
</para>
</refsect1>
<refsect1>
<title>RETURNS</title>
<para>
   <constant>true</constant> if group stop completion should be notified to the parent, <constant>false</constant>
   otherwise.
</para>
</refsect1>
</refentry>

<refentry id="API-ptrace-trap-notify">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>July 2015</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>ptrace_trap_notify</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.4.104</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>ptrace_trap_notify</refname>
 <refpurpose>
     schedule trap to notify ptracer
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>void <function>ptrace_trap_notify </function></funcdef>
   <paramdef>struct task_struct * <parameter>t</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>t</parameter></term>
   <listitem>
    <para>
     tracee wanting to notify tracer
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
<title>Description</title>
<para>
   This function schedules sticky ptrace trap which is cleared on the next
   TRAP_STOP to notify ptracer of an event.  <parameter>t</parameter> must have been seized by
   ptracer.
   </para><para>

   If <parameter>t</parameter> is running, STOP trap will be taken.  If trapped for STOP and
   ptracer is listening for events, tracee is woken up so that it can
   re-trap for the new event.  If trapped otherwise, STOP trap will be
   eventually taken without returning to userland after the existing traps
   are finished by PTRACE_CONT.
</para>
</refsect1>
<refsect1>
<title>CONTEXT</title>
<para>
   Must be called with <parameter>task</parameter>-&gt;sighand-&gt;siglock held.
</para>
</refsect1>
</refentry>

<refentry id="API-do-notify-parent-cldstop">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>July 2015</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>do_notify_parent_cldstop</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.4.104</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>do_notify_parent_cldstop</refname>
 <refpurpose>
     notify parent of stopped/continued state change
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>void <function>do_notify_parent_cldstop </function></funcdef>
   <paramdef>struct task_struct * <parameter>tsk</parameter></paramdef>
   <paramdef>bool <parameter>for_ptracer</parameter></paramdef>
   <paramdef>int <parameter>why</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>tsk</parameter></term>
   <listitem>
    <para>
     task reporting the state change
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>for_ptracer</parameter></term>
   <listitem>
    <para>
     the notification is for ptracer
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>why</parameter></term>
   <listitem>
    <para>
     CLD_{CONTINUED|STOPPED|TRAPPED} to report
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
<title>Description</title>
<para>
   Notify <parameter>tsk</parameter>'s parent that the stopped/continued state has changed.  If
   <parameter>for_ptracer</parameter> is <constant>false</constant>, <parameter>tsk</parameter>'s group leader notifies to its real parent.
   If <constant>true</constant>, <parameter>tsk</parameter> reports to <parameter>tsk</parameter>-&gt;parent which should be the ptracer.
</para>
</refsect1>
<refsect1>
<title>CONTEXT</title>
<para>
   Must be called with tasklist_lock at least read locked.
</para>
</refsect1>
</refentry>

<refentry id="API-do-signal-stop">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>July 2015</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>do_signal_stop</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.4.104</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>do_signal_stop</refname>
 <refpurpose>
     handle group stop for SIGSTOP and other stop signals
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>bool <function>do_signal_stop </function></funcdef>
   <paramdef>int <parameter>signr</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>signr</parameter></term>
   <listitem>
    <para>
     signr causing group stop if initiating
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
<title>Description</title>
<para>
   If <constant>JOBCTL_STOP_PENDING</constant> is not set yet, initiate group stop with <parameter>signr</parameter>
   and participate in it.  If already set, participate in the existing
   group stop.  If participated in a group stop (and thus slept), <constant>true</constant> is
   returned with siglock released.
   </para><para>

   If ptraced, this function doesn't handle stop itself.  Instead,
   <constant>JOBCTL_TRAP_STOP</constant> is scheduled and <constant>false</constant> is returned with siglock
   untouched.  The caller must ensure that INTERRUPT trap handling takes
   places afterwards.
</para>
</refsect1>
<refsect1>
<title>CONTEXT</title>
<para>
   Must be called with <parameter>current</parameter>-&gt;sighand-&gt;siglock held, which is released
   on <constant>true</constant> return.
</para>
</refsect1>
<refsect1>
<title>RETURNS</title>
<para>
   <constant>false</constant> if group stop is already cancelled or ptrace trap is scheduled.
   <constant>true</constant> if participated in group stop.
</para>
</refsect1>
</refentry>

<refentry id="API-do-jobctl-trap">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>July 2015</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>do_jobctl_trap</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.4.104</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>do_jobctl_trap</refname>
 <refpurpose>
     take care of ptrace jobctl traps
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>void <function>do_jobctl_trap </function></funcdef>
   <paramdef> <parameter>void</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>void</parameter></term>
   <listitem>
    <para>
     no arguments
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
<title>Description</title>
<para>
   </para><para>

   When PT_SEIZED, it's used for both group stop and explicit
   SEIZE/INTERRUPT traps.  Both generate PTRACE_EVENT_STOP trap with
   accompanying siginfo.  If stopped, lower eight bits of exit_code contain
   the stop signal; otherwise, <constant>SIGTRAP</constant>.
   </para><para>

   When !PT_SEIZED, it's used only for group stop trap with stop signal
   number as exit_code and no siginfo.
</para>
</refsect1>
<refsect1>
<title>CONTEXT</title>
<para>
   Must be called with <parameter>current</parameter>-&gt;sighand-&gt;siglock held, which may be
   released and re-acquired before returning with intervening sleep.
</para>
</refsect1>
</refentry>

<refentry id="API-block-sigmask">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>July 2015</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>block_sigmask</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.4.104</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>block_sigmask</refname>
 <refpurpose>
     add <parameter>ka</parameter>'s signal mask to current-&gt;blocked
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>void <function>block_sigmask </function></funcdef>
   <paramdef>struct k_sigaction * <parameter>ka</parameter></paramdef>
   <paramdef>int <parameter>signr</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>ka</parameter></term>
   <listitem>
    <para>
     action for <parameter>signr</parameter>
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>signr</parameter></term>
   <listitem>
    <para>
     signal that has been successfully delivered
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
<title>Description</title>
<para>
   This function should be called when a signal has succesfully been
   delivered. It adds the mask of signals for <parameter>ka</parameter> to current-&gt;blocked
   so that they are blocked during the execution of the signal
   handler. In addition, <parameter>signr</parameter> will be blocked unless <constant>SA_NODEFER</constant> is
   set in <parameter>ka</parameter>-&gt;sa.sa_flags.
</para>
</refsect1>
</refentry>

<refentry id="API-sys-restart-syscall">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>July 2015</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>sys_restart_syscall</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.4.104</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>sys_restart_syscall</refname>
 <refpurpose>
     restart a system call
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>long <function>sys_restart_syscall </function></funcdef>
   <paramdef> <parameter>void</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>void</parameter></term>
   <listitem>
    <para>
     no arguments
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
</refentry>

<refentry id="API-set-current-blocked">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>July 2015</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>set_current_blocked</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.4.104</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>set_current_blocked</refname>
 <refpurpose>
     change current-&gt;blocked mask
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>void <function>set_current_blocked </function></funcdef>
   <paramdef>const sigset_t * <parameter>newset</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>newset</parameter></term>
   <listitem>
    <para>
     new mask
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
<title>Description</title>
<para>
   It is wrong to change -&gt;blocked directly, this helper should be used
   to ensure the process can't miss a shared signal we are going to block.
</para>
</refsect1>
</refentry>

<refentry id="API-sys-rt-sigprocmask">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>July 2015</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>sys_rt_sigprocmask</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.4.104</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>sys_rt_sigprocmask</refname>
 <refpurpose>
     change the list of currently blocked signals
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>long <function>sys_rt_sigprocmask </function></funcdef>
   <paramdef>int <parameter>how</parameter></paramdef>
   <paramdef>sigset_t __user * <parameter>nset</parameter></paramdef>
   <paramdef>sigset_t __user * <parameter>oset</parameter></paramdef>
   <paramdef>size_t <parameter>sigsetsize</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>how</parameter></term>
   <listitem>
    <para>
     whether to add, remove, or set signals
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>nset</parameter></term>
   <listitem>
    <para>
     stores pending signals
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>oset</parameter></term>
   <listitem>
    <para>
     previous value of signal mask if non-null
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>sigsetsize</parameter></term>
   <listitem>
    <para>
     size of sigset_t type
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
</refentry>

<refentry id="API-sys-rt-sigpending">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>July 2015</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>sys_rt_sigpending</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.4.104</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>sys_rt_sigpending</refname>
 <refpurpose>
     examine a pending signal that has been raised while blocked
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>long <function>sys_rt_sigpending </function></funcdef>
   <paramdef>sigset_t __user * <parameter>set</parameter></paramdef>
   <paramdef>size_t <parameter>sigsetsize</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>set</parameter></term>
   <listitem>
    <para>
     stores pending signals
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>sigsetsize</parameter></term>
   <listitem>
    <para>
     size of sigset_t type or larger
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
</refentry>

<refentry id="API-do-sigtimedwait">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>July 2015</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>do_sigtimedwait</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.4.104</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>do_sigtimedwait</refname>
 <refpurpose>
     wait for queued signals specified in <parameter>which</parameter>
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>int <function>do_sigtimedwait </function></funcdef>
   <paramdef>const sigset_t * <parameter>which</parameter></paramdef>
   <paramdef>siginfo_t * <parameter>info</parameter></paramdef>
   <paramdef>const struct timespec * <parameter>ts</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>which</parameter></term>
   <listitem>
    <para>
     queued signals to wait for
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>info</parameter></term>
   <listitem>
    <para>
     if non-null, the signal's siginfo is returned here
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>ts</parameter></term>
   <listitem>
    <para>
     upper bound on process time suspension
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
</refentry>

<refentry id="API-sys-rt-sigtimedwait">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>July 2015</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>sys_rt_sigtimedwait</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.4.104</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>sys_rt_sigtimedwait</refname>
 <refpurpose>
     synchronously wait for queued signals specified in <parameter>uthese</parameter>
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>long <function>sys_rt_sigtimedwait </function></funcdef>
   <paramdef>const sigset_t __user * <parameter>uthese</parameter></paramdef>
   <paramdef>siginfo_t __user * <parameter>uinfo</parameter></paramdef>
   <paramdef>const struct timespec __user * <parameter>uts</parameter></paramdef>
   <paramdef>size_t <parameter>sigsetsize</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>uthese</parameter></term>
   <listitem>
    <para>
     queued signals to wait for
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>uinfo</parameter></term>
   <listitem>
    <para>
     if non-null, the signal's siginfo is returned here
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>uts</parameter></term>
   <listitem>
    <para>
     upper bound on process time suspension
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>sigsetsize</parameter></term>
   <listitem>
    <para>
     size of sigset_t type
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
</refentry>

<refentry id="API-sys-kill">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>July 2015</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>sys_kill</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.4.104</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>sys_kill</refname>
 <refpurpose>
     send a signal to a process
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>long <function>sys_kill </function></funcdef>
   <paramdef>pid_t <parameter>pid</parameter></paramdef>
   <paramdef>int <parameter>sig</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>pid</parameter></term>
   <listitem>
    <para>
     the PID of the process
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>sig</parameter></term>
   <listitem>
    <para>
     signal to be sent
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
</refentry>

<refentry id="API-sys-tgkill">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>July 2015</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>sys_tgkill</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.4.104</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>sys_tgkill</refname>
 <refpurpose>
     send signal to one specific thread
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>long <function>sys_tgkill </function></funcdef>
   <paramdef>pid_t <parameter>tgid</parameter></paramdef>
   <paramdef>pid_t <parameter>pid</parameter></paramdef>
   <paramdef>int <parameter>sig</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>tgid</parameter></term>
   <listitem>
    <para>
     the thread group ID of the thread
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>pid</parameter></term>
   <listitem>
    <para>
     the PID of the thread
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>sig</parameter></term>
   <listitem>
    <para>
     signal to be sent
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
<title>Description</title>
<para>
   This syscall also checks the <parameter>tgid</parameter> and returns -ESRCH even if the PID
   exists but it's not belonging to the target process anymore. This
   method solves the problem of threads exiting and PIDs getting reused.
</para>
</refsect1>
</refentry>

<refentry id="API-sys-tkill">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>July 2015</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>sys_tkill</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.4.104</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>sys_tkill</refname>
 <refpurpose>
     send signal to one specific task
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>long <function>sys_tkill </function></funcdef>
   <paramdef>pid_t <parameter>pid</parameter></paramdef>
   <paramdef>int <parameter>sig</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>pid</parameter></term>
   <listitem>
    <para>
     the PID of the task
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>sig</parameter></term>
   <listitem>
    <para>
     signal to be sent
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
<title>Description</title>
<para>
   Send a signal to only one task, even if it's a CLONE_THREAD task.
</para>
</refsect1>
</refentry>

<refentry id="API-sys-rt-sigqueueinfo">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>July 2015</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>sys_rt_sigqueueinfo</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.4.104</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>sys_rt_sigqueueinfo</refname>
 <refpurpose>
     send signal information to a signal
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>long <function>sys_rt_sigqueueinfo </function></funcdef>
   <paramdef>pid_t <parameter>pid</parameter></paramdef>
   <paramdef>int <parameter>sig</parameter></paramdef>
   <paramdef>siginfo_t __user * <parameter>uinfo</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>pid</parameter></term>
   <listitem>
    <para>
     the PID of the thread
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>sig</parameter></term>
   <listitem>
    <para>
     signal to be sent
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>uinfo</parameter></term>
   <listitem>
    <para>
     signal info to be sent
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
</refentry>

<refentry id="API-sys-sigpending">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>July 2015</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>sys_sigpending</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.4.104</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>sys_sigpending</refname>
 <refpurpose>
     examine pending signals
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>long <function>sys_sigpending </function></funcdef>
   <paramdef>old_sigset_t __user * <parameter>set</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>set</parameter></term>
   <listitem>
    <para>
     where mask of pending signal is returned
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
</refentry>

<refentry id="API-sys-sigprocmask">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>July 2015</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>sys_sigprocmask</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.4.104</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>sys_sigprocmask</refname>
 <refpurpose>
     examine and change blocked signals
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>long <function>sys_sigprocmask </function></funcdef>
   <paramdef>int <parameter>how</parameter></paramdef>
   <paramdef>old_sigset_t __user * <parameter>nset</parameter></paramdef>
   <paramdef>old_sigset_t __user * <parameter>oset</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>how</parameter></term>
   <listitem>
    <para>
     whether to add, remove, or set signals
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>nset</parameter></term>
   <listitem>
    <para>
     signals to add or remove (if non-null)
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>oset</parameter></term>
   <listitem>
    <para>
     previous value of signal mask if non-null
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
<title>Description</title>
<para>
   Some platforms have their own version with special arguments;
   others support only sys_rt_sigprocmask.
</para>
</refsect1>
</refentry>

<refentry id="API-sys-rt-sigaction">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>July 2015</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>sys_rt_sigaction</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.4.104</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>sys_rt_sigaction</refname>
 <refpurpose>
     alter an action taken by a process
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>long <function>sys_rt_sigaction </function></funcdef>
   <paramdef>int <parameter>sig</parameter></paramdef>
   <paramdef>const struct sigaction __user * <parameter>act</parameter></paramdef>
   <paramdef>struct sigaction __user * <parameter>oact</parameter></paramdef>
   <paramdef>size_t <parameter>sigsetsize</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>sig</parameter></term>
   <listitem>
    <para>
     signal to be sent
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>act</parameter></term>
   <listitem>
    <para>
     new sigaction
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>oact</parameter></term>
   <listitem>
    <para>
     used to save the previous sigaction
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>sigsetsize</parameter></term>
   <listitem>
    <para>
     size of sigset_t type
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
</refentry>

<refentry id="API-sys-rt-sigsuspend">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>July 2015</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>sys_rt_sigsuspend</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.4.104</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>sys_rt_sigsuspend</refname>
 <refpurpose>
     replace the signal mask for a value with the <parameter>unewset</parameter> value until a signal is received
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>long <function>sys_rt_sigsuspend </function></funcdef>
   <paramdef>sigset_t __user * <parameter>unewset</parameter></paramdef>
   <paramdef>size_t <parameter>sigsetsize</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>unewset</parameter></term>
   <listitem>
    <para>
     new signal mask value
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>sigsetsize</parameter></term>
   <listitem>
    <para>
     size of sigset_t type
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
</refentry>

<!-- include/linux/kthread.h -->
<refentry id="API-kthread-run">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>July 2015</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>kthread_run</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.4.104</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>kthread_run</refname>
 <refpurpose>
  create and wake a thread.
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef> <function>kthread_run </function></funcdef>
   <paramdef> <parameter>threadfn</parameter></paramdef>
   <paramdef> <parameter>data</parameter></paramdef>
   <paramdef> <parameter>namefmt</parameter></paramdef>
   <paramdef> <parameter>...</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>threadfn</parameter></term>
   <listitem>
    <para>
     the function to run until signal_pending(current).
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>data</parameter></term>
   <listitem>
    <para>
     data ptr for <parameter>threadfn</parameter>.
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>namefmt</parameter></term>
   <listitem>
    <para>
     printf-style name for the thread.
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>...</parameter></term>
   <listitem>
    <para>
     variable arguments
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
<title>Description</title>
<para>
   Convenient wrapper for <function>kthread_create</function> followed by
   <function>wake_up_process</function>.  Returns the kthread or ERR_PTR(-ENOMEM).
</para>
</refsect1>
</refentry>

<!-- kernel/kthread.c -->
<refentry id="API-kthread-should-stop">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>July 2015</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>kthread_should_stop</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.4.104</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>kthread_should_stop</refname>
 <refpurpose>
  should this kthread return now?
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>int <function>kthread_should_stop </function></funcdef>
   <paramdef> <parameter>void</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>void</parameter></term>
   <listitem>
    <para>
     no arguments
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
<title>Description</title>
<para>
   </para><para>

   When someone calls <function>kthread_stop</function> on your kthread, it will be woken
   and this will return true.  You should then return, and your return
   value will be passed through to <function>kthread_stop</function>.
</para>
</refsect1>
</refentry>

<refentry id="API-kthread-freezable-should-stop">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>July 2015</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>kthread_freezable_should_stop</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.4.104</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>kthread_freezable_should_stop</refname>
 <refpurpose>
     should this freezable kthread return now?
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>bool <function>kthread_freezable_should_stop </function></funcdef>
   <paramdef>bool * <parameter>was_frozen</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>was_frozen</parameter></term>
   <listitem>
    <para>
     optional out parameter, indicates whether <constant>current</constant> was frozen
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
<title>Description</title>
<para>
   <function>kthread_should_stop</function> for freezable kthreads, which will enter
   refrigerator if necessary.  This function is safe from <function>kthread_stop</function> /
   freezer deadlock and freezable kthreads should use this function instead
   of calling <function>try_to_freeze</function> directly.
</para>
</refsect1>
</refentry>

<refentry id="API-kthread-create-on-node">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>July 2015</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>kthread_create_on_node</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.4.104</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>kthread_create_on_node</refname>
 <refpurpose>
     create a kthread.
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>struct task_struct * <function>kthread_create_on_node </function></funcdef>
   <paramdef>int (*<parameter>threadfn</parameter>)
     <funcparams>void *data</funcparams></paramdef>
   <paramdef>void * <parameter>data</parameter></paramdef>
   <paramdef>int <parameter>node</parameter></paramdef>
   <paramdef>const char <parameter>namefmt[]</parameter></paramdef>
   <paramdef> <parameter>...</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>threadfn</parameter></term>
   <listitem>
    <para>
     the function to run until signal_pending(current).
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>data</parameter></term>
   <listitem>
    <para>
     data ptr for <parameter>threadfn</parameter>.
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>node</parameter></term>
   <listitem>
    <para>
     memory node number.
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>namefmt[]</parameter></term>
   <listitem>
    <para>
     printf-style name for the thread.
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>...</parameter></term>
   <listitem>
    <para>
     variable arguments
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
<title>Description</title>
<para>
   This helper function creates and names a kernel
   thread.  The thread will be stopped: use <function>wake_up_process</function> to start
   it.  See also <function>kthread_run</function>.
   </para><para>

   If thread is going to be bound on a particular cpu, give its node
   in <parameter>node</parameter>, to get NUMA affinity for kthread stack, or else give -1.
   When woken, the thread will run <parameter>threadfn</parameter>() with <parameter>data</parameter> as its
   argument. <parameter>threadfn</parameter>() can either call <function>do_exit</function> directly if it is a
   standalone thread for which no one will call <function>kthread_stop</function>, or
   return when '<function>kthread_should_stop</function>' is true (which means
   <function>kthread_stop</function> has been called).  The return value should be zero
   or a negative error number; it will be passed to <function>kthread_stop</function>.
   </para><para>

   Returns a task_struct or ERR_PTR(-ENOMEM).
</para>
</refsect1>
</refentry>

<refentry id="API-kthread-bind">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>July 2015</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>kthread_bind</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.4.104</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>kthread_bind</refname>
 <refpurpose>
     bind a just-created kthread to a cpu.
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>void <function>kthread_bind </function></funcdef>
   <paramdef>struct task_struct * <parameter>p</parameter></paramdef>
   <paramdef>unsigned int <parameter>cpu</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>p</parameter></term>
   <listitem>
    <para>
     thread created by <function>kthread_create</function>.
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>cpu</parameter></term>
   <listitem>
    <para>
     cpu (might not be online, must be possible) for <parameter>k</parameter> to run on.
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
<title>Description</title>
<para>
   This function is equivalent to <function>set_cpus_allowed</function>,
   except that <parameter>cpu</parameter> doesn't need to be online, and the thread must be
   stopped (i.e., just returned from <function>kthread_create</function>).
</para>
</refsect1>
</refentry>

<refentry id="API-kthread-stop">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>July 2015</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>kthread_stop</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.4.104</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>kthread_stop</refname>
 <refpurpose>
     stop a thread created by <function>kthread_create</function>.
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>int <function>kthread_stop </function></funcdef>
   <paramdef>struct task_struct * <parameter>k</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>k</parameter></term>
   <listitem>
    <para>
     thread created by <function>kthread_create</function>.
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
<title>Description</title>
<para>
   Sets <function>kthread_should_stop</function> for <parameter>k</parameter> to return true, wakes it, and
   waits for it to exit. This can also be called after <function>kthread_create</function>
   instead of calling <function>wake_up_process</function>: the thread will exit without
   calling <function>threadfn</function>.
   </para><para>

   If <function>threadfn</function> may call <function>do_exit</function> itself, the caller must ensure
   task_struct can't go away.
   </para><para>

   Returns the result of <function>threadfn</function>, or <constant>-EINTR</constant> if <function>wake_up_process</function>
   was never called.
</para>
</refsect1>
</refentry>

<refentry id="API-kthread-worker-fn">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>July 2015</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>kthread_worker_fn</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.4.104</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>kthread_worker_fn</refname>
 <refpurpose>
     kthread function to process kthread_worker
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>int <function>kthread_worker_fn </function></funcdef>
   <paramdef>void * <parameter>worker_ptr</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>worker_ptr</parameter></term>
   <listitem>
    <para>
     pointer to initialized kthread_worker
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
<title>Description</title>
<para>
   This function can be used as <parameter>threadfn</parameter> to <function>kthread_create</function> or
   <function>kthread_run</function> with <parameter>worker_ptr</parameter> argument pointing to an initialized
   kthread_worker.  The started kthread will process work_list until
   the it is stopped with <function>kthread_stop</function>.  A kthread can also call
   this function directly after extra initialization.
   </para><para>

   Different kthreads can be used for the same kthread_worker as long
   as there's only one kthread attached to it at any given time.  A
   kthread_worker without an attached kthread simply collects queued
   kthread_works.
</para>
</refsect1>
</refentry>

<refentry id="API-queue-kthread-work">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>July 2015</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>queue_kthread_work</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.4.104</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>queue_kthread_work</refname>
 <refpurpose>
     queue a kthread_work
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>bool <function>queue_kthread_work </function></funcdef>
   <paramdef>struct kthread_worker * <parameter>worker</parameter></paramdef>
   <paramdef>struct kthread_work * <parameter>work</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>worker</parameter></term>
   <listitem>
    <para>
     target kthread_worker
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>work</parameter></term>
   <listitem>
    <para>
     kthread_work to queue
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
<title>Description</title>
<para>
   Queue <parameter>work</parameter> to work processor <parameter>task</parameter> for async execution.  <parameter>task</parameter>
   must have been created with <function>kthread_worker_create</function>.  Returns <constant>true</constant>
   if <parameter>work</parameter> was successfully queued, <constant>false</constant> if it was already pending.
</para>
</refsect1>
</refentry>

<refentry id="API-flush-kthread-work">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>July 2015</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>flush_kthread_work</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.4.104</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>flush_kthread_work</refname>
 <refpurpose>
     flush a kthread_work
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>void <function>flush_kthread_work </function></funcdef>
   <paramdef>struct kthread_work * <parameter>work</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>work</parameter></term>
   <listitem>
    <para>
     work to flush
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
<title>Description</title>
<para>
   If <parameter>work</parameter> is queued or executing, wait for it to finish execution.
</para>
</refsect1>
</refentry>

<refentry id="API-flush-kthread-worker">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>July 2015</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>flush_kthread_worker</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.4.104</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>flush_kthread_worker</refname>
 <refpurpose>
     flush all current works on a kthread_worker
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>void <function>flush_kthread_worker </function></funcdef>
   <paramdef>struct kthread_worker * <parameter>worker</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>worker</parameter></term>
   <listitem>
    <para>
     worker to flush
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
<title>Description</title>
<para>
   Wait until all currently executing or pending works on <parameter>worker</parameter> are
   finished.
</para>
</refsect1>
</refentry>

     </sect1>

     <sect1><title>Kernel objects manipulation</title>
<!--
X!Iinclude/linux/kobject.h
-->
<!-- lib/kobject.c -->
<refentry id="API-kobject-get-path">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>July 2015</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>kobject_get_path</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.4.104</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>kobject_get_path</refname>
 <refpurpose>
  generate and return the path associated with a given kobj and kset pair.
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>char * <function>kobject_get_path </function></funcdef>
   <paramdef>struct kobject * <parameter>kobj</parameter></paramdef>
   <paramdef>gfp_t <parameter>gfp_mask</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>kobj</parameter></term>
   <listitem>
    <para>
     kobject in question, with which to build the path
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>gfp_mask</parameter></term>
   <listitem>
    <para>
     the allocation type used to allocate the path
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
<title>Description</title>
<para>
   The result must be freed by the caller with <function>kfree</function>.
</para>
</refsect1>
</refentry>

<refentry id="API-kobject-set-name">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>July 2015</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>kobject_set_name</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.4.104</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>kobject_set_name</refname>
 <refpurpose>
     Set the name of a kobject
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>int <function>kobject_set_name </function></funcdef>
   <paramdef>struct kobject * <parameter>kobj</parameter></paramdef>
   <paramdef>const char * <parameter>fmt</parameter></paramdef>
   <paramdef> <parameter>...</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>kobj</parameter></term>
   <listitem>
    <para>
     struct kobject to set the name of
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>fmt</parameter></term>
   <listitem>
    <para>
     format string used to build the name
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>...</parameter></term>
   <listitem>
    <para>
     variable arguments
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
<title>Description</title>
<para>
   This sets the name of the kobject.  If you have already added the
   kobject to the system, you must call <function>kobject_rename</function> in order to
   change the name of the kobject.
</para>
</refsect1>
</refentry>

<refentry id="API-kobject-init">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>July 2015</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>kobject_init</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.4.104</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>kobject_init</refname>
 <refpurpose>
     initialize a kobject structure
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>void <function>kobject_init </function></funcdef>
   <paramdef>struct kobject * <parameter>kobj</parameter></paramdef>
   <paramdef>struct kobj_type * <parameter>ktype</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>kobj</parameter></term>
   <listitem>
    <para>
     pointer to the kobject to initialize
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>ktype</parameter></term>
   <listitem>
    <para>
     pointer to the ktype for this kobject.
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
<title>Description</title>
<para>
   This function will properly initialize a kobject such that it can then
   be passed to the <function>kobject_add</function> call.
   </para><para>

   After this function is called, the kobject MUST be cleaned up by a call
   to <function>kobject_put</function>, not by a call to kfree directly to ensure that all of
   the memory is cleaned up properly.
</para>
</refsect1>
</refentry>

<refentry id="API-kobject-add">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>July 2015</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>kobject_add</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.4.104</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>kobject_add</refname>
 <refpurpose>
     the main kobject add function
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>int <function>kobject_add </function></funcdef>
   <paramdef>struct kobject * <parameter>kobj</parameter></paramdef>
   <paramdef>struct kobject * <parameter>parent</parameter></paramdef>
   <paramdef>const char * <parameter>fmt</parameter></paramdef>
   <paramdef> <parameter>...</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>kobj</parameter></term>
   <listitem>
    <para>
     the kobject to add
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>parent</parameter></term>
   <listitem>
    <para>
     pointer to the parent of the kobject.
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>fmt</parameter></term>
   <listitem>
    <para>
     format to name the kobject with.
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>...</parameter></term>
   <listitem>
    <para>
     variable arguments
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
<title>Description</title>
<para>
   The kobject name is set and added to the kobject hierarchy in this
   function.
   </para><para>

   If <parameter>parent</parameter> is set, then the parent of the <parameter>kobj</parameter> will be set to it.
   If <parameter>parent</parameter> is NULL, then the parent of the <parameter>kobj</parameter> will be set to the
   kobject associted with the kset assigned to this kobject.  If no kset
   is assigned to the kobject, then the kobject will be located in the
   root of the sysfs tree.
   </para><para>

   If this function returns an error, <function>kobject_put</function> must be called to
   properly clean up the memory associated with the object.
   Under no instance should the kobject that is passed to this function
   be directly freed with a call to <function>kfree</function>, that can leak memory.
   </para><para>

   Note, no <quote>add</quote> uevent will be created with this call, the caller should set
   up all of the necessary sysfs files for the object and then call
   <function>kobject_uevent</function> with the UEVENT_ADD parameter to ensure that
   userspace is properly notified of this kobject's creation.
</para>
</refsect1>
</refentry>

<refentry id="API-kobject-init-and-add">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>July 2015</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>kobject_init_and_add</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.4.104</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>kobject_init_and_add</refname>
 <refpurpose>
     initialize a kobject structure and add it to the kobject hierarchy
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>int <function>kobject_init_and_add </function></funcdef>
   <paramdef>struct kobject * <parameter>kobj</parameter></paramdef>
   <paramdef>struct kobj_type * <parameter>ktype</parameter></paramdef>
   <paramdef>struct kobject * <parameter>parent</parameter></paramdef>
   <paramdef>const char * <parameter>fmt</parameter></paramdef>
   <paramdef> <parameter>...</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>kobj</parameter></term>
   <listitem>
    <para>
     pointer to the kobject to initialize
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>ktype</parameter></term>
   <listitem>
    <para>
     pointer to the ktype for this kobject.
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>parent</parameter></term>
   <listitem>
    <para>
     pointer to the parent of this kobject.
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>fmt</parameter></term>
   <listitem>
    <para>
     the name of the kobject.
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>...</parameter></term>
   <listitem>
    <para>
     variable arguments
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
<title>Description</title>
<para>
   This function combines the call to <function>kobject_init</function> and
   <function>kobject_add</function>.  The same type of error handling after a call to
   <function>kobject_add</function> and kobject lifetime rules are the same here.
</para>
</refsect1>
</refentry>

<refentry id="API-kobject-rename">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>July 2015</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>kobject_rename</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.4.104</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>kobject_rename</refname>
 <refpurpose>
     change the name of an object
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>int <function>kobject_rename </function></funcdef>
   <paramdef>struct kobject * <parameter>kobj</parameter></paramdef>
   <paramdef>const char * <parameter>new_name</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>kobj</parameter></term>
   <listitem>
    <para>
     object in question.
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>new_name</parameter></term>
   <listitem>
    <para>
     object's new name
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
<title>Description</title>
<para>
   It is the responsibility of the caller to provide mutual
   exclusion between two different calls of kobject_rename
   on the same kobject and to ensure that new_name is valid and
   won't conflict with other kobjects.
</para>
</refsect1>
</refentry>

<refentry id="API-kobject-del">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>July 2015</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>kobject_del</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.4.104</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>kobject_del</refname>
 <refpurpose>
     unlink kobject from hierarchy.
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>void <function>kobject_del </function></funcdef>
   <paramdef>struct kobject * <parameter>kobj</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>kobj</parameter></term>
   <listitem>
    <para>
     object.
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
</refentry>

<refentry id="API-kobject-get">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>July 2015</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>kobject_get</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.4.104</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>kobject_get</refname>
 <refpurpose>
     increment refcount for object.
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>struct kobject * <function>kobject_get </function></funcdef>
   <paramdef>struct kobject * <parameter>kobj</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>kobj</parameter></term>
   <listitem>
    <para>
     object.
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
</refentry>

<refentry id="API-kobject-put">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>July 2015</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>kobject_put</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.4.104</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>kobject_put</refname>
 <refpurpose>
     decrement refcount for object.
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>void <function>kobject_put </function></funcdef>
   <paramdef>struct kobject * <parameter>kobj</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>kobj</parameter></term>
   <listitem>
    <para>
     object.
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
<title>Description</title>
<para>
   Decrement the refcount, and if 0, call <function>kobject_cleanup</function>.
</para>
</refsect1>
</refentry>

<refentry id="API-kobject-create-and-add">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>July 2015</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>kobject_create_and_add</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.4.104</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>kobject_create_and_add</refname>
 <refpurpose>
     create a struct kobject dynamically and register it with sysfs
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>struct kobject * <function>kobject_create_and_add </function></funcdef>
   <paramdef>const char * <parameter>name</parameter></paramdef>
   <paramdef>struct kobject * <parameter>parent</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>name</parameter></term>
   <listitem>
    <para>
     the name for the kset
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>parent</parameter></term>
   <listitem>
    <para>
     the parent kobject of this kobject, if any.
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
<title>Description</title>
<para>
   This function creates a kobject structure dynamically and registers it
   with sysfs.  When you are finished with this structure, call
   <function>kobject_put</function> and the structure will be dynamically freed when
   it is no longer being used.
   </para><para>

   If the kobject was not able to be created, NULL will be returned.
</para>
</refsect1>
</refentry>

<refentry id="API-kset-register">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>July 2015</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>kset_register</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.4.104</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>kset_register</refname>
 <refpurpose>
     initialize and add a kset.
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>int <function>kset_register </function></funcdef>
   <paramdef>struct kset * <parameter>k</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>k</parameter></term>
   <listitem>
    <para>
     kset.
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
</refentry>

<refentry id="API-kset-unregister">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>July 2015</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>kset_unregister</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.4.104</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>kset_unregister</refname>
 <refpurpose>
     remove a kset.
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>void <function>kset_unregister </function></funcdef>
   <paramdef>struct kset * <parameter>k</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>k</parameter></term>
   <listitem>
    <para>
     kset.
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
</refentry>

<refentry id="API-kset-create-and-add">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>July 2015</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>kset_create_and_add</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.4.104</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>kset_create_and_add</refname>
 <refpurpose>
     create a struct kset dynamically and add it to sysfs
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>struct kset * <function>kset_create_and_add </function></funcdef>
   <paramdef>const char * <parameter>name</parameter></paramdef>
   <paramdef>const struct kset_uevent_ops * <parameter>uevent_ops</parameter></paramdef>
   <paramdef>struct kobject * <parameter>parent_kobj</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>name</parameter></term>
   <listitem>
    <para>
     the name for the kset
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>uevent_ops</parameter></term>
   <listitem>
    <para>
     a struct kset_uevent_ops for the kset
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>parent_kobj</parameter></term>
   <listitem>
    <para>
     the parent kobject of this kset, if any.
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
<title>Description</title>
<para>
   This function creates a kset structure dynamically and registers it
   with sysfs.  When you are finished with this structure, call
   <function>kset_unregister</function> and the structure will be dynamically freed when it
   is no longer being used.
   </para><para>

   If the kset was not able to be created, NULL will be returned.
</para>
</refsect1>
</refentry>

     </sect1>

     <sect1><title>Kernel utility functions</title>
<!-- include/linux/kernel.h -->
<refentry id="API-upper-32-bits">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>July 2015</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>upper_32_bits</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.4.104</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>upper_32_bits</refname>
 <refpurpose>
  return bits 32-63 of a number
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef> <function>upper_32_bits </function></funcdef>
   <paramdef> <parameter>n</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>n</parameter></term>
   <listitem>
    <para>
     the number we're accessing
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
<title>Description</title>
<para>
   A basic shift-right of a 64- or 32-bit quantity.  Use this to suppress
   the <quote>right shift count &gt;= width of type</quote> warning when that quantity is
   32-bits.
</para>
</refsect1>
</refentry>

<refentry id="API-lower-32-bits">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>July 2015</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>lower_32_bits</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.4.104</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>lower_32_bits</refname>
 <refpurpose>
     return bits 0-31 of a number
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef> <function>lower_32_bits </function></funcdef>
   <paramdef> <parameter>n</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>n</parameter></term>
   <listitem>
    <para>
     the number we're accessing
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
</refentry>

<refentry id="API-might-sleep">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>July 2015</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>might_sleep</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.4.104</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>might_sleep</refname>
 <refpurpose>
     annotation for functions that can sleep
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef> <function>might_sleep </function></funcdef>
  <void/>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <para>
  None
 </para>
</refsect1>
<refsect1>
<title>Description</title>
<para>
   </para><para>

   this macro will print a stack trace if it is executed in an atomic
   context (spinlock, irq-handler, ...).
   </para><para>

   This is a useful debugging help to be able to catch problems early and not
   be bitten later when the calling function happens to sleep when it is not
   supposed to.
</para>
</refsect1>
</refentry>

<refentry id="API-trace-printk">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>July 2015</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>trace_printk</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.4.104</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>trace_printk</refname>
 <refpurpose>
     printf formatting in the ftrace buffer
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef> <function>trace_printk </function></funcdef>
   <paramdef> <parameter>fmt</parameter></paramdef>
   <paramdef> <parameter>args...</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>fmt</parameter></term>
   <listitem>
    <para>
     the printf format for printing
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>args...</parameter></term>
   <listitem>
    <para>
     variable arguments
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
<title>Note</title>
<para>
   __trace_printk is an internal function for trace_printk and
   the <parameter>ip</parameter> is passed in via the trace_printk macro.
   </para><para>

   This function allows a kernel developer to debug fast path sections
   that printk is not appropriate for. By scattering in various
   printk like tracing in the code, a developer can quickly see
   where problems are occurring.
   </para><para>

   This is intended as a debugging tool for the developer only.
   Please refrain from leaving trace_printks scattered around in
   your code.
</para>
</refsect1>
</refentry>

<refentry id="API-min-not-zero">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>July 2015</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>min_not_zero</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.4.104</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>min_not_zero</refname>
 <refpurpose>
     return the minimum that is _not_ zero, unless both are zero
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef> <function>min_not_zero </function></funcdef>
   <paramdef> <parameter>x</parameter></paramdef>
   <paramdef> <parameter>y</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>x</parameter></term>
   <listitem>
    <para>
     value1
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>y</parameter></term>
   <listitem>
    <para>
     value2
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
</refentry>

<refentry id="API-clamp">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>July 2015</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>clamp</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.4.104</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>clamp</refname>
 <refpurpose>
     return a value clamped to a given range with strict typechecking
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef> <function>clamp </function></funcdef>
   <paramdef> <parameter>val</parameter></paramdef>
   <paramdef> <parameter>min</parameter></paramdef>
   <paramdef> <parameter>max</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>val</parameter></term>
   <listitem>
    <para>
     current value
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>min</parameter></term>
   <listitem>
    <para>
     minimum allowable value
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>max</parameter></term>
   <listitem>
    <para>
     maximum allowable value
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
<title>Description</title>
<para>
   This macro does strict typechecking of min/max to make sure they are of the
   same type as val.  See the unnecessary pointer comparisons.
</para>
</refsect1>
</refentry>

<refentry id="API-clamp-t">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>July 2015</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>clamp_t</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.4.104</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>clamp_t</refname>
 <refpurpose>
     return a value clamped to a given range using a given type
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef> <function>clamp_t </function></funcdef>
   <paramdef> <parameter>type</parameter></paramdef>
   <paramdef> <parameter>val</parameter></paramdef>
   <paramdef> <parameter>min</parameter></paramdef>
   <paramdef> <parameter>max</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>type</parameter></term>
   <listitem>
    <para>
     the type of variable to use
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>val</parameter></term>
   <listitem>
    <para>
     current value
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>min</parameter></term>
   <listitem>
    <para>
     minimum allowable value
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>max</parameter></term>
   <listitem>
    <para>
     maximum allowable value
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
<title>Description</title>
<para>
   This macro does no typechecking and uses temporary variables of type
   'type' to make all the comparisons.
</para>
</refsect1>
</refentry>

<refentry id="API-clamp-val">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>July 2015</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>clamp_val</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.4.104</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>clamp_val</refname>
 <refpurpose>
     return a value clamped to a given range using val's type
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef> <function>clamp_val </function></funcdef>
   <paramdef> <parameter>val</parameter></paramdef>
   <paramdef> <parameter>min</parameter></paramdef>
   <paramdef> <parameter>max</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>val</parameter></term>
   <listitem>
    <para>
     current value
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>min</parameter></term>
   <listitem>
    <para>
     minimum allowable value
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>max</parameter></term>
   <listitem>
    <para>
     maximum allowable value
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
<title>Description</title>
<para>
   This macro does no typechecking and uses temporary variables of whatever
   type the input argument 'val' is.  This is useful when val is an unsigned
   type and min and max are literals that will otherwise be assigned a signed
   integer type.
</para>
</refsect1>
</refentry>

<refentry id="API-container-of">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>July 2015</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>container_of</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.4.104</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>container_of</refname>
 <refpurpose>
     cast a member of a structure out to the containing structure
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef> <function>container_of </function></funcdef>
   <paramdef> <parameter>ptr</parameter></paramdef>
   <paramdef> <parameter>type</parameter></paramdef>
   <paramdef> <parameter>member</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>ptr</parameter></term>
   <listitem>
    <para>
     the pointer to the member.
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>type</parameter></term>
   <listitem>
    <para>
     the type of the container struct this is embedded in.
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>member</parameter></term>
   <listitem>
    <para>
     the name of the member within the struct.
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
</refentry>

<!-- kernel/printk.c -->
<refentry id="API-printk">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>July 2015</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>printk</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.4.104</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>printk</refname>
 <refpurpose>
  print a kernel message
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>int <function>printk </function></funcdef>
   <paramdef>const char * <parameter>fmt</parameter></paramdef>
   <paramdef> <parameter>...</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>fmt</parameter></term>
   <listitem>
    <para>
     format string
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>...</parameter></term>
   <listitem>
    <para>
     variable arguments
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
<title>Description</title>
<para>
   This is <function>printk</function>.  It can be called from any context.  We want it to work.
   </para><para>

   We try to grab the console_lock.  If we succeed, it's easy - we log the output and
   call the console drivers.  If we fail to get the semaphore we place the output
   into the log buffer and return.  The current holder of the console_sem will
   notice the new output in <function>console_unlock</function>; and will send it to the
   consoles before releasing the lock.
   </para><para>

   One effect of this deferred printing is that code which calls <function>printk</function> and
   then changes console_loglevel may break. This is because console_loglevel
   is inspected when the actual printing occurs.
</para>
</refsect1>
<refsect1>
<title>See also</title>
<para>
   printf(3)
   </para><para>

   See the <function>vsnprintf</function> documentation for format string extensions over C99.
</para>
</refsect1>
</refentry>

<refentry id="API-console-lock">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>July 2015</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>console_lock</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.4.104</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>console_lock</refname>
 <refpurpose>
     lock the console system for exclusive use.
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>void <function>console_lock </function></funcdef>
   <paramdef> <parameter>void</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>void</parameter></term>
   <listitem>
    <para>
     no arguments
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
<title>Description</title>
<para>
   </para><para>

   Acquires a lock which guarantees that the caller has
   exclusive access to the console system and the console_drivers list.
   </para><para>

   Can sleep, returns nothing.
</para>
</refsect1>
</refentry>

<refentry id="API-console-trylock">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>July 2015</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>console_trylock</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.4.104</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>console_trylock</refname>
 <refpurpose>
     try to lock the console system for exclusive use.
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>int <function>console_trylock </function></funcdef>
   <paramdef> <parameter>void</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>void</parameter></term>
   <listitem>
    <para>
     no arguments
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
<title>Description</title>
<para>
   </para><para>

   Tried to acquire a lock which guarantees that the caller has
   exclusive access to the console system and the console_drivers list.
   </para><para>

   returns 1 on success, and 0 on failure to acquire the lock.
</para>
</refsect1>
</refentry>

<refentry id="API-console-conditional-schedule">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>July 2015</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>console_conditional_schedule</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.4.104</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>console_conditional_schedule</refname>
 <refpurpose>
     yield the CPU if required
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>void __sched <function>console_conditional_schedule </function></funcdef>
   <paramdef> <parameter>void</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>void</parameter></term>
   <listitem>
    <para>
     no arguments
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
<title>Description</title>
<para>
   </para><para>

   If the console code is currently allowed to sleep, and
   if this CPU should yield the CPU to another task, do
   so here.
   </para><para>

   Must be called within <function>console_lock</function>;.
</para>
</refsect1>
</refentry>

<refentry id="API-printk-timed-ratelimit">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>July 2015</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>printk_timed_ratelimit</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.4.104</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>printk_timed_ratelimit</refname>
 <refpurpose>
     caller-controlled printk ratelimiting
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>bool <function>printk_timed_ratelimit </function></funcdef>
   <paramdef>unsigned long * <parameter>caller_jiffies</parameter></paramdef>
   <paramdef>unsigned int <parameter>interval_msecs</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>caller_jiffies</parameter></term>
   <listitem>
    <para>
     pointer to caller's state
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>interval_msecs</parameter></term>
   <listitem>
    <para>
     minimum interval between prints
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
<title>Description</title>
<para>
   <function>printk_timed_ratelimit</function> returns true if more than <parameter>interval_msecs</parameter>
   milliseconds have elapsed since the last time <function>printk_timed_ratelimit</function>
   returned true.
</para>
</refsect1>
</refentry>

<refentry id="API-kmsg-dump-register">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>July 2015</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>kmsg_dump_register</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.4.104</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>kmsg_dump_register</refname>
 <refpurpose>
     register a kernel log dumper.
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>int <function>kmsg_dump_register </function></funcdef>
   <paramdef>struct kmsg_dumper * <parameter>dumper</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>dumper</parameter></term>
   <listitem>
    <para>
     pointer to the kmsg_dumper structure
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
<title>Description</title>
<para>
   Adds a kernel log dumper to the system. The dump callback in the
   structure will be called when the kernel oopses or panics and must be
   set. Returns zero on success and <constant>-EINVAL</constant> or <constant>-EBUSY</constant> otherwise.
</para>
</refsect1>
</refentry>

<refentry id="API-kmsg-dump-unregister">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>July 2015</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>kmsg_dump_unregister</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.4.104</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>kmsg_dump_unregister</refname>
 <refpurpose>
     unregister a kmsg dumper.
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>int <function>kmsg_dump_unregister </function></funcdef>
   <paramdef>struct kmsg_dumper * <parameter>dumper</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>dumper</parameter></term>
   <listitem>
    <para>
     pointer to the kmsg_dumper structure
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
<title>Description</title>
<para>
   Removes a dump device from the system. Returns zero on success and
   <constant>-EINVAL</constant> otherwise.
</para>
</refsect1>
</refentry>

<!-- kernel/panic.c -->
<refentry id="API-panic">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>July 2015</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>panic</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.4.104</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>panic</refname>
 <refpurpose>
  halt the system
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>void <function>panic </function></funcdef>
   <paramdef>const char * <parameter>fmt</parameter></paramdef>
   <paramdef> <parameter>...</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>fmt</parameter></term>
   <listitem>
    <para>
     The text string to print
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>...</parameter></term>
   <listitem>
    <para>
     variable arguments
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
<title>Description</title>
<para>
   Display a message, then perform cleanups.
   </para><para>

   This function never returns.
</para>
</refsect1>
</refentry>

<!-- kernel/sys.c -->
<refentry id="API-emergency-restart">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>July 2015</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>emergency_restart</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.4.104</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>emergency_restart</refname>
 <refpurpose>
  reboot the system
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>void <function>emergency_restart </function></funcdef>
   <paramdef> <parameter>void</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>void</parameter></term>
   <listitem>
    <para>
     no arguments
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
<title>Description</title>
<para>
   </para><para>

   Without shutting down any hardware or taking any locks
   reboot the system.  This is called when we know we are in
   trouble so this is our best effort to reboot.  This is
   safe to call in interrupt context.
</para>
</refsect1>
</refentry>

<refentry id="API-register-reboot-notifier">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>July 2015</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>register_reboot_notifier</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.4.104</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>register_reboot_notifier</refname>
 <refpurpose>
     Register function to be called at reboot time
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>int <function>register_reboot_notifier </function></funcdef>
   <paramdef>struct notifier_block * <parameter>nb</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>nb</parameter></term>
   <listitem>
    <para>
     Info about notifier function to be called
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
<title>Description</title>
<para>
   Registers a function with the list of functions
   to be called at reboot time.
   </para><para>

   Currently always returns zero, as <function>blocking_notifier_chain_register</function>
   always returns zero.
</para>
</refsect1>
</refentry>

<refentry id="API-unregister-reboot-notifier">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>July 2015</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>unregister_reboot_notifier</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.4.104</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>unregister_reboot_notifier</refname>
 <refpurpose>
     Unregister previously registered reboot notifier
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>int <function>unregister_reboot_notifier </function></funcdef>
   <paramdef>struct notifier_block * <parameter>nb</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>nb</parameter></term>
   <listitem>
    <para>
     Hook to be unregistered
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
<title>Description</title>
<para>
   Unregisters a previously registered reboot
   notifier function.
   </para><para>

   Returns zero on success, or <constant>-ENOENT</constant> on failure.
</para>
</refsect1>
</refentry>

<refentry id="API-kernel-restart">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>July 2015</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>kernel_restart</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.4.104</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>kernel_restart</refname>
 <refpurpose>
     reboot the system
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>void <function>kernel_restart </function></funcdef>
   <paramdef>char * <parameter>cmd</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>cmd</parameter></term>
   <listitem>
    <para>
     pointer to buffer containing command to execute for restart
     or <constant>NULL</constant>
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
<title>Description</title>
<para>
   Shutdown everything and perform a clean reboot.
   This is not safe to call in interrupt context.
</para>
</refsect1>
</refentry>

<refentry id="API-kernel-halt">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>July 2015</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>kernel_halt</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.4.104</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>kernel_halt</refname>
 <refpurpose>
     halt the system
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>void <function>kernel_halt </function></funcdef>
   <paramdef> <parameter>void</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>void</parameter></term>
   <listitem>
    <para>
     no arguments
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
<title>Description</title>
<para>
   </para><para>

   Shutdown everything and perform a clean system halt.
</para>
</refsect1>
</refentry>

<refentry id="API-kernel-power-off">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>July 2015</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>kernel_power_off</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.4.104</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>kernel_power_off</refname>
 <refpurpose>
     power_off the system
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>void <function>kernel_power_off </function></funcdef>
   <paramdef> <parameter>void</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>void</parameter></term>
   <listitem>
    <para>
     no arguments
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
<title>Description</title>
<para>
   </para><para>

   Shutdown everything and perform a clean system power_off.
</para>
</refsect1>
</refentry>

<refentry id="API-orderly-poweroff">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>July 2015</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>orderly_poweroff</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.4.104</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>orderly_poweroff</refname>
 <refpurpose>
     Trigger an orderly system poweroff
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>int <function>orderly_poweroff </function></funcdef>
   <paramdef>bool <parameter>force</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>force</parameter></term>
   <listitem>
    <para>
     force poweroff if command execution fails
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
<title>Description</title>
<para>
   This may be called from any context to trigger a system shutdown.
   If the orderly shutdown fails, it will force an immediate shutdown.
</para>
</refsect1>
</refentry>

<!-- kernel/rcupdate.c -->
<refentry id="API-rcu-read-lock-bh-held">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>July 2015</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>rcu_read_lock_bh_held</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.4.104</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>rcu_read_lock_bh_held</refname>
 <refpurpose>
  might we be in RCU-bh read-side critical section?
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>int <function>rcu_read_lock_bh_held </function></funcdef>
   <paramdef> <parameter>void</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>void</parameter></term>
   <listitem>
    <para>
     no arguments
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
<title>Description</title>
<para>
   </para><para>

   Check for bottom half being disabled, which covers both the
   CONFIG_PROVE_RCU and not cases.  Note that if someone uses
   <function>rcu_read_lock_bh</function>, but then later enables BH, lockdep (if enabled)
   will show the situation.  This is useful for debug checks in functions
   that require that they be called within an RCU read-side critical
   section.
   </para><para>

   Check <function>debug_lockdep_rcu_enabled</function> to prevent false positives during boot.
   </para><para>

   Note that <function>rcu_read_lock</function> is disallowed if the CPU is either idle or
   offline from an RCU perspective, so check for those as well.
</para>
</refsect1>
</refentry>

<refentry id="API-init-rcu-head-on-stack">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>July 2015</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>init_rcu_head_on_stack</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.4.104</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>init_rcu_head_on_stack</refname>
 <refpurpose>
     initialize on-stack rcu_head for debugobjects
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>void <function>init_rcu_head_on_stack </function></funcdef>
   <paramdef>struct rcu_head * <parameter>head</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>head</parameter></term>
   <listitem>
    <para>
     pointer to rcu_head structure to be initialized
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
<title>Description</title>
<para>
   This function informs debugobjects of a new rcu_head structure that
   has been allocated as an auto variable on the stack.  This function
   is not required for rcu_head structures that are statically defined or
   that are dynamically allocated on the heap.  This function has no
   effect for !CONFIG_DEBUG_OBJECTS_RCU_HEAD kernel builds.
</para>
</refsect1>
</refentry>

<refentry id="API-destroy-rcu-head-on-stack">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>July 2015</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>destroy_rcu_head_on_stack</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.4.104</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>destroy_rcu_head_on_stack</refname>
 <refpurpose>
     destroy on-stack rcu_head for debugobjects
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>void <function>destroy_rcu_head_on_stack </function></funcdef>
   <paramdef>struct rcu_head * <parameter>head</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>head</parameter></term>
   <listitem>
    <para>
     pointer to rcu_head structure to be initialized
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
<title>Description</title>
<para>
   This function informs debugobjects that an on-stack rcu_head structure
   is about to go out of scope.  As with <function>init_rcu_head_on_stack</function>, this
   function is not required for rcu_head structures that are statically
   defined or that are dynamically allocated on the heap.  Also as with
   <function>init_rcu_head_on_stack</function>, this function has no effect for
   !CONFIG_DEBUG_OBJECTS_RCU_HEAD kernel builds.
</para>
</refsect1>
</refentry>

     </sect1>

     <sect1><title>Device Resource Management</title>
<!-- drivers/base/devres.c -->
<refentry id="API-devres-alloc">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>July 2015</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>devres_alloc</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.4.104</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>devres_alloc</refname>
 <refpurpose>
  Allocate device resource data
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>void * <function>devres_alloc </function></funcdef>
   <paramdef>dr_release_t <parameter>release</parameter></paramdef>
   <paramdef>size_t <parameter>size</parameter></paramdef>
   <paramdef>gfp_t <parameter>gfp</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>release</parameter></term>
   <listitem>
    <para>
     Release function devres will be associated with
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>size</parameter></term>
   <listitem>
    <para>
     Allocation size
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>gfp</parameter></term>
   <listitem>
    <para>
     Allocation flags
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
<title>Description</title>
<para>
   Allocate devres of <parameter>size</parameter> bytes.  The allocated area is zeroed, then
   associated with <parameter>release</parameter>.  The returned pointer can be passed to
   other devres_*() functions.
</para>
</refsect1>
<refsect1>
<title>RETURNS</title>
<para>
   Pointer to allocated devres on success, NULL on failure.
</para>
</refsect1>
</refentry>

<refentry id="API-devres-free">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>July 2015</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>devres_free</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.4.104</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>devres_free</refname>
 <refpurpose>
     Free device resource data
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>void <function>devres_free </function></funcdef>
   <paramdef>void * <parameter>res</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>res</parameter></term>
   <listitem>
    <para>
     Pointer to devres data to free
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
<title>Description</title>
<para>
   Free devres created with <function>devres_alloc</function>.
</para>
</refsect1>
</refentry>

<refentry id="API-devres-add">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>July 2015</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>devres_add</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.4.104</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>devres_add</refname>
 <refpurpose>
     Register device resource
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>void <function>devres_add </function></funcdef>
   <paramdef>struct device * <parameter>dev</parameter></paramdef>
   <paramdef>void * <parameter>res</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>dev</parameter></term>
   <listitem>
    <para>
     Device to add resource to
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>res</parameter></term>
   <listitem>
    <para>
     Resource to register
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
<title>Description</title>
<para>
   Register devres <parameter>res</parameter> to <parameter>dev</parameter>.  <parameter>res</parameter> should have been allocated
   using <function>devres_alloc</function>.  On driver detach, the associated release
   function will be invoked and devres will be freed automatically.
</para>
</refsect1>
</refentry>

<refentry id="API-devres-find">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>July 2015</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>devres_find</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.4.104</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>devres_find</refname>
 <refpurpose>
     Find device resource
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>void * <function>devres_find </function></funcdef>
   <paramdef>struct device * <parameter>dev</parameter></paramdef>
   <paramdef>dr_release_t <parameter>release</parameter></paramdef>
   <paramdef>dr_match_t <parameter>match</parameter></paramdef>
   <paramdef>void * <parameter>match_data</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>dev</parameter></term>
   <listitem>
    <para>
     Device to lookup resource from
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>release</parameter></term>
   <listitem>
    <para>
     Look for resources associated with this release function
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>match</parameter></term>
   <listitem>
    <para>
     Match function (optional)
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>match_data</parameter></term>
   <listitem>
    <para>
     Data for the match function
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
<title>Description</title>
<para>
   Find the latest devres of <parameter>dev</parameter> which is associated with <parameter>release</parameter>
   and for which <parameter>match</parameter> returns 1.  If <parameter>match</parameter> is NULL, it's considered
   to match all.
</para>
</refsect1>
<refsect1>
<title>RETURNS</title>
<para>
   Pointer to found devres, NULL if not found.
</para>
</refsect1>
</refentry>

<refentry id="API-devres-get">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>July 2015</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>devres_get</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.4.104</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>devres_get</refname>
 <refpurpose>
     Find devres, if non-existent, add one atomically
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>void * <function>devres_get </function></funcdef>
   <paramdef>struct device * <parameter>dev</parameter></paramdef>
   <paramdef>void * <parameter>new_res</parameter></paramdef>
   <paramdef>dr_match_t <parameter>match</parameter></paramdef>
   <paramdef>void * <parameter>match_data</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>dev</parameter></term>
   <listitem>
    <para>
     Device to lookup or add devres for
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>new_res</parameter></term>
   <listitem>
    <para>
     Pointer to new initialized devres to add if not found
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>match</parameter></term>
   <listitem>
    <para>
     Match function (optional)
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>match_data</parameter></term>
   <listitem>
    <para>
     Data for the match function
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
<title>Description</title>
<para>
   Find the latest devres of <parameter>dev</parameter> which has the same release function
   as <parameter>new_res</parameter> and for which <parameter>match</parameter> return 1.  If found, <parameter>new_res</parameter> is
   freed; otherwise, <parameter>new_res</parameter> is added atomically.
</para>
</refsect1>
<refsect1>
<title>RETURNS</title>
<para>
   Pointer to found or added devres.
</para>
</refsect1>
</refentry>

<refentry id="API-devres-remove">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>July 2015</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>devres_remove</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.4.104</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>devres_remove</refname>
 <refpurpose>
     Find a device resource and remove it
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>void * <function>devres_remove </function></funcdef>
   <paramdef>struct device * <parameter>dev</parameter></paramdef>
   <paramdef>dr_release_t <parameter>release</parameter></paramdef>
   <paramdef>dr_match_t <parameter>match</parameter></paramdef>
   <paramdef>void * <parameter>match_data</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>dev</parameter></term>
   <listitem>
    <para>
     Device to find resource from
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>release</parameter></term>
   <listitem>
    <para>
     Look for resources associated with this release function
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>match</parameter></term>
   <listitem>
    <para>
     Match function (optional)
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>match_data</parameter></term>
   <listitem>
    <para>
     Data for the match function
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
<title>Description</title>
<para>
   Find the latest devres of <parameter>dev</parameter> associated with <parameter>release</parameter> and for
   which <parameter>match</parameter> returns 1.  If <parameter>match</parameter> is NULL, it's considered to
   match all.  If found, the resource is removed atomically and
   returned.
</para>
</refsect1>
<refsect1>
<title>RETURNS</title>
<para>
   Pointer to removed devres on success, NULL if not found.
</para>
</refsect1>
</refentry>

<refentry id="API-devres-destroy">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>July 2015</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>devres_destroy</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.4.104</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>devres_destroy</refname>
 <refpurpose>
     Find a device resource and destroy it
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>int <function>devres_destroy </function></funcdef>
   <paramdef>struct device * <parameter>dev</parameter></paramdef>
   <paramdef>dr_release_t <parameter>release</parameter></paramdef>
   <paramdef>dr_match_t <parameter>match</parameter></paramdef>
   <paramdef>void * <parameter>match_data</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>dev</parameter></term>
   <listitem>
    <para>
     Device to find resource from
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>release</parameter></term>
   <listitem>
    <para>
     Look for resources associated with this release function
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>match</parameter></term>
   <listitem>
    <para>
     Match function (optional)
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>match_data</parameter></term>
   <listitem>
    <para>
     Data for the match function
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
<title>Description</title>
<para>
   Find the latest devres of <parameter>dev</parameter> associated with <parameter>release</parameter> and for
   which <parameter>match</parameter> returns 1.  If <parameter>match</parameter> is NULL, it's considered to
   match all.  If found, the resource is removed atomically and freed.
</para>
</refsect1>
<refsect1>
<title>RETURNS</title>
<para>
   0 if devres is found and freed, -ENOENT if not found.
</para>
</refsect1>
</refentry>

<refentry id="API-devres-open-group">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>July 2015</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>devres_open_group</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.4.104</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>devres_open_group</refname>
 <refpurpose>
     Open a new devres group
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>void * <function>devres_open_group </function></funcdef>
   <paramdef>struct device * <parameter>dev</parameter></paramdef>
   <paramdef>void * <parameter>id</parameter></paramdef>
   <paramdef>gfp_t <parameter>gfp</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>dev</parameter></term>
   <listitem>
    <para>
     Device to open devres group for
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>id</parameter></term>
   <listitem>
    <para>
     Separator ID
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>gfp</parameter></term>
   <listitem>
    <para>
     Allocation flags
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
<title>Description</title>
<para>
   Open a new devres group for <parameter>dev</parameter> with <parameter>id</parameter>.  For <parameter>id</parameter>, using a
   pointer to an object which won't be used for another group is
   recommended.  If <parameter>id</parameter> is NULL, address-wise unique ID is created.
</para>
</refsect1>
<refsect1>
<title>RETURNS</title>
<para>
   ID of the new group, NULL on failure.
</para>
</refsect1>
</refentry>

<refentry id="API-devres-close-group">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>July 2015</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>devres_close_group</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.4.104</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>devres_close_group</refname>
 <refpurpose>
     Close a devres group
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>void <function>devres_close_group </function></funcdef>
   <paramdef>struct device * <parameter>dev</parameter></paramdef>
   <paramdef>void * <parameter>id</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>dev</parameter></term>
   <listitem>
    <para>
     Device to close devres group for
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>id</parameter></term>
   <listitem>
    <para>
     ID of target group, can be NULL
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
<title>Description</title>
<para>
   Close the group identified by <parameter>id</parameter>.  If <parameter>id</parameter> is NULL, the latest open
   group is selected.
</para>
</refsect1>
</refentry>

<refentry id="API-devres-remove-group">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>July 2015</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>devres_remove_group</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.4.104</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>devres_remove_group</refname>
 <refpurpose>
     Remove a devres group
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>void <function>devres_remove_group </function></funcdef>
   <paramdef>struct device * <parameter>dev</parameter></paramdef>
   <paramdef>void * <parameter>id</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>dev</parameter></term>
   <listitem>
    <para>
     Device to remove group for
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>id</parameter></term>
   <listitem>
    <para>
     ID of target group, can be NULL
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
<title>Description</title>
<para>
   Remove the group identified by <parameter>id</parameter>.  If <parameter>id</parameter> is NULL, the latest
   open group is selected.  Note that removing a group doesn't affect
   any other resources.
</para>
</refsect1>
</refentry>

<refentry id="API-devres-release-group">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>July 2015</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>devres_release_group</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.4.104</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>devres_release_group</refname>
 <refpurpose>
     Release resources in a devres group
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>int <function>devres_release_group </function></funcdef>
   <paramdef>struct device * <parameter>dev</parameter></paramdef>
   <paramdef>void * <parameter>id</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>dev</parameter></term>
   <listitem>
    <para>
     Device to release group for
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>id</parameter></term>
   <listitem>
    <para>
     ID of target group, can be NULL
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
<title>Description</title>
<para>
   Release all resources in the group identified by <parameter>id</parameter>.  If <parameter>id</parameter> is
   NULL, the latest open group is selected.  The selected group and
   groups properly nested inside the selected group are removed.
</para>
</refsect1>
<refsect1>
<title>RETURNS</title>
<para>
   The number of released non-group resources.
</para>
</refsect1>
</refentry>

<refentry id="API-devm-kzalloc">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>July 2015</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>devm_kzalloc</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.4.104</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>devm_kzalloc</refname>
 <refpurpose>
     Resource-managed kzalloc
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>void * <function>devm_kzalloc </function></funcdef>
   <paramdef>struct device * <parameter>dev</parameter></paramdef>
   <paramdef>size_t <parameter>size</parameter></paramdef>
   <paramdef>gfp_t <parameter>gfp</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>dev</parameter></term>
   <listitem>
    <para>
     Device to allocate memory for
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>size</parameter></term>
   <listitem>
    <para>
     Allocation size
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>gfp</parameter></term>
   <listitem>
    <para>
     Allocation gfp flags
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
<title>Description</title>
<para>
   Managed kzalloc.  Memory allocated with this function is
   automatically freed on driver detach.  Like all other devres
   resources, guaranteed alignment is unsigned long long.
</para>
</refsect1>
<refsect1>
<title>RETURNS</title>
<para>
   Pointer to allocated memory on success, NULL on failure.
</para>
</refsect1>
</refentry>

<refentry id="API-devm-kfree">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>July 2015</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>devm_kfree</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.4.104</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>devm_kfree</refname>
 <refpurpose>
     Resource-managed kfree
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>void <function>devm_kfree </function></funcdef>
   <paramdef>struct device * <parameter>dev</parameter></paramdef>
   <paramdef>void * <parameter>p</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>dev</parameter></term>
   <listitem>
    <para>
     Device this memory belongs to
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>p</parameter></term>
   <listitem>
    <para>
     Memory to free
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
<title>Description</title>
<para>
   Free memory allocated with <function>devm_kzalloc</function>.
</para>
</refsect1>
</refentry>

     </sect1>

  </chapter>

  <chapter id="devdrivers">
     <title>Device drivers infrastructure</title>
     <sect1><title>The Basic Device Driver-Model Structures </title>
<!-- include/linux/device.h -->
<refentry id="API-struct-bus-type">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>July 2015</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>struct bus_type</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.4.104</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>struct bus_type</refname>
 <refpurpose>
  The bus type of the device
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <programlisting>
struct bus_type {
  const char * name;
  const char * dev_name;
  struct device * dev_root;
  struct bus_attribute * bus_attrs;
  struct device_attribute * dev_attrs;
  struct driver_attribute * drv_attrs;
  int (* match) (struct device *dev, struct device_driver *drv);
  int (* uevent) (struct device *dev, struct kobj_uevent_env *env);
  int (* probe) (struct device *dev);
  int (* remove) (struct device *dev);
  void (* shutdown) (struct device *dev);
  int (* suspend) (struct device *dev, pm_message_t state);
  int (* resume) (struct device *dev);
  const struct dev_pm_ops * pm;
  struct iommu_ops * iommu_ops;
  struct subsys_private * p;
};  </programlisting>
</refsynopsisdiv>
 <refsect1>
  <title>Members</title>
  <variablelist>
    <varlistentry>      <term>name</term>
      <listitem><para>
The name of the bus.
      </para></listitem>
    </varlistentry>
    <varlistentry>      <term>dev_name</term>
      <listitem><para>
Used for subsystems to enumerate devices like (<quote>foo<constant>u</constant></quote>, dev-&gt;id).
      </para></listitem>
    </varlistentry>
    <varlistentry>      <term>dev_root</term>
      <listitem><para>
Default device to use as the parent.
      </para></listitem>
    </varlistentry>
    <varlistentry>      <term>bus_attrs</term>
      <listitem><para>
Default attributes of the bus.
      </para></listitem>
    </varlistentry>
    <varlistentry>      <term>dev_attrs</term>
      <listitem><para>
Default attributes of the devices on the bus.
      </para></listitem>
    </varlistentry>
    <varlistentry>      <term>drv_attrs</term>
      <listitem><para>
Default attributes of the device drivers on the bus.
      </para></listitem>
    </varlistentry>
    <varlistentry>      <term>match</term>
      <listitem><para>
Called, perhaps multiple times, whenever a new device or driver
is added for this bus. It should return a nonzero value if the
given device can be handled by the given driver.
      </para></listitem>
    </varlistentry>
    <varlistentry>      <term>uevent</term>
      <listitem><para>
Called when a device is added, removed, or a few other things
that generate uevents to add the environment variables.
      </para></listitem>
    </varlistentry>
    <varlistentry>      <term>probe</term>
      <listitem><para>
Called when a new device or driver add to this bus, and callback
the specific driver's probe to initial the matched device.
      </para></listitem>
    </varlistentry>
    <varlistentry>      <term>remove</term>
      <listitem><para>
Called when a device removed from this bus.
      </para></listitem>
    </varlistentry>
    <varlistentry>      <term>shutdown</term>
      <listitem><para>
Called at shut-down time to quiesce the device.
      </para></listitem>
    </varlistentry>
    <varlistentry>      <term>suspend</term>
      <listitem><para>
Called when a device on this bus wants to go to sleep mode.
      </para></listitem>
    </varlistentry>
    <varlistentry>      <term>resume</term>
      <listitem><para>
Called to bring a device on this bus out of sleep mode.
      </para></listitem>
    </varlistentry>
    <varlistentry>      <term>pm</term>
      <listitem><para>
Power management operations of this bus, callback the specific
device driver's pm-ops.
      </para></listitem>
    </varlistentry>
    <varlistentry>      <term>iommu_ops</term>
      <listitem><para>
IOMMU specific operations for this bus, used to attach IOMMU
driver implementations to a bus and allow the driver to do
bus-specific setup
      </para></listitem>
    </varlistentry>
    <varlistentry>      <term>p</term>
      <listitem><para>
The private data of the driver core, only the driver core can
touch this.
      </para></listitem>
    </varlistentry>
  </variablelist>
 </refsect1>
<refsect1>
<title>Description</title>
<para>
   A bus is a channel between the processor and one or more devices. For the
   purposes of the device model, all devices are connected via a bus, even if
   it is an internal, virtual, <quote>platform</quote> bus. Buses can plug into each other.
   A USB controller is usually a PCI device, for example. The device model
   represents the actual connections between buses and the devices they control.
   A bus is represented by the bus_type structure. It contains the name, the
   default attributes, the bus' methods, PM operations, and the driver core's
   private data.
</para>
</refsect1>
</refentry>

<refentry id="API-struct-device-driver">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>July 2015</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>struct device_driver</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.4.104</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>struct device_driver</refname>
 <refpurpose>
     The basic device driver structure
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <programlisting>
struct device_driver {
  const char * name;
  struct bus_type * bus;
  struct module * owner;
  const char * mod_name;
  bool suppress_bind_attrs;
  const struct of_device_id * of_match_table;
  int (* probe) (struct device *dev);
  int (* remove) (struct device *dev);
  void (* shutdown) (struct device *dev);
  int (* suspend) (struct device *dev, pm_message_t state);
  int (* resume) (struct device *dev);
  const struct attribute_group ** groups;
  const struct dev_pm_ops * pm;
  struct driver_private * p;
};  </programlisting>
</refsynopsisdiv>
 <refsect1>
  <title>Members</title>
  <variablelist>
    <varlistentry>      <term>name</term>
      <listitem><para>
   Name of the device driver.
      </para></listitem>
    </varlistentry>
    <varlistentry>      <term>bus</term>
      <listitem><para>
   The bus which the device of this driver belongs to.
      </para></listitem>
    </varlistentry>
    <varlistentry>      <term>owner</term>
      <listitem><para>
   The module owner.
      </para></listitem>
    </varlistentry>
    <varlistentry>      <term>mod_name</term>
      <listitem><para>
   Used for built-in modules.
      </para></listitem>
    </varlistentry>
    <varlistentry>      <term>suppress_bind_attrs</term>
      <listitem><para>
   Disables bind/unbind via sysfs.
      </para></listitem>
    </varlistentry>
    <varlistentry>      <term>of_match_table</term>
      <listitem><para>
   The open firmware table.
      </para></listitem>
    </varlistentry>
    <varlistentry>      <term>probe</term>
      <listitem><para>
   Called to query the existence of a specific device,
   whether this driver can work with it, and bind the driver
   to a specific device.
      </para></listitem>
    </varlistentry>
    <varlistentry>      <term>remove</term>
      <listitem><para>
   Called when the device is removed from the system to
   unbind a device from this driver.
      </para></listitem>
    </varlistentry>
    <varlistentry>      <term>shutdown</term>
      <listitem><para>
   Called at shut-down time to quiesce the device.
      </para></listitem>
    </varlistentry>
    <varlistentry>      <term>suspend</term>
      <listitem><para>
   Called to put the device to sleep mode. Usually to a
   low power state.
      </para></listitem>
    </varlistentry>
    <varlistentry>      <term>resume</term>
      <listitem><para>
   Called to bring a device from sleep mode.
      </para></listitem>
    </varlistentry>
    <varlistentry>      <term>groups</term>
      <listitem><para>
   Default attributes that get created by the driver core
   automatically.
      </para></listitem>
    </varlistentry>
    <varlistentry>      <term>pm</term>
      <listitem><para>
   Power management operations of the device which matched
   this driver.
      </para></listitem>
    </varlistentry>
    <varlistentry>      <term>p</term>
      <listitem><para>
   Driver core's private data, no one other than the driver
   core can touch this.
      </para></listitem>
    </varlistentry>
  </variablelist>
 </refsect1>
<refsect1>
<title>Description</title>
<para>
   The device driver-model tracks all of the drivers known to the system.
   The main reason for this tracking is to enable the driver core to match
   up drivers with new devices. Once drivers are known objects within the
   system, however, a number of other things become possible. Device drivers
   can export information and configuration variables that are independent
   of any specific device.
</para>
</refsect1>
</refentry>

<refentry id="API-struct-subsys-interface">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>July 2015</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>struct subsys_interface</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.4.104</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>struct subsys_interface</refname>
 <refpurpose>
     interfaces to device functions
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <programlisting>
struct subsys_interface {
  const char * name;
  struct bus_type * subsys;
  struct list_head node;
  int (* add_dev) (struct device *dev, struct subsys_interface *sif);
  int (* remove_dev) (struct device *dev, struct subsys_interface *sif);
};  </programlisting>
</refsynopsisdiv>
 <refsect1>
  <title>Members</title>
  <variablelist>
    <varlistentry>      <term>name</term>
      <listitem><para>
   name of the device function
      </para></listitem>
    </varlistentry>
    <varlistentry>      <term>subsys</term>
      <listitem><para>
   subsytem of the devices to attach to
      </para></listitem>
    </varlistentry>
    <varlistentry>      <term>node</term>
      <listitem><para>
   the list of functions registered at the subsystem
      </para></listitem>
    </varlistentry>
    <varlistentry>      <term>add_dev</term>
      <listitem><para>
   device hookup to device function handler
      </para></listitem>
    </varlistentry>
    <varlistentry>      <term>remove_dev</term>
      <listitem><para>
   device hookup to device function handler
      </para></listitem>
    </varlistentry>
  </variablelist>
 </refsect1>
<refsect1>
<title>Description</title>
<para>
   Simple interfaces attached to a subsystem. Multiple interfaces can
   attach to a subsystem and its devices. Unlike drivers, they do not
   exclusively claim or control devices. Interfaces usually represent
   a specific functionality of a subsystem/class of devices.
</para>
</refsect1>
</refentry>

<refentry id="API-struct-class">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>July 2015</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>struct class</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.4.104</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>struct class</refname>
 <refpurpose>
     device classes
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <programlisting>
struct class {
  const char * name;
  struct module * owner;
  struct class_attribute * class_attrs;
  struct device_attribute * dev_attrs;
  struct bin_attribute * dev_bin_attrs;
  struct kobject * dev_kobj;
  int (* dev_uevent) (struct device *dev, struct kobj_uevent_env *env);
  char *(* devnode) (struct device *dev, umode_t *mode);
  void (* class_release) (struct class *class);
  void (* dev_release) (struct device *dev);
  int (* suspend) (struct device *dev, pm_message_t state);
  int (* resume) (struct device *dev);
  const struct kobj_ns_type_operations * ns_type;
  const void *(* namespace) (struct device *dev);
  const struct dev_pm_ops * pm;
  struct subsys_private * p;
};  </programlisting>
</refsynopsisdiv>
 <refsect1>
  <title>Members</title>
  <variablelist>
    <varlistentry>      <term>name</term>
      <listitem><para>
   Name of the class.
      </para></listitem>
    </varlistentry>
    <varlistentry>      <term>owner</term>
      <listitem><para>
   The module owner.
      </para></listitem>
    </varlistentry>
    <varlistentry>      <term>class_attrs</term>
      <listitem><para>
   Default attributes of this class.
      </para></listitem>
    </varlistentry>
    <varlistentry>      <term>dev_attrs</term>
      <listitem><para>
   Default attributes of the devices belong to the class.
      </para></listitem>
    </varlistentry>
    <varlistentry>      <term>dev_bin_attrs</term>
      <listitem><para>
   Default binary attributes of the devices belong to the class.
      </para></listitem>
    </varlistentry>
    <varlistentry>      <term>dev_kobj</term>
      <listitem><para>
   The kobject that represents this class and links it into the hierarchy.
      </para></listitem>
    </varlistentry>
    <varlistentry>      <term>dev_uevent</term>
      <listitem><para>
   Called when a device is added, removed from this class, or a
   few other things that generate uevents to add the environment
   variables.
      </para></listitem>
    </varlistentry>
    <varlistentry>      <term>devnode</term>
      <listitem><para>
   Callback to provide the devtmpfs.
      </para></listitem>
    </varlistentry>
    <varlistentry>      <term>class_release</term>
      <listitem><para>
   Called to release this class.
      </para></listitem>
    </varlistentry>
    <varlistentry>      <term>dev_release</term>
      <listitem><para>
   Called to release the device.
      </para></listitem>
    </varlistentry>
    <varlistentry>      <term>suspend</term>
      <listitem><para>
   Used to put the device to sleep mode, usually to a low power
   state.
      </para></listitem>
    </varlistentry>
    <varlistentry>      <term>resume</term>
      <listitem><para>
   Used to bring the device from the sleep mode.
      </para></listitem>
    </varlistentry>
    <varlistentry>      <term>ns_type</term>
      <listitem><para>
   Callbacks so sysfs can detemine namespaces.
      </para></listitem>
    </varlistentry>
    <varlistentry>      <term>namespace</term>
      <listitem><para>
   Namespace of the device belongs to this class.
      </para></listitem>
    </varlistentry>
    <varlistentry>      <term>pm</term>
      <listitem><para>
   The default device power management operations of this class.
      </para></listitem>
    </varlistentry>
    <varlistentry>      <term>p</term>
      <listitem><para>
   The private data of the driver core, no one other than the
   driver core can touch this.
      </para></listitem>
    </varlistentry>
  </variablelist>
 </refsect1>
<refsect1>
<title>Description</title>
<para>
   A class is a higher-level view of a device that abstracts out low-level
   implementation details. Drivers may see a SCSI disk or an ATA disk, but,
   at the class level, they are all simply disks. Classes allow user space
   to work with devices based on what they do, rather than how they are
   connected or how they work.
</para>
</refsect1>
</refentry>

<refentry id="API-struct-device">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>July 2015</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>struct device</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.4.104</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>struct device</refname>
 <refpurpose>
     The basic device structure
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <programlisting>
struct device {
  struct device * parent;
  struct device_private * p;
  struct kobject kobj;
  const char * init_name;
  const struct device_type * type;
  struct mutex mutex;
  struct bus_type * bus;
  struct device_driver * driver;
  void * platform_data;
  struct dev_pm_info power;
  struct dev_pm_domain * pm_domain;
#ifdef CONFIG_NUMA
  int numa_node;
#endif
  u64 * dma_mask;
  u64 coherent_dma_mask;
  struct device_dma_parameters * dma_parms;
  struct list_head dma_pools;
  struct dma_coherent_mem * dma_mem;
  struct dev_archdata archdata;
  struct device_node * of_node;
  dev_t devt;
  u32 id;
  spinlock_t devres_lock;
  struct list_head devres_head;
  struct klist_node knode_class;
  struct class * class;
  const struct attribute_group ** groups;
  void (* release) (struct device *dev);
};  </programlisting>
</refsynopsisdiv>
 <refsect1>
  <title>Members</title>
  <variablelist>
    <varlistentry>      <term>parent</term>
      <listitem><para>
   The device's <quote>parent</quote> device, the device to which it is attached.
   In most cases, a parent device is some sort of bus or host
   controller. If parent is NULL, the device, is a top-level device,
   which is not usually what you want.
      </para></listitem>
    </varlistentry>
    <varlistentry>      <term>p</term>
      <listitem><para>
   Holds the private data of the driver core portions of the device.
   See the comment of the struct device_private for detail.
      </para></listitem>
    </varlistentry>
    <varlistentry>      <term>kobj</term>
      <listitem><para>
   A top-level, abstract class from which other classes are derived.
      </para></listitem>
    </varlistentry>
    <varlistentry>      <term>init_name</term>
      <listitem><para>
   Initial name of the device.
      </para></listitem>
    </varlistentry>
    <varlistentry>      <term>type</term>
      <listitem><para>
   The type of device.
   This identifies the device type and carries type-specific
   information.
      </para></listitem>
    </varlistentry>
    <varlistentry>      <term>mutex</term>
      <listitem><para>
   Mutex to synchronize calls to its driver.
      </para></listitem>
    </varlistentry>
    <varlistentry>      <term>bus</term>
      <listitem><para>
   Type of bus device is on.
      </para></listitem>
    </varlistentry>
    <varlistentry>      <term>driver</term>
      <listitem><para>
   Which driver has allocated this
      </para></listitem>
    </varlistentry>
    <varlistentry>      <term>platform_data</term>
      <listitem><para>
   Platform data specific to the device.
      </para></listitem>
    </varlistentry>
    <varlistentry>      <term>power</term>
      <listitem><para>
   For device power management.
   See Documentation/power/devices.txt for details.
      </para></listitem>
    </varlistentry>
    <varlistentry>      <term>pm_domain</term>
      <listitem><para>
   Provide callbacks that are executed during system suspend,
   hibernation, system resume and during runtime PM transitions
   along with subsystem-level and driver-level callbacks.
      </para></listitem>
    </varlistentry>
    <varlistentry>      <term>numa_node</term>
      <listitem><para>
   NUMA node this device is close to.
      </para></listitem>
    </varlistentry>
    <varlistentry>      <term>dma_mask</term>
      <listitem><para>
   Dma mask (if dma'ble device).
      </para></listitem>
    </varlistentry>
    <varlistentry>      <term>coherent_dma_mask</term>
      <listitem><para>
   Like dma_mask, but for alloc_coherent mapping as not all
   hardware supports 64-bit addresses for consistent allocations
   such descriptors.
      </para></listitem>
    </varlistentry>
    <varlistentry>      <term>dma_parms</term>
      <listitem><para>
   A low level driver may set these to teach IOMMU code about
   segment limitations.
      </para></listitem>
    </varlistentry>
    <varlistentry>      <term>dma_pools</term>
      <listitem><para>
   Dma pools (if dma'ble device).
      </para></listitem>
    </varlistentry>
    <varlistentry>      <term>dma_mem</term>
      <listitem><para>
   Internal for coherent mem override.
      </para></listitem>
    </varlistentry>
    <varlistentry>      <term>archdata</term>
      <listitem><para>
   For arch-specific additions.
      </para></listitem>
    </varlistentry>
    <varlistentry>      <term>of_node</term>
      <listitem><para>
   Associated device tree node.
      </para></listitem>
    </varlistentry>
    <varlistentry>      <term>devt</term>
      <listitem><para>
   For creating the sysfs <quote>dev</quote>.
      </para></listitem>
    </varlistentry>
    <varlistentry>      <term>id</term>
      <listitem><para>
   device instance
      </para></listitem>
    </varlistentry>
    <varlistentry>      <term>devres_lock</term>
      <listitem><para>
   Spinlock to protect the resource of the device.
      </para></listitem>
    </varlistentry>
    <varlistentry>      <term>devres_head</term>
      <listitem><para>
   The resources list of the device.
      </para></listitem>
    </varlistentry>
    <varlistentry>      <term>knode_class</term>
      <listitem><para>
   The node used to add the device to the class list.
      </para></listitem>
    </varlistentry>
    <varlistentry>      <term>class</term>
      <listitem><para>
   The class of the device.
      </para></listitem>
    </varlistentry>
    <varlistentry>      <term>groups</term>
      <listitem><para>
   Optional attribute groups.
      </para></listitem>
    </varlistentry>
    <varlistentry>      <term>release</term>
      <listitem><para>
   Callback to free the device after all references have
   gone away. This should be set by the allocator of the
   device (i.e. the bus driver that discovered the device).
      </para></listitem>
    </varlistentry>
  </variablelist>
 </refsect1>
<refsect1>
<title>Example</title>
<informalexample><programlisting>
   For devices on custom boards, as typical of embedded
   and SOC based hardware, Linux often uses platform_data to point
   to board-specific structures describing devices and how they
   are wired.  That can include what ports are available, chip
   variants, which GPIO pins act in what additional roles, and so
   on.  This shrinks the <quote>Board Support Packages</quote> (BSPs) and
   minimizes board-specific #ifdefs in drivers.
</programlisting></informalexample>
</refsect1>
<refsect1>
<title>Description</title>
<para>
   At the lowest level, every device in a Linux system is represented by an
   instance of struct device. The device structure contains the information
   that the device model core needs to model the system. Most subsystems,
   however, track additional information about the devices they host. As a
   result, it is rare for devices to be represented by bare device structures;
   instead, that structure, like kobject structures, is usually embedded within
   a higher-level representation of the device.
</para>
</refsect1>
</refentry>

<refentry id="API-module-driver">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>July 2015</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>module_driver</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.4.104</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>module_driver</refname>
 <refpurpose>
     Helper macro for drivers that don't do anything special in module init/exit. This eliminates a lot of boilerplate. Each module may only use this macro once, and calling it replaces <function>module_init</function> and <function>module_exit</function>.
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef> <function>module_driver </function></funcdef>
   <paramdef> <parameter>__driver</parameter></paramdef>
   <paramdef> <parameter>__register</parameter></paramdef>
   <paramdef> <parameter>__unregister</parameter></paramdef>
   <paramdef> <parameter>...</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>__driver</parameter></term>
   <listitem>
    <para>
     driver name
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>__register</parameter></term>
   <listitem>
    <para>
     register function for this driver type
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>__unregister</parameter></term>
   <listitem>
    <para>
     unregister function for this driver type
     @...: Additional arguments to be passed to __register and __unregister.
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>...</parameter></term>
   <listitem>
    <para>
     variable arguments
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
<title>Description</title>
<para>
   Use this macro to construct bus specific macros for registering
   drivers, and do not use it on its own.
</para>
</refsect1>
</refentry>

     </sect1>
     <sect1><title>Device Drivers Base</title>
<!-- drivers/base/init.c -->
<refentry id="API-driver-init">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>July 2015</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>driver_init</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.4.104</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>driver_init</refname>
 <refpurpose>
  initialize driver model.
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>void <function>driver_init </function></funcdef>
   <paramdef> <parameter>void</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>void</parameter></term>
   <listitem>
    <para>
     no arguments
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
<title>Description</title>
<para>
   </para><para>

   Call the driver model init functions to initialize their
   subsystems. Called early from init/main.c.
</para>
</refsect1>
</refentry>

<!-- drivers/base/driver.c -->
<refentry id="API-driver-for-each-device">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>July 2015</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>driver_for_each_device</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.4.104</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>driver_for_each_device</refname>
 <refpurpose>
  Iterator for devices bound to a driver.
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>int <function>driver_for_each_device </function></funcdef>
   <paramdef>struct device_driver * <parameter>drv</parameter></paramdef>
   <paramdef>struct device * <parameter>start</parameter></paramdef>
   <paramdef>void * <parameter>data</parameter></paramdef>
   <paramdef>int (*<parameter>fn</parameter>)
     <funcparams>struct device *, void *</funcparams></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>drv</parameter></term>
   <listitem>
    <para>
     Driver we're iterating.
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>start</parameter></term>
   <listitem>
    <para>
     Device to begin with
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>data</parameter></term>
   <listitem>
    <para>
     Data to pass to the callback.
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>fn</parameter></term>
   <listitem>
    <para>
     Function to call for each device.
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
<title>Description</title>
<para>
   Iterate over the <parameter>drv</parameter>'s list of devices calling <parameter>fn</parameter> for each one.
</para>
</refsect1>
</refentry>

<refentry id="API-driver-find-device">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>July 2015</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>driver_find_device</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.4.104</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>driver_find_device</refname>
 <refpurpose>
     device iterator for locating a particular device.
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>struct device * <function>driver_find_device </function></funcdef>
   <paramdef>struct device_driver * <parameter>drv</parameter></paramdef>
   <paramdef>struct device * <parameter>start</parameter></paramdef>
   <paramdef>void * <parameter>data</parameter></paramdef>
   <paramdef>int (*<parameter>match</parameter>)
     <funcparams>struct device *dev, void *data</funcparams></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>drv</parameter></term>
   <listitem>
    <para>
     The device's driver
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>start</parameter></term>
   <listitem>
    <para>
     Device to begin with
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>data</parameter></term>
   <listitem>
    <para>
     Data to pass to match function
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>match</parameter></term>
   <listitem>
    <para>
     Callback function to check device
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
<title>Description</title>
<para>
   This is similar to the <function>driver_for_each_device</function> function above, but
   it returns a reference to a device that is 'found' for later use, as
   determined by the <parameter>match</parameter> callback.
   </para><para>

   The callback should return 0 if the device doesn't match and non-zero
   if it does.  If the callback returns non-zero, this function will
   return to the caller and not iterate over any more devices.
</para>
</refsect1>
</refentry>

<refentry id="API-driver-create-file">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>July 2015</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>driver_create_file</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.4.104</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>driver_create_file</refname>
 <refpurpose>
     create sysfs file for driver.
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>int <function>driver_create_file </function></funcdef>
   <paramdef>struct device_driver * <parameter>drv</parameter></paramdef>
   <paramdef>const struct driver_attribute * <parameter>attr</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>drv</parameter></term>
   <listitem>
    <para>
     driver.
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>attr</parameter></term>
   <listitem>
    <para>
     driver attribute descriptor.
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
</refentry>

<refentry id="API-driver-remove-file">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>July 2015</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>driver_remove_file</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.4.104</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>driver_remove_file</refname>
 <refpurpose>
     remove sysfs file for driver.
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>void <function>driver_remove_file </function></funcdef>
   <paramdef>struct device_driver * <parameter>drv</parameter></paramdef>
   <paramdef>const struct driver_attribute * <parameter>attr</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>drv</parameter></term>
   <listitem>
    <para>
     driver.
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>attr</parameter></term>
   <listitem>
    <para>
     driver attribute descriptor.
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
</refentry>

<refentry id="API-driver-register">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>July 2015</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>driver_register</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.4.104</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>driver_register</refname>
 <refpurpose>
     register driver with bus
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>int <function>driver_register </function></funcdef>
   <paramdef>struct device_driver * <parameter>drv</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>drv</parameter></term>
   <listitem>
    <para>
     driver to register
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
<title>Description</title>
<para>
   We pass off most of the work to the <function>bus_add_driver</function> call,
   since most of the things we have to do deal with the bus
   structures.
</para>
</refsect1>
</refentry>

<refentry id="API-driver-unregister">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>July 2015</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>driver_unregister</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.4.104</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>driver_unregister</refname>
 <refpurpose>
     remove driver from system.
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>void <function>driver_unregister </function></funcdef>
   <paramdef>struct device_driver * <parameter>drv</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>drv</parameter></term>
   <listitem>
    <para>
     driver.
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
<title>Description</title>
<para>
   Again, we pass off most of the work to the bus-level call.
</para>
</refsect1>
</refentry>

<refentry id="API-driver-find">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>July 2015</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>driver_find</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.4.104</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>driver_find</refname>
 <refpurpose>
     locate driver on a bus by its name.
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>struct device_driver * <function>driver_find </function></funcdef>
   <paramdef>const char * <parameter>name</parameter></paramdef>
   <paramdef>struct bus_type * <parameter>bus</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>name</parameter></term>
   <listitem>
    <para>
     name of the driver.
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>bus</parameter></term>
   <listitem>
    <para>
     bus to scan for the driver.
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
<title>Description</title>
<para>
   Call <function>kset_find_obj</function> to iterate over list of drivers on
   a bus to find driver by name. Return driver if found.
   </para><para>

   This routine provides no locking to prevent the driver it returns
   from being unregistered or unloaded while the caller is using it.
   The caller is responsible for preventing this.
</para>
</refsect1>
</refentry>

<!-- drivers/base/core.c -->
<refentry id="API-dev-driver-string">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>July 2015</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>dev_driver_string</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.4.104</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>dev_driver_string</refname>
 <refpurpose>
  Return a device's driver name, if at all possible
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>const char * <function>dev_driver_string </function></funcdef>
   <paramdef>const struct device * <parameter>dev</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>dev</parameter></term>
   <listitem>
    <para>
     struct device to get the name of
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
<title>Description</title>
<para>
   Will return the device's driver's name if it is bound to a device.  If
   the device is not bound to a device, it will return the name of the bus
   it is attached to.  If it is not attached to a bus either, an empty
   string will be returned.
</para>
</refsect1>
</refentry>

<refentry id="API-device-create-file">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>July 2015</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>device_create_file</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.4.104</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>device_create_file</refname>
 <refpurpose>
     create sysfs attribute file for device.
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>int <function>device_create_file </function></funcdef>
   <paramdef>struct device * <parameter>dev</parameter></paramdef>
   <paramdef>const struct device_attribute * <parameter>attr</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>dev</parameter></term>
   <listitem>
    <para>
     device.
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>attr</parameter></term>
   <listitem>
    <para>
     device attribute descriptor.
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
</refentry>

<refentry id="API-device-remove-file">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>July 2015</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>device_remove_file</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.4.104</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>device_remove_file</refname>
 <refpurpose>
     remove sysfs attribute file.
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>void <function>device_remove_file </function></funcdef>
   <paramdef>struct device * <parameter>dev</parameter></paramdef>
   <paramdef>const struct device_attribute * <parameter>attr</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>dev</parameter></term>
   <listitem>
    <para>
     device.
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>attr</parameter></term>
   <listitem>
    <para>
     device attribute descriptor.
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
</refentry>

<refentry id="API-device-create-bin-file">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>July 2015</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>device_create_bin_file</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.4.104</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>device_create_bin_file</refname>
 <refpurpose>
     create sysfs binary attribute file for device.
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>int <function>device_create_bin_file </function></funcdef>
   <paramdef>struct device * <parameter>dev</parameter></paramdef>
   <paramdef>const struct bin_attribute * <parameter>attr</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>dev</parameter></term>
   <listitem>
    <para>
     device.
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>attr</parameter></term>
   <listitem>
    <para>
     device binary attribute descriptor.
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
</refentry>

<refentry id="API-device-remove-bin-file">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>July 2015</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>device_remove_bin_file</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.4.104</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>device_remove_bin_file</refname>
 <refpurpose>
     remove sysfs binary attribute file
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>void <function>device_remove_bin_file </function></funcdef>
   <paramdef>struct device * <parameter>dev</parameter></paramdef>
   <paramdef>const struct bin_attribute * <parameter>attr</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>dev</parameter></term>
   <listitem>
    <para>
     device.
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>attr</parameter></term>
   <listitem>
    <para>
     device binary attribute descriptor.
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
</refentry>

<refentry id="API-device-schedule-callback-owner">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>July 2015</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>device_schedule_callback_owner</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.4.104</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>device_schedule_callback_owner</refname>
 <refpurpose>
     helper to schedule a callback for a device
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>int <function>device_schedule_callback_owner </function></funcdef>
   <paramdef>struct device * <parameter>dev</parameter></paramdef>
   <paramdef>void (*<parameter>func</parameter>)
     <funcparams>struct device *</funcparams></paramdef>
   <paramdef>struct module * <parameter>owner</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>dev</parameter></term>
   <listitem>
    <para>
     device.
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>func</parameter></term>
   <listitem>
    <para>
     callback function to invoke later.
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>owner</parameter></term>
   <listitem>
    <para>
     module owning the callback routine
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
<title>Description</title>
<para>
   Attribute methods must not unregister themselves or their parent device
   (which would amount to the same thing).  Attempts to do so will deadlock,
   since unregistration is mutually exclusive with driver callbacks.
   </para><para>

   Instead methods can call this routine, which will attempt to allocate
   and schedule a workqueue request to call back <parameter>func</parameter> with <parameter>dev</parameter> as its
   argument in the workqueue's process context.  <parameter>dev</parameter> will be pinned until
   <parameter>func</parameter> returns.
   </para><para>

   This routine is usually called via the inline <function>device_schedule_callback</function>,
   which automatically sets <parameter>owner</parameter> to THIS_MODULE.
   </para><para>

   Returns 0 if the request was submitted, -ENOMEM if storage could not
   be allocated, -ENODEV if a reference to <parameter>owner</parameter> isn't available.
</para>
</refsect1>
<refsect1>
<title>NOTE</title>
<para>
   This routine won't work if CONFIG_SYSFS isn't set!  It uses an
   underlying sysfs routine (since it is intended for use by attribute
   methods), and if sysfs isn't available you'll get nothing but -ENOSYS.
</para>
</refsect1>
</refentry>

<refentry id="API-device-initialize">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>July 2015</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>device_initialize</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.4.104</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>device_initialize</refname>
 <refpurpose>
     init device structure.
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>void <function>device_initialize </function></funcdef>
   <paramdef>struct device * <parameter>dev</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>dev</parameter></term>
   <listitem>
    <para>
     device.
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
<title>Description</title>
<para>
   This prepares the device for use by other layers by initializing
   its fields.
   It is the first half of <function>device_register</function>, if called by
   that function, though it can also be called separately, so one
   may use <parameter>dev</parameter>'s fields. In particular, <function>get_device</function>/<function>put_device</function>
   may be used for reference counting of <parameter>dev</parameter> after calling this
   function.
   </para><para>

   All fields in <parameter>dev</parameter> must be initialized by the caller to 0, except
   for those explicitly set to some other value.  The simplest
   approach is to use <function>kzalloc</function> to allocate the structure containing
   <parameter>dev</parameter>.
</para>
</refsect1>
<refsect1>
<title>NOTE</title>
<para>
   Use <function>put_device</function> to give up your reference instead of freeing
   <parameter>dev</parameter> directly once you have called this function.
</para>
</refsect1>
</refentry>

<refentry id="API-dev-set-name">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>July 2015</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>dev_set_name</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.4.104</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>dev_set_name</refname>
 <refpurpose>
     set a device name
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>int <function>dev_set_name </function></funcdef>
   <paramdef>struct device * <parameter>dev</parameter></paramdef>
   <paramdef>const char * <parameter>fmt</parameter></paramdef>
   <paramdef> <parameter>...</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>dev</parameter></term>
   <listitem>
    <para>
     device
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>fmt</parameter></term>
   <listitem>
    <para>
     format string for the device's name
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>...</parameter></term>
   <listitem>
    <para>
     variable arguments
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
</refentry>

<refentry id="API-device-add">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>July 2015</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>device_add</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.4.104</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>device_add</refname>
 <refpurpose>
     add device to device hierarchy.
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>int <function>device_add </function></funcdef>
   <paramdef>struct device * <parameter>dev</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>dev</parameter></term>
   <listitem>
    <para>
     device.
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
<title>Description</title>
<para>
   This is part 2 of <function>device_register</function>, though may be called
   separately _iff_ <function>device_initialize</function> has been called separately.
   </para><para>

   This adds <parameter>dev</parameter> to the kobject hierarchy via <function>kobject_add</function>, adds it
   to the global and sibling lists for the device, then
   adds it to the other relevant subsystems of the driver model.
   </para><para>

   Do not call this routine or <function>device_register</function> more than once for
   any device structure.  The driver model core is not designed to work
   with devices that get unregistered and then spring back to life.
   (Among other things, it's very hard to guarantee that all references
   to the previous incarnation of <parameter>dev</parameter> have been dropped.)  Allocate
   and register a fresh new struct device instead.
</para>
</refsect1>
<refsect1>
<title>NOTE</title>
<para>
   _Never_ directly free <parameter>dev</parameter> after calling this function, even
   if it returned an error! Always use <function>put_device</function> to give up your
   reference instead.
</para>
</refsect1>
</refentry>

<refentry id="API-device-register">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>July 2015</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>device_register</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.4.104</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>device_register</refname>
 <refpurpose>
     register a device with the system.
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>int <function>device_register </function></funcdef>
   <paramdef>struct device * <parameter>dev</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>dev</parameter></term>
   <listitem>
    <para>
     pointer to the device structure
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
<title>Description</title>
<para>
   This happens in two clean steps - initialize the device
   and add it to the system. The two steps can be called
   separately, but this is the easiest and most common.
   I.e. you should only call the two helpers separately if
   have a clearly defined need to use and refcount the device
   before it is added to the hierarchy.
   </para><para>

   For more information, see the kerneldoc for <function>device_initialize</function>
   and <function>device_add</function>.
</para>
</refsect1>
<refsect1>
<title>NOTE</title>
<para>
   _Never_ directly free <parameter>dev</parameter> after calling this function, even
   if it returned an error! Always use <function>put_device</function> to give up the
   reference initialized in this function instead.
</para>
</refsect1>
</refentry>

<refentry id="API-get-device">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>July 2015</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>get_device</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.4.104</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>get_device</refname>
 <refpurpose>
     increment reference count for device.
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>struct device * <function>get_device </function></funcdef>
   <paramdef>struct device * <parameter>dev</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>dev</parameter></term>
   <listitem>
    <para>
     device.
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
<title>Description</title>
<para>
   This simply forwards the call to <function>kobject_get</function>, though
   we do take care to provide for the case that we get a NULL
   pointer passed in.
</para>
</refsect1>
</refentry>

<refentry id="API-put-device">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>July 2015</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>put_device</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.4.104</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>put_device</refname>
 <refpurpose>
     decrement reference count.
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>void <function>put_device </function></funcdef>
   <paramdef>struct device * <parameter>dev</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>dev</parameter></term>
   <listitem>
    <para>
     device in question.
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
</refentry>

<refentry id="API-device-del">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>July 2015</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>device_del</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.4.104</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>device_del</refname>
 <refpurpose>
     delete device from system.
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>void <function>device_del </function></funcdef>
   <paramdef>struct device * <parameter>dev</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>dev</parameter></term>
   <listitem>
    <para>
     device.
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
<title>Description</title>
<para>
   This is the first part of the device unregistration
   sequence. This removes the device from the lists we control
   from here, has it removed from the other driver model
   subsystems it was added to in <function>device_add</function>, and removes it
   from the kobject hierarchy.
</para>
</refsect1>
<refsect1>
<title>NOTE</title>
<para>
   this should be called manually _iff_ <function>device_add</function> was
   also called manually.
</para>
</refsect1>
</refentry>

<refentry id="API-device-unregister">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>July 2015</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>device_unregister</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.4.104</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>device_unregister</refname>
 <refpurpose>
     unregister device from system.
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>void <function>device_unregister </function></funcdef>
   <paramdef>struct device * <parameter>dev</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>dev</parameter></term>
   <listitem>
    <para>
     device going away.
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
<title>Description</title>
<para>
   We do this in two parts, like we do <function>device_register</function>. First,
   we remove it from all the subsystems with <function>device_del</function>, then
   we decrement the reference count via <function>put_device</function>. If that
   is the final reference count, the device will be cleaned up
   via <function>device_release</function> above. Otherwise, the structure will
   stick around until the final reference to the device is dropped.
</para>
</refsect1>
</refentry>

<refentry id="API-device-for-each-child">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>July 2015</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>device_for_each_child</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.4.104</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>device_for_each_child</refname>
 <refpurpose>
     device child iterator.
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>int <function>device_for_each_child </function></funcdef>
   <paramdef>struct device * <parameter>parent</parameter></paramdef>
   <paramdef>void * <parameter>data</parameter></paramdef>
   <paramdef>int (*<parameter>fn</parameter>)
     <funcparams>struct device *dev, void *data</funcparams></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>parent</parameter></term>
   <listitem>
    <para>
     parent struct device.
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>data</parameter></term>
   <listitem>
    <para>
     data for the callback.
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>fn</parameter></term>
   <listitem>
    <para>
     function to be called for each device.
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
<title>Description</title>
<para>
   Iterate over <parameter>parent</parameter>'s child devices, and call <parameter>fn</parameter> for each,
   passing it <parameter>data</parameter>.
   </para><para>

   We check the return of <parameter>fn</parameter> each time. If it returns anything
   other than 0, we break out and return that value.
</para>
</refsect1>
</refentry>

<refentry id="API-device-find-child">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>July 2015</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>device_find_child</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.4.104</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>device_find_child</refname>
 <refpurpose>
     device iterator for locating a particular device.
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>struct device * <function>device_find_child </function></funcdef>
   <paramdef>struct device * <parameter>parent</parameter></paramdef>
   <paramdef>void * <parameter>data</parameter></paramdef>
   <paramdef>int (*<parameter>match</parameter>)
     <funcparams>struct device *dev, void *data</funcparams></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>parent</parameter></term>
   <listitem>
    <para>
     parent struct device
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>data</parameter></term>
   <listitem>
    <para>
     Data to pass to match function
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>match</parameter></term>
   <listitem>
    <para>
     Callback function to check device
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
<title>Description</title>
<para>
   This is similar to the <function>device_for_each_child</function> function above, but it
   returns a reference to a device that is 'found' for later use, as
   determined by the <parameter>match</parameter> callback.
   </para><para>

   The callback should return 0 if the device doesn't match and non-zero
   if it does.  If the callback returns non-zero and a reference to the
   current device can be obtained, this function will return to the caller
   and not iterate over any more devices.
</para>
</refsect1>
</refentry>

<refentry id="API---root-device-register">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>July 2015</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>__root_device_register</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.4.104</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>__root_device_register</refname>
 <refpurpose>
     allocate and register a root device
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>struct device * <function>__root_device_register </function></funcdef>
   <paramdef>const char * <parameter>name</parameter></paramdef>
   <paramdef>struct module * <parameter>owner</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>name</parameter></term>
   <listitem>
    <para>
     root device name
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>owner</parameter></term>
   <listitem>
    <para>
     owner module of the root device, usually THIS_MODULE
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
<title>Description</title>
<para>
   This function allocates a root device and registers it
   using <function>device_register</function>. In order to free the returned
   device, use <function>root_device_unregister</function>.
   </para><para>

   Root devices are dummy devices which allow other devices
   to be grouped under /sys/devices. Use this function to
   allocate a root device and then use it as the parent of
   any device which should appear under /sys/devices/{name}
   </para><para>

   The /sys/devices/{name} directory will also contain a
   'module' symlink which points to the <parameter>owner</parameter> directory
   in sysfs.
   </para><para>

   Returns <structname>struct device</structname> pointer on success, or <function>ERR_PTR</function> on error.
</para>
</refsect1>
<refsect1>
<title>Note</title>
<para>
   You probably want to use <function>root_device_register</function>.
</para>
</refsect1>
</refentry>

<refentry id="API-root-device-unregister">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>July 2015</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>root_device_unregister</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.4.104</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>root_device_unregister</refname>
 <refpurpose>
     unregister and free a root device
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>void <function>root_device_unregister </function></funcdef>
   <paramdef>struct device * <parameter>dev</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>dev</parameter></term>
   <listitem>
    <para>
     device going away
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
<title>Description</title>
<para>
   This function unregisters and cleans up a device that was created by
   <function>root_device_register</function>.
</para>
</refsect1>
</refentry>

<refentry id="API-device-create-vargs">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>July 2015</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>device_create_vargs</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.4.104</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>device_create_vargs</refname>
 <refpurpose>
     creates a device and registers it with sysfs
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>struct device * <function>device_create_vargs </function></funcdef>
   <paramdef>struct class * <parameter>class</parameter></paramdef>
   <paramdef>struct device * <parameter>parent</parameter></paramdef>
   <paramdef>dev_t <parameter>devt</parameter></paramdef>
   <paramdef>void * <parameter>drvdata</parameter></paramdef>
   <paramdef>const char * <parameter>fmt</parameter></paramdef>
   <paramdef>va_list <parameter>args</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>class</parameter></term>
   <listitem>
    <para>
     pointer to the struct class that this device should be registered to
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>parent</parameter></term>
   <listitem>
    <para>
     pointer to the parent struct device of this new device, if any
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>devt</parameter></term>
   <listitem>
    <para>
     the dev_t for the char device to be added
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>drvdata</parameter></term>
   <listitem>
    <para>
     the data to be added to the device for callbacks
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>fmt</parameter></term>
   <listitem>
    <para>
     string for the device's name
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>args</parameter></term>
   <listitem>
    <para>
     va_list for the device's name
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
<title>Description</title>
<para>
   This function can be used by char device classes.  A struct device
   will be created in sysfs, registered to the specified class.
   </para><para>

   A <quote>dev</quote> file will be created, showing the dev_t for the device, if
   the dev_t is not 0,0.
   If a pointer to a parent struct device is passed in, the newly created
   struct device will be a child of that device in sysfs.
   The pointer to the struct device will be returned from the call.
   Any further sysfs files that might be required can be created using this
   pointer.
   </para><para>

   Returns <structname>struct device</structname> pointer on success, or <function>ERR_PTR</function> on error.
</para>
</refsect1>
<refsect1>
<title>Note</title>
<para>
   the struct class passed to this function must have previously
   been created with a call to <function>class_create</function>.
</para>
</refsect1>
</refentry>

<refentry id="API-device-create">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>July 2015</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>device_create</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.4.104</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>device_create</refname>
 <refpurpose>
     creates a device and registers it with sysfs
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>struct device * <function>device_create </function></funcdef>
   <paramdef>struct class * <parameter>class</parameter></paramdef>
   <paramdef>struct device * <parameter>parent</parameter></paramdef>
   <paramdef>dev_t <parameter>devt</parameter></paramdef>
   <paramdef>void * <parameter>drvdata</parameter></paramdef>
   <paramdef>const char * <parameter>fmt</parameter></paramdef>
   <paramdef> <parameter>...</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>class</parameter></term>
   <listitem>
    <para>
     pointer to the struct class that this device should be registered to
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>parent</parameter></term>
   <listitem>
    <para>
     pointer to the parent struct device of this new device, if any
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>devt</parameter></term>
   <listitem>
    <para>
     the dev_t for the char device to be added
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>drvdata</parameter></term>
   <listitem>
    <para>
     the data to be added to the device for callbacks
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>fmt</parameter></term>
   <listitem>
    <para>
     string for the device's name
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>...</parameter></term>
   <listitem>
    <para>
     variable arguments
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
<title>Description</title>
<para>
   This function can be used by char device classes.  A struct device
   will be created in sysfs, registered to the specified class.
   </para><para>

   A <quote>dev</quote> file will be created, showing the dev_t for the device, if
   the dev_t is not 0,0.
   If a pointer to a parent struct device is passed in, the newly created
   struct device will be a child of that device in sysfs.
   The pointer to the struct device will be returned from the call.
   Any further sysfs files that might be required can be created using this
   pointer.
   </para><para>

   Returns <structname>struct device</structname> pointer on success, or <function>ERR_PTR</function> on error.
</para>
</refsect1>
<refsect1>
<title>Note</title>
<para>
   the struct class passed to this function must have previously
   been created with a call to <function>class_create</function>.
</para>
</refsect1>
</refentry>

<refentry id="API-device-destroy">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>July 2015</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>device_destroy</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.4.104</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>device_destroy</refname>
 <refpurpose>
     removes a device that was created with <function>device_create</function>
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>void <function>device_destroy </function></funcdef>
   <paramdef>struct class * <parameter>class</parameter></paramdef>
   <paramdef>dev_t <parameter>devt</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>class</parameter></term>
   <listitem>
    <para>
     pointer to the struct class that this device was registered with
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>devt</parameter></term>
   <listitem>
    <para>
     the dev_t of the device that was previously registered
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
<title>Description</title>
<para>
   This call unregisters and cleans up a device that was created with a
   call to <function>device_create</function>.
</para>
</refsect1>
</refentry>

<refentry id="API-device-rename">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>July 2015</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>device_rename</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.4.104</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>device_rename</refname>
 <refpurpose>
     renames a device
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>int <function>device_rename </function></funcdef>
   <paramdef>struct device * <parameter>dev</parameter></paramdef>
   <paramdef>const char * <parameter>new_name</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>dev</parameter></term>
   <listitem>
    <para>
     the pointer to the struct device to be renamed
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>new_name</parameter></term>
   <listitem>
    <para>
     the new name of the device
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
<title>Description</title>
<para>
   It is the responsibility of the caller to provide mutual
   exclusion between two different calls of device_rename
   on the same device to ensure that new_name is valid and
   won't conflict with other devices.
</para>
</refsect1>
<refsect1>
<title>Note</title>
<para>
   Don't call this function.  Currently, the networking layer calls this
   function, but that will change.  The following text from Kay Sievers offers
</para>
</refsect1>
<refsect1>
<title>some insight</title>
<para>
   </para><para>

   Renaming devices is racy at many levels, symlinks and other stuff are not
   replaced atomically, and you get a <quote>move</quote> uevent, but it's not easy to
   connect the event to the old and new device. Device nodes are not renamed at
   all, there isn't even support for that in the kernel now.
   </para><para>

   In the meantime, during renaming, your target name might be taken by another
   driver, creating conflicts. Or the old name is taken directly after you
   renamed it -- then you get events for the same DEVPATH, before you even see
   the <quote>move</quote> event. It's just a mess, and nothing new should ever rely on
   kernel device renaming. Besides that, it's not even implemented now for
   other things than (driver-core wise very simple) network devices.
   </para><para>

   We are currently about to change network renaming in udev to completely
   disallow renaming of devices in the same namespace as the kernel uses,
   because we can't solve the problems properly, that arise with swapping names
   of multiple interfaces without races. Means, renaming of eth[0-9]* will only
   be allowed to some other name than eth[0-9]*, for the aforementioned
   reasons.
   </para><para>

   Make up a <quote>real</quote> name in the driver before you register anything, or add
   some other attributes for userspace to find the device, or use udev to add
   symlinks -- but never rename kernel devices later, it's a complete mess. We
   don't even want to get into that and try to implement the missing pieces in
   the core. We really have other pieces to fix in the driver core mess. :)
</para>
</refsect1>
</refentry>

<refentry id="API-device-move">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>July 2015</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>device_move</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.4.104</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>device_move</refname>
 <refpurpose>
     moves a device to a new parent
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>int <function>device_move </function></funcdef>
   <paramdef>struct device * <parameter>dev</parameter></paramdef>
   <paramdef>struct device * <parameter>new_parent</parameter></paramdef>
   <paramdef>enum dpm_order <parameter>dpm_order</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>dev</parameter></term>
   <listitem>
    <para>
     the pointer to the struct device to be moved
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>new_parent</parameter></term>
   <listitem>
    <para>
     the new parent of the device (can by NULL)
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>dpm_order</parameter></term>
   <listitem>
    <para>
     how to reorder the dpm_list
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
</refentry>

<!-- drivers/base/syscore.c -->
<refentry id="API-register-syscore-ops">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>July 2015</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>register_syscore_ops</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.4.104</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>register_syscore_ops</refname>
 <refpurpose>
  Register a set of system core operations.
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>void <function>register_syscore_ops </function></funcdef>
   <paramdef>struct syscore_ops * <parameter>ops</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>ops</parameter></term>
   <listitem>
    <para>
     System core operations to register.
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
</refentry>

<refentry id="API-unregister-syscore-ops">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>July 2015</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>unregister_syscore_ops</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.4.104</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>unregister_syscore_ops</refname>
 <refpurpose>
     Unregister a set of system core operations.
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>void <function>unregister_syscore_ops </function></funcdef>
   <paramdef>struct syscore_ops * <parameter>ops</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>ops</parameter></term>
   <listitem>
    <para>
     System core operations to unregister.
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
</refentry>

<refentry id="API-syscore-suspend">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>July 2015</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>syscore_suspend</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.4.104</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>syscore_suspend</refname>
 <refpurpose>
     Execute all the registered system core suspend callbacks.
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>int <function>syscore_suspend </function></funcdef>
   <paramdef> <parameter>void</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>void</parameter></term>
   <listitem>
    <para>
     no arguments
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
<title>Description</title>
<para>
   </para><para>

   This function is executed with one CPU on-line and disabled interrupts.
</para>
</refsect1>
</refentry>

<refentry id="API-syscore-resume">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>July 2015</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>syscore_resume</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.4.104</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>syscore_resume</refname>
 <refpurpose>
     Execute all the registered system core resume callbacks.
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>void <function>syscore_resume </function></funcdef>
   <paramdef> <parameter>void</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>void</parameter></term>
   <listitem>
    <para>
     no arguments
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
<title>Description</title>
<para>
   </para><para>

   This function is executed with one CPU on-line and disabled interrupts.
</para>
</refsect1>
</refentry>

<!-- drivers/base/class.c -->
<refentry id="API---class-create">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>July 2015</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>__class_create</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.4.104</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>__class_create</refname>
 <refpurpose>
  create a struct class structure
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>struct class * <function>__class_create </function></funcdef>
   <paramdef>struct module * <parameter>owner</parameter></paramdef>
   <paramdef>const char * <parameter>name</parameter></paramdef>
   <paramdef>struct lock_class_key * <parameter>key</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>owner</parameter></term>
   <listitem>
    <para>
     pointer to the module that is to <quote>own</quote> this struct class
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>name</parameter></term>
   <listitem>
    <para>
     pointer to a string for the name of this class.
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>key</parameter></term>
   <listitem>
    <para>
     the lock_class_key for this class; used by mutex lock debugging
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
<title>Description</title>
<para>
   This is used to create a struct class pointer that can then be used
   in calls to <function>device_create</function>.
   </para><para>

   Returns <structname>struct class</structname> pointer on success, or <function>ERR_PTR</function> on error.
   </para><para>

   Note, the pointer created here is to be destroyed when finished by
   making a call to <function>class_destroy</function>.
</para>
</refsect1>
</refentry>

<refentry id="API-class-destroy">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>July 2015</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>class_destroy</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.4.104</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>class_destroy</refname>
 <refpurpose>
     destroys a struct class structure
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>void <function>class_destroy </function></funcdef>
   <paramdef>struct class * <parameter>cls</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>cls</parameter></term>
   <listitem>
    <para>
     pointer to the struct class that is to be destroyed
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
<title>Description</title>
<para>
   Note, the pointer to be destroyed must have been created with a call
   to <function>class_create</function>.
</para>
</refsect1>
</refentry>

<refentry id="API-class-dev-iter-init">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>July 2015</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>class_dev_iter_init</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.4.104</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>class_dev_iter_init</refname>
 <refpurpose>
     initialize class device iterator
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>void <function>class_dev_iter_init </function></funcdef>
   <paramdef>struct class_dev_iter * <parameter>iter</parameter></paramdef>
   <paramdef>struct class * <parameter>class</parameter></paramdef>
   <paramdef>struct device * <parameter>start</parameter></paramdef>
   <paramdef>const struct device_type * <parameter>type</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>iter</parameter></term>
   <listitem>
    <para>
     class iterator to initialize
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>class</parameter></term>
   <listitem>
    <para>
     the class we wanna iterate over
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>start</parameter></term>
   <listitem>
    <para>
     the device to start iterating from, if any
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>type</parameter></term>
   <listitem>
    <para>
     device_type of the devices to iterate over, NULL for all
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
<title>Description</title>
<para>
   Initialize class iterator <parameter>iter</parameter> such that it iterates over devices
   of <parameter>class</parameter>.  If <parameter>start</parameter> is set, the list iteration will start there,
   otherwise if it is NULL, the iteration starts at the beginning of
   the list.
</para>
</refsect1>
</refentry>

<refentry id="API-class-dev-iter-next">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>July 2015</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>class_dev_iter_next</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.4.104</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>class_dev_iter_next</refname>
 <refpurpose>
     iterate to the next device
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>struct device * <function>class_dev_iter_next </function></funcdef>
   <paramdef>struct class_dev_iter * <parameter>iter</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>iter</parameter></term>
   <listitem>
    <para>
     class iterator to proceed
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
<title>Description</title>
<para>
   Proceed <parameter>iter</parameter> to the next device and return it.  Returns NULL if
   iteration is complete.
   </para><para>

   The returned device is referenced and won't be released till
   iterator is proceed to the next device or exited.  The caller is
   free to do whatever it wants to do with the device including
   calling back into class code.
</para>
</refsect1>
</refentry>

<refentry id="API-class-dev-iter-exit">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>July 2015</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>class_dev_iter_exit</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.4.104</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>class_dev_iter_exit</refname>
 <refpurpose>
     finish iteration
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>void <function>class_dev_iter_exit </function></funcdef>
   <paramdef>struct class_dev_iter * <parameter>iter</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>iter</parameter></term>
   <listitem>
    <para>
     class iterator to finish
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
<title>Description</title>
<para>
   Finish an iteration.  Always call this function after iteration is
   complete whether the iteration ran till the end or not.
</para>
</refsect1>
</refentry>

<refentry id="API-class-for-each-device">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>July 2015</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>class_for_each_device</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.4.104</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>class_for_each_device</refname>
 <refpurpose>
     device iterator
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>int <function>class_for_each_device </function></funcdef>
   <paramdef>struct class * <parameter>class</parameter></paramdef>
   <paramdef>struct device * <parameter>start</parameter></paramdef>
   <paramdef>void * <parameter>data</parameter></paramdef>
   <paramdef>int (*<parameter>fn</parameter>)
     <funcparams>struct device *, void *</funcparams></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>class</parameter></term>
   <listitem>
    <para>
     the class we're iterating
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>start</parameter></term>
   <listitem>
    <para>
     the device to start with in the list, if any.
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>data</parameter></term>
   <listitem>
    <para>
     data for the callback
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>fn</parameter></term>
   <listitem>
    <para>
     function to be called for each device
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
<title>Description</title>
<para>
   Iterate over <parameter>class</parameter>'s list of devices, and call <parameter>fn</parameter> for each,
   passing it <parameter>data</parameter>.  If <parameter>start</parameter> is set, the list iteration will start
   there, otherwise if it is NULL, the iteration starts at the
   beginning of the list.
   </para><para>

   We check the return of <parameter>fn</parameter> each time. If it returns anything
   other than 0, we break out and return that value.
   </para><para>

   <parameter>fn</parameter> is allowed to do anything including calling back into class
   code.  There's no locking restriction.
</para>
</refsect1>
</refentry>

<refentry id="API-class-find-device">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>July 2015</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>class_find_device</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.4.104</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>class_find_device</refname>
 <refpurpose>
     device iterator for locating a particular device
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>struct device * <function>class_find_device </function></funcdef>
   <paramdef>struct class * <parameter>class</parameter></paramdef>
   <paramdef>struct device * <parameter>start</parameter></paramdef>
   <paramdef>void * <parameter>data</parameter></paramdef>
   <paramdef>int (*<parameter>match</parameter>)
     <funcparams>struct device *, void *</funcparams></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>class</parameter></term>
   <listitem>
    <para>
     the class we're iterating
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>start</parameter></term>
   <listitem>
    <para>
     Device to begin with
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>data</parameter></term>
   <listitem>
    <para>
     data for the match function
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>match</parameter></term>
   <listitem>
    <para>
     function to check device
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
<title>Description</title>
<para>
   This is similar to the <function>class_for_each_dev</function> function above, but it
   returns a reference to a device that is 'found' for later use, as
   determined by the <parameter>match</parameter> callback.
   </para><para>

   The callback should return 0 if the device doesn't match and non-zero
   if it does.  If the callback returns non-zero, this function will
   return to the caller and not iterate over any more devices.
   </para><para>

   Note, you will need to drop the reference with <function>put_device</function> after use.
   </para><para>

   <parameter>fn</parameter> is allowed to do anything including calling back into class
   code.  There's no locking restriction.
</para>
</refsect1>
</refentry>

<refentry id="API-class-compat-register">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>July 2015</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>class_compat_register</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.4.104</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>class_compat_register</refname>
 <refpurpose>
     register a compatibility class
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>struct class_compat * <function>class_compat_register </function></funcdef>
   <paramdef>const char * <parameter>name</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>name</parameter></term>
   <listitem>
    <para>
     the name of the class
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
<title>Description</title>
<para>
   Compatibility class are meant as a temporary user-space compatibility
   workaround when converting a family of class devices to a bus devices.
</para>
</refsect1>
</refentry>

<refentry id="API-class-compat-unregister">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>July 2015</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>class_compat_unregister</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.4.104</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>class_compat_unregister</refname>
 <refpurpose>
     unregister a compatibility class
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>void <function>class_compat_unregister </function></funcdef>
   <paramdef>struct class_compat * <parameter>cls</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>cls</parameter></term>
   <listitem>
    <para>
     the class to unregister
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
</refentry>

<refentry id="API-class-compat-create-link">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>July 2015</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>class_compat_create_link</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.4.104</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>class_compat_create_link</refname>
 <refpurpose>
     create a compatibility class device link to a bus device
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>int <function>class_compat_create_link </function></funcdef>
   <paramdef>struct class_compat * <parameter>cls</parameter></paramdef>
   <paramdef>struct device * <parameter>dev</parameter></paramdef>
   <paramdef>struct device * <parameter>device_link</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>cls</parameter></term>
   <listitem>
    <para>
     the compatibility class
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>dev</parameter></term>
   <listitem>
    <para>
     the target bus device
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>device_link</parameter></term>
   <listitem>
    <para>
     an optional device to which a <quote>device</quote> link should be created
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
</refentry>

<refentry id="API-class-compat-remove-link">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>July 2015</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>class_compat_remove_link</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.4.104</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>class_compat_remove_link</refname>
 <refpurpose>
     remove a compatibility class device link to a bus device
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>void <function>class_compat_remove_link </function></funcdef>
   <paramdef>struct class_compat * <parameter>cls</parameter></paramdef>
   <paramdef>struct device * <parameter>dev</parameter></paramdef>
   <paramdef>struct device * <parameter>device_link</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>cls</parameter></term>
   <listitem>
    <para>
     the compatibility class
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>dev</parameter></term>
   <listitem>
    <para>
     the target bus device
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>device_link</parameter></term>
   <listitem>
    <para>
     an optional device to which a <quote>device</quote> link was previously
     created
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
</refentry>

<!-- drivers/base/node.c -->
<refentry id="API-unregister-node">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>July 2015</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>unregister_node</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.4.104</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>unregister_node</refname>
 <refpurpose>
  unregister a node device
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>void <function>unregister_node </function></funcdef>
   <paramdef>struct node * <parameter>node</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>node</parameter></term>
   <listitem>
    <para>
     node going away
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
<title>Description</title>
<para>
   Unregisters a node device <parameter>node</parameter>.  All the devices on the node must be
   unregistered before calling this function.
</para>
</refsect1>
</refentry>

<!-- drivers/base/firmware_class.c -->
<refentry id="API-request-firmware">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>July 2015</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>request_firmware</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.4.104</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>request_firmware</refname>
 <refpurpose>
  send firmware request and wait for it
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>int <function>request_firmware </function></funcdef>
   <paramdef>const struct firmware ** <parameter>firmware_p</parameter></paramdef>
   <paramdef>const char * <parameter>name</parameter></paramdef>
   <paramdef>struct device * <parameter>device</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>firmware_p</parameter></term>
   <listitem>
    <para>
     pointer to firmware image
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>name</parameter></term>
   <listitem>
    <para>
     name of firmware file
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>device</parameter></term>
   <listitem>
    <para>
     device for which firmware is being loaded
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
<title>Description</title>
<para>
   <parameter>firmware_p</parameter> will be used to return a firmware image by the name
   of <parameter>name</parameter> for device <parameter>device</parameter>.
   </para><para>

   Should be called from user context where sleeping is allowed.
   </para><para>

   <parameter>name</parameter> will be used as <envar>$FIRMWARE</envar> in the uevent environment and
   should be distinctive enough not to be confused with any other
   firmware image for this or any other device.
</para>
</refsect1>
</refentry>

<refentry id="API-release-firmware">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>July 2015</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>release_firmware</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.4.104</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>release_firmware</refname>
 <refpurpose>
     release the resource associated with a firmware image
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>void <function>release_firmware </function></funcdef>
   <paramdef>const struct firmware * <parameter>fw</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>fw</parameter></term>
   <listitem>
    <para>
     firmware resource to release
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
</refentry>

<refentry id="API-request-firmware-nowait">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>July 2015</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>request_firmware_nowait</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.4.104</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>request_firmware_nowait</refname>
 <refpurpose>
     asynchronous version of request_firmware
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>int <function>request_firmware_nowait </function></funcdef>
   <paramdef>struct module * <parameter>module</parameter></paramdef>
   <paramdef>bool <parameter>uevent</parameter></paramdef>
   <paramdef>const char * <parameter>name</parameter></paramdef>
   <paramdef>struct device * <parameter>device</parameter></paramdef>
   <paramdef>gfp_t <parameter>gfp</parameter></paramdef>
   <paramdef>void * <parameter>context</parameter></paramdef>
   <paramdef>void (*<parameter>cont</parameter>)
     <funcparams>const struct firmware *fw, void *context</funcparams></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>module</parameter></term>
   <listitem>
    <para>
     module requesting the firmware
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>uevent</parameter></term>
   <listitem>
    <para>
     sends uevent to copy the firmware image if this flag
     is non-zero else the firmware copy must be done manually.
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>name</parameter></term>
   <listitem>
    <para>
     name of firmware file
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>device</parameter></term>
   <listitem>
    <para>
     device for which firmware is being loaded
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>gfp</parameter></term>
   <listitem>
    <para>
     allocation flags
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>context</parameter></term>
   <listitem>
    <para>
     will be passed over to <parameter>cont</parameter>, and
     <parameter>fw</parameter> may be <constant>NULL</constant> if firmware request fails.
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>cont</parameter></term>
   <listitem>
    <para>
     function will be called asynchronously when the firmware
     request is over.
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
<title>Description</title>
<para>
   Asynchronous variant of <function>request_firmware</function> for user contexts where
   it is not possible to sleep for long time. It can't be called
   in atomic contexts.
</para>
</refsect1>
</refentry>

<!-- drivers/base/transport_class.c -->
<refentry id="API-transport-class-register">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>July 2015</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>transport_class_register</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.4.104</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>transport_class_register</refname>
 <refpurpose>
  register an initial transport class
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>int <function>transport_class_register </function></funcdef>
   <paramdef>struct transport_class * <parameter>tclass</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>tclass</parameter></term>
   <listitem>
    <para>
     a pointer to the transport class structure to be initialised
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
<title>Description</title>
<para>
   The transport class contains an embedded class which is used to
   identify it.  The caller should initialise this structure with
   zeros and then generic class must have been initialised with the
   actual transport class unique name.  There's a macro
   <function>DECLARE_TRANSPORT_CLASS</function> to do this (declared classes still must
   be registered).
   </para><para>

   Returns 0 on success or error on failure.
</para>
</refsect1>
</refentry>

<refentry id="API-transport-class-unregister">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>July 2015</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>transport_class_unregister</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.4.104</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>transport_class_unregister</refname>
 <refpurpose>
     unregister a previously registered class
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>void <function>transport_class_unregister </function></funcdef>
   <paramdef>struct transport_class * <parameter>tclass</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>tclass</parameter></term>
   <listitem>
    <para>
     The transport class to unregister
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
<title>Description</title>
<para>
   Must be called prior to deallocating the memory for the transport
   class.
</para>
</refsect1>
</refentry>

<refentry id="API-anon-transport-class-register">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>July 2015</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>anon_transport_class_register</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.4.104</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>anon_transport_class_register</refname>
 <refpurpose>
     register an anonymous class
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>int <function>anon_transport_class_register </function></funcdef>
   <paramdef>struct anon_transport_class * <parameter>atc</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>atc</parameter></term>
   <listitem>
    <para>
     The anon transport class to register
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
<title>Description</title>
<para>
   The anonymous transport class contains both a transport class and a
   container.  The idea of an anonymous class is that it never
   actually has any device attributes associated with it (and thus
   saves on container storage).  So it can only be used for triggering
   events.  Use prezero and then use <function>DECLARE_ANON_TRANSPORT_CLASS</function> to
   initialise the anon transport class storage.
</para>
</refsect1>
</refentry>

<refentry id="API-anon-transport-class-unregister">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>July 2015</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>anon_transport_class_unregister</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.4.104</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>anon_transport_class_unregister</refname>
 <refpurpose>
     unregister an anon class
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>void <function>anon_transport_class_unregister </function></funcdef>
   <paramdef>struct anon_transport_class * <parameter>atc</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>atc</parameter></term>
   <listitem>
    <para>
     Pointer to the anon transport class to unregister
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
<title>Description</title>
<para>
   Must be called prior to deallocating the memory for the anon
   transport class.
</para>
</refsect1>
</refentry>

<refentry id="API-transport-setup-device">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>July 2015</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>transport_setup_device</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.4.104</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>transport_setup_device</refname>
 <refpurpose>
     declare a new dev for transport class association but don't make it visible yet.
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>void <function>transport_setup_device </function></funcdef>
   <paramdef>struct device * <parameter>dev</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>dev</parameter></term>
   <listitem>
    <para>
     the generic device representing the entity being added
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
<title>Description</title>
<para>
   Usually, dev represents some component in the HBA system (either
   the HBA itself or a device remote across the HBA bus).  This
   routine is simply a trigger point to see if any set of transport
   classes wishes to associate with the added device.  This allocates
   storage for the class device and initialises it, but does not yet
   add it to the system or add attributes to it (you do this with
   transport_add_device).  If you have no need for a separate setup
   and add operations, use transport_register_device (see
   transport_class.h).
</para>
</refsect1>
</refentry>

<refentry id="API-transport-add-device">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>July 2015</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>transport_add_device</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.4.104</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>transport_add_device</refname>
 <refpurpose>
     declare a new dev for transport class association
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>void <function>transport_add_device </function></funcdef>
   <paramdef>struct device * <parameter>dev</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>dev</parameter></term>
   <listitem>
    <para>
     the generic device representing the entity being added
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
<title>Description</title>
<para>
   Usually, dev represents some component in the HBA system (either
   the HBA itself or a device remote across the HBA bus).  This
   routine is simply a trigger point used to add the device to the
   system and register attributes for it.
</para>
</refsect1>
</refentry>

<refentry id="API-transport-configure-device">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>July 2015</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>transport_configure_device</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.4.104</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>transport_configure_device</refname>
 <refpurpose>
     configure an already set up device
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>void <function>transport_configure_device </function></funcdef>
   <paramdef>struct device * <parameter>dev</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>dev</parameter></term>
   <listitem>
    <para>
     generic device representing device to be configured
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
<title>Description</title>
<para>
   The idea of configure is simply to provide a point within the setup
   process to allow the transport class to extract information from a
   device after it has been setup.  This is used in SCSI because we
   have to have a setup device to begin using the HBA, but after we
   send the initial inquiry, we use configure to extract the device
   parameters.  The device need not have been added to be configured.
</para>
</refsect1>
</refentry>

<refentry id="API-transport-remove-device">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>July 2015</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>transport_remove_device</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.4.104</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>transport_remove_device</refname>
 <refpurpose>
     remove the visibility of a device
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>void <function>transport_remove_device </function></funcdef>
   <paramdef>struct device * <parameter>dev</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>dev</parameter></term>
   <listitem>
    <para>
     generic device to remove
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
<title>Description</title>
<para>
   This call removes the visibility of the device (to the user from
   sysfs), but does not destroy it.  To eliminate a device entirely
   you must also call transport_destroy_device.  If you don't need to
   do remove and destroy as separate operations, use
   <function>transport_unregister_device</function> (see transport_class.h) which will
   perform both calls for you.
</para>
</refsect1>
</refentry>

<refentry id="API-transport-destroy-device">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>July 2015</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>transport_destroy_device</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.4.104</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>transport_destroy_device</refname>
 <refpurpose>
     destroy a removed device
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>void <function>transport_destroy_device </function></funcdef>
   <paramdef>struct device * <parameter>dev</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>dev</parameter></term>
   <listitem>
    <para>
     device to eliminate from the transport class.
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
<title>Description</title>
<para>
   This call triggers the elimination of storage associated with the
   transport classdev.  Note: all it really does is relinquish a
   reference to the classdev.  The memory will not be freed until the
   last reference goes to zero.  Note also that the classdev retains a
   reference count on dev, so dev too will remain for as long as the
   transport class device remains around.
</para>
</refsect1>
</refentry>

<!-- Cannot be included, because
     attribute_container_add_class_device_adapter
 and attribute_container_classdev_to_container
     exceed allowed 44 characters maximum
X!Edrivers/base/attribute_container.c
-->
<!-- drivers/base/dd.c -->
<refentry id="API-device-bind-driver">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>July 2015</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>device_bind_driver</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.4.104</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>device_bind_driver</refname>
 <refpurpose>
  bind a driver to one device.
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>int <function>device_bind_driver </function></funcdef>
   <paramdef>struct device * <parameter>dev</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>dev</parameter></term>
   <listitem>
    <para>
     device.
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
<title>Description</title>
<para>
   Allow manual attachment of a driver to a device.
   Caller must have already set <parameter>dev</parameter>-&gt;driver.
   </para><para>

   Note that this does not modify the bus reference count
   nor take the bus's rwsem. Please verify those are accounted
   for before calling this. (It is ok to call with no other effort
   from a driver's <function>probe</function> method.)
   </para><para>

   This function must be called with the device lock held.
</para>
</refsect1>
</refentry>

<refentry id="API-wait-for-device-probe">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>July 2015</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>wait_for_device_probe</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.4.104</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>wait_for_device_probe</refname>
 <refpurpose>
   </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>void <function>wait_for_device_probe </function></funcdef>
   <paramdef> <parameter>void</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>void</parameter></term>
   <listitem>
    <para>
     no arguments
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
<title>Description</title>
<para>
   Wait for device probing to be completed.
</para>
</refsect1>
</refentry>

<refentry id="API-device-attach">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>July 2015</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>device_attach</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.4.104</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>device_attach</refname>
 <refpurpose>
     try to attach device to a driver.
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>int <function>device_attach </function></funcdef>
   <paramdef>struct device * <parameter>dev</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>dev</parameter></term>
   <listitem>
    <para>
     device.
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
<title>Description</title>
<para>
   Walk the list of drivers that the bus has and call
   <function>driver_probe_device</function> for each pair. If a compatible
   pair is found, break out and return.
   </para><para>

   Returns 1 if the device was bound to a driver;
   0 if no matching driver was found;
   -ENODEV if the device is not registered.
   </para><para>

   When called for a USB interface, <parameter>dev</parameter>-&gt;parent lock must be held.
</para>
</refsect1>
</refentry>

<refentry id="API-driver-attach">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>July 2015</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>driver_attach</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.4.104</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>driver_attach</refname>
 <refpurpose>
     try to bind driver to devices.
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>int <function>driver_attach </function></funcdef>
   <paramdef>struct device_driver * <parameter>drv</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>drv</parameter></term>
   <listitem>
    <para>
     driver.
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
<title>Description</title>
<para>
   Walk the list of devices that the bus has on it and try to
   match the driver with each one.  If <function>driver_probe_device</function>
   returns 0 and the <parameter>dev</parameter>-&gt;driver is set, we've found a
   compatible pair.
</para>
</refsect1>
</refentry>

<refentry id="API-device-release-driver">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>July 2015</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>device_release_driver</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.4.104</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>device_release_driver</refname>
 <refpurpose>
     manually detach device from driver.
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>void <function>device_release_driver </function></funcdef>
   <paramdef>struct device * <parameter>dev</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>dev</parameter></term>
   <listitem>
    <para>
     device.
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
<title>Description</title>
<para>
   Manually detach device from driver.
   When called for a USB interface, <parameter>dev</parameter>-&gt;parent lock must be held.
</para>
</refsect1>
</refentry>

<!--
X!Edrivers/base/interface.c
-->
<!-- include/linux/platform_device.h -->
<refentry id="API-platform-device-register-resndata">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>July 2015</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>platform_device_register_resndata</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.4.104</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>platform_device_register_resndata</refname>
 <refpurpose>
  add a platform-level device with resources and platform-specific data
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>struct platform_device * <function>platform_device_register_resndata </function></funcdef>
   <paramdef>struct device * <parameter>parent</parameter></paramdef>
   <paramdef>const char * <parameter>name</parameter></paramdef>
   <paramdef>int <parameter>id</parameter></paramdef>
   <paramdef>const struct resource * <parameter>res</parameter></paramdef>
   <paramdef>unsigned int <parameter>num</parameter></paramdef>
   <paramdef>const void * <parameter>data</parameter></paramdef>
   <paramdef>size_t <parameter>size</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>parent</parameter></term>
   <listitem>
    <para>
     parent device for the device we're adding
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>name</parameter></term>
   <listitem>
    <para>
     base name of the device we're adding
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>id</parameter></term>
   <listitem>
    <para>
     instance id
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>res</parameter></term>
   <listitem>
    <para>
     set of resources that needs to be allocated for the device
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>num</parameter></term>
   <listitem>
    <para>
     number of resources
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>data</parameter></term>
   <listitem>
    <para>
     platform specific data for this platform device
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>size</parameter></term>
   <listitem>
    <para>
     size of platform specific data
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
<title>Description</title>
<para>
   Returns <structname>struct platform_device</structname> pointer on success, or <function>ERR_PTR</function> on error.
</para>
</refsect1>
</refentry>

<refentry id="API-platform-device-register-simple">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>July 2015</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>platform_device_register_simple</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.4.104</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>platform_device_register_simple</refname>
 <refpurpose>
     add a platform-level device and its resources
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>struct platform_device * <function>platform_device_register_simple </function></funcdef>
   <paramdef>const char * <parameter>name</parameter></paramdef>
   <paramdef>int <parameter>id</parameter></paramdef>
   <paramdef>const struct resource * <parameter>res</parameter></paramdef>
   <paramdef>unsigned int <parameter>num</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>name</parameter></term>
   <listitem>
    <para>
     base name of the device we're adding
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>id</parameter></term>
   <listitem>
    <para>
     instance id
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>res</parameter></term>
   <listitem>
    <para>
     set of resources that needs to be allocated for the device
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>num</parameter></term>
   <listitem>
    <para>
     number of resources
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
<title>Description</title>
<para>
   This function creates a simple platform device that requires minimal
   resource and memory management. Canned release function freeing memory
   allocated for the device allows drivers using such devices to be
   unloaded without waiting for the last reference to the device to be
   dropped.
   </para><para>

   This interface is primarily intended for use with legacy drivers which
   probe hardware directly.  Because such drivers create sysfs device nodes
   themselves, rather than letting system infrastructure handle such device
   enumeration tasks, they don't fully conform to the Linux driver model.
   In particular, when such drivers are built as modules, they can't be
   <quote>hotplugged</quote>.
   </para><para>

   Returns <structname>struct platform_device</structname> pointer on success, or <function>ERR_PTR</function> on error.
</para>
</refsect1>
</refentry>

<refentry id="API-platform-device-register-data">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>July 2015</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>platform_device_register_data</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.4.104</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>platform_device_register_data</refname>
 <refpurpose>
     add a platform-level device with platform-specific data
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>struct platform_device * <function>platform_device_register_data </function></funcdef>
   <paramdef>struct device * <parameter>parent</parameter></paramdef>
   <paramdef>const char * <parameter>name</parameter></paramdef>
   <paramdef>int <parameter>id</parameter></paramdef>
   <paramdef>const void * <parameter>data</parameter></paramdef>
   <paramdef>size_t <parameter>size</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>parent</parameter></term>
   <listitem>
    <para>
     parent device for the device we're adding
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>name</parameter></term>
   <listitem>
    <para>
     base name of the device we're adding
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>id</parameter></term>
   <listitem>
    <para>
     instance id
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>data</parameter></term>
   <listitem>
    <para>
     platform specific data for this platform device
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>size</parameter></term>
   <listitem>
    <para>
     size of platform specific data
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
<title>Description</title>
<para>
   This function creates a simple platform device that requires minimal
   resource and memory management. Canned release function freeing memory
   allocated for the device allows drivers using such devices to be
   unloaded without waiting for the last reference to the device to be
   dropped.
   </para><para>

   Returns <structname>struct platform_device</structname> pointer on success, or <function>ERR_PTR</function> on error.
</para>
</refsect1>
</refentry>

<!-- drivers/base/platform.c -->
<refentry id="API-platform-get-resource">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>July 2015</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>platform_get_resource</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.4.104</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>platform_get_resource</refname>
 <refpurpose>
  get a resource for a device
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>struct resource * <function>platform_get_resource </function></funcdef>
   <paramdef>struct platform_device * <parameter>dev</parameter></paramdef>
   <paramdef>unsigned int <parameter>type</parameter></paramdef>
   <paramdef>unsigned int <parameter>num</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>dev</parameter></term>
   <listitem>
    <para>
     platform device
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>type</parameter></term>
   <listitem>
    <para>
     resource type
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>num</parameter></term>
   <listitem>
    <para>
     resource index
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
</refentry>

<refentry id="API-platform-get-irq">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>July 2015</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>platform_get_irq</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.4.104</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>platform_get_irq</refname>
 <refpurpose>
     get an IRQ for a device
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>int <function>platform_get_irq </function></funcdef>
   <paramdef>struct platform_device * <parameter>dev</parameter></paramdef>
   <paramdef>unsigned int <parameter>num</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>dev</parameter></term>
   <listitem>
    <para>
     platform device
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>num</parameter></term>
   <listitem>
    <para>
     IRQ number index
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
</refentry>

<refentry id="API-platform-get-resource-byname">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>July 2015</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>platform_get_resource_byname</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.4.104</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>platform_get_resource_byname</refname>
 <refpurpose>
     get a resource for a device by name
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>struct resource * <function>platform_get_resource_byname </function></funcdef>
   <paramdef>struct platform_device * <parameter>dev</parameter></paramdef>
   <paramdef>unsigned int <parameter>type</parameter></paramdef>
   <paramdef>const char * <parameter>name</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>dev</parameter></term>
   <listitem>
    <para>
     platform device
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>type</parameter></term>
   <listitem>
    <para>
     resource type
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>name</parameter></term>
   <listitem>
    <para>
     resource name
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
</refentry>

<refentry id="API-platform-get-irq-byname">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>July 2015</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>platform_get_irq_byname</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.4.104</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>platform_get_irq_byname</refname>
 <refpurpose>
     get an IRQ for a device
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>int <function>platform_get_irq_byname </function></funcdef>
   <paramdef>struct platform_device * <parameter>dev</parameter></paramdef>
   <paramdef>const char * <parameter>name</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>dev</parameter></term>
   <listitem>
    <para>
     platform device
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>name</parameter></term>
   <listitem>
    <para>
     IRQ name
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
</refentry>

<refentry id="API-platform-add-devices">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>July 2015</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>platform_add_devices</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.4.104</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>platform_add_devices</refname>
 <refpurpose>
     add a numbers of platform devices
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>int <function>platform_add_devices </function></funcdef>
   <paramdef>struct platform_device ** <parameter>devs</parameter></paramdef>
   <paramdef>int <parameter>num</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>devs</parameter></term>
   <listitem>
    <para>
     array of platform devices to add
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>num</parameter></term>
   <listitem>
    <para>
     number of platform devices in array
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
</refentry>

<refentry id="API-platform-device-put">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>July 2015</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>platform_device_put</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.4.104</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>platform_device_put</refname>
 <refpurpose>
     destroy a platform device
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>void <function>platform_device_put </function></funcdef>
   <paramdef>struct platform_device * <parameter>pdev</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>pdev</parameter></term>
   <listitem>
    <para>
     platform device to free
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
<title>Description</title>
<para>
   Free all memory associated with a platform device.  This function must
   _only_ be externally called in error cases.  All other usage is a bug.
</para>
</refsect1>
</refentry>

<refentry id="API-platform-device-alloc">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>July 2015</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>platform_device_alloc</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.4.104</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>platform_device_alloc</refname>
 <refpurpose>
     create a platform device
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>struct platform_device * <function>platform_device_alloc </function></funcdef>
   <paramdef>const char * <parameter>name</parameter></paramdef>
   <paramdef>int <parameter>id</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>name</parameter></term>
   <listitem>
    <para>
     base name of the device we're adding
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>id</parameter></term>
   <listitem>
    <para>
     instance id
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
<title>Description</title>
<para>
   Create a platform device object which can have other objects attached
   to it, and which will have attached objects freed when it is released.
</para>
</refsect1>
</refentry>

<refentry id="API-platform-device-add-resources">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>July 2015</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>platform_device_add_resources</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.4.104</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>platform_device_add_resources</refname>
 <refpurpose>
     add resources to a platform device
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>int <function>platform_device_add_resources </function></funcdef>
   <paramdef>struct platform_device * <parameter>pdev</parameter></paramdef>
   <paramdef>const struct resource * <parameter>res</parameter></paramdef>
   <paramdef>unsigned int <parameter>num</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>pdev</parameter></term>
   <listitem>
    <para>
     platform device allocated by platform_device_alloc to add resources to
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>res</parameter></term>
   <listitem>
    <para>
     set of resources that needs to be allocated for the device
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>num</parameter></term>
   <listitem>
    <para>
     number of resources
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
<title>Description</title>
<para>
   Add a copy of the resources to the platform device.  The memory
   associated with the resources will be freed when the platform device is
   released.
</para>
</refsect1>
</refentry>

<refentry id="API-platform-device-add-data">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>July 2015</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>platform_device_add_data</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.4.104</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>platform_device_add_data</refname>
 <refpurpose>
     add platform-specific data to a platform device
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>int <function>platform_device_add_data </function></funcdef>
   <paramdef>struct platform_device * <parameter>pdev</parameter></paramdef>
   <paramdef>const void * <parameter>data</parameter></paramdef>
   <paramdef>size_t <parameter>size</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>pdev</parameter></term>
   <listitem>
    <para>
     platform device allocated by platform_device_alloc to add resources to
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>data</parameter></term>
   <listitem>
    <para>
     platform specific data for this platform device
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>size</parameter></term>
   <listitem>
    <para>
     size of platform specific data
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
<title>Description</title>
<para>
   Add a copy of platform specific data to the platform device's
   platform_data pointer.  The memory associated with the platform data
   will be freed when the platform device is released.
</para>
</refsect1>
</refentry>

<refentry id="API-platform-device-add">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>July 2015</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>platform_device_add</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.4.104</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>platform_device_add</refname>
 <refpurpose>
     add a platform device to device hierarchy
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>int <function>platform_device_add </function></funcdef>
   <paramdef>struct platform_device * <parameter>pdev</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>pdev</parameter></term>
   <listitem>
    <para>
     platform device we're adding
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
<title>Description</title>
<para>
   This is part 2 of <function>platform_device_register</function>, though may be called
   separately _iff_ pdev was allocated by <function>platform_device_alloc</function>.
</para>
</refsect1>
</refentry>

<refentry id="API-platform-device-del">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>July 2015</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>platform_device_del</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.4.104</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>platform_device_del</refname>
 <refpurpose>
     remove a platform-level device
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>void <function>platform_device_del </function></funcdef>
   <paramdef>struct platform_device * <parameter>pdev</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>pdev</parameter></term>
   <listitem>
    <para>
     platform device we're removing
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
<title>Description</title>
<para>
   Note that this function will also release all memory- and port-based
   resources owned by the device (<parameter>dev</parameter>-&gt;resource).  This function must
   _only_ be externally called in error cases.  All other usage is a bug.
</para>
</refsect1>
</refentry>

<refentry id="API-platform-device-register">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>July 2015</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>platform_device_register</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.4.104</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>platform_device_register</refname>
 <refpurpose>
     add a platform-level device
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>int <function>platform_device_register </function></funcdef>
   <paramdef>struct platform_device * <parameter>pdev</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>pdev</parameter></term>
   <listitem>
    <para>
     platform device we're adding
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
</refentry>

<refentry id="API-platform-device-unregister">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>July 2015</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>platform_device_unregister</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.4.104</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>platform_device_unregister</refname>
 <refpurpose>
     unregister a platform-level device
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>void <function>platform_device_unregister </function></funcdef>
   <paramdef>struct platform_device * <parameter>pdev</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>pdev</parameter></term>
   <listitem>
    <para>
     platform device we're unregistering
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
<title>Description</title>
<para>
   Unregistration is done in 2 steps. First we release all resources
   and remove it from the subsystem, then we drop reference count by
   calling <function>platform_device_put</function>.
</para>
</refsect1>
</refentry>

<refentry id="API-platform-device-register-full">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>July 2015</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>platform_device_register_full</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.4.104</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>platform_device_register_full</refname>
 <refpurpose>
     add a platform-level device with resources and platform-specific data
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>struct platform_device * <function>platform_device_register_full </function></funcdef>
   <paramdef>const struct platform_device_info * <parameter>pdevinfo</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>pdevinfo</parameter></term>
   <listitem>
    <para>
     data used to create device
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
<title>Description</title>
<para>
   Returns <structname>struct platform_device</structname> pointer on success, or <function>ERR_PTR</function> on error.
</para>
</refsect1>
</refentry>

<refentry id="API-platform-driver-register">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>July 2015</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>platform_driver_register</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.4.104</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>platform_driver_register</refname>
 <refpurpose>
     register a driver for platform-level devices
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>int <function>platform_driver_register </function></funcdef>
   <paramdef>struct platform_driver * <parameter>drv</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>drv</parameter></term>
   <listitem>
    <para>
     platform driver structure
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
</refentry>

<refentry id="API-platform-driver-unregister">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>July 2015</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>platform_driver_unregister</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.4.104</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>platform_driver_unregister</refname>
 <refpurpose>
     unregister a driver for platform-level devices
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>void <function>platform_driver_unregister </function></funcdef>
   <paramdef>struct platform_driver * <parameter>drv</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>drv</parameter></term>
   <listitem>
    <para>
     platform driver structure
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
</refentry>

<refentry id="API-platform-driver-probe">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>July 2015</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>platform_driver_probe</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.4.104</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>platform_driver_probe</refname>
 <refpurpose>
     register driver for non-hotpluggable device
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>int <function>platform_driver_probe </function></funcdef>
   <paramdef>struct platform_driver * <parameter>drv</parameter></paramdef>
   <paramdef>int (*<parameter>probe</parameter>)
     <funcparams>struct platform_device *</funcparams></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>drv</parameter></term>
   <listitem>
    <para>
     platform driver structure
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>probe</parameter></term>
   <listitem>
    <para>
     the driver probe routine, probably from an __init section
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
<title>Description</title>
<para>
   Use this instead of <function>platform_driver_register</function> when you know the device
   is not hotpluggable and has already been registered, and you want to
   remove its run-once <function>probe</function> infrastructure from memory after the driver
   has bound to the device.
   </para><para>

   One typical use for this would be with drivers for controllers integrated
   into system-on-chip processors, where the controller devices have been
   configured as part of board setup.
   </para><para>

   Returns zero if the driver registered and bound to a device, else returns
   a negative error code and with the driver not registered.
</para>
</refsect1>
</refentry>

<refentry id="API-platform-create-bundle">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>July 2015</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>platform_create_bundle</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.4.104</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>platform_create_bundle</refname>
 <refpurpose>
     register driver and create corresponding device
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>struct platform_device * <function>platform_create_bundle </function></funcdef>
   <paramdef>struct platform_driver * <parameter>driver</parameter></paramdef>
   <paramdef>int (*<parameter>probe</parameter>)
     <funcparams>struct platform_device *</funcparams></paramdef>
   <paramdef>struct resource * <parameter>res</parameter></paramdef>
   <paramdef>unsigned int <parameter>n_res</parameter></paramdef>
   <paramdef>const void * <parameter>data</parameter></paramdef>
   <paramdef>size_t <parameter>size</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>driver</parameter></term>
   <listitem>
    <para>
     platform driver structure
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>probe</parameter></term>
   <listitem>
    <para>
     the driver probe routine, probably from an __init section
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>res</parameter></term>
   <listitem>
    <para>
     set of resources that needs to be allocated for the device
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>n_res</parameter></term>
   <listitem>
    <para>
     number of resources
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>data</parameter></term>
   <listitem>
    <para>
     platform specific data for this platform device
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>size</parameter></term>
   <listitem>
    <para>
     size of platform specific data
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
<title>Description</title>
<para>
   Use this in legacy-style modules that probe hardware directly and
   register a single platform device and corresponding platform driver.
   </para><para>

   Returns <structname>struct platform_device</structname> pointer on success, or <function>ERR_PTR</function> on error.
</para>
</refsect1>
</refentry>

<!-- drivers/base/bus.c -->
<refentry id="API-bus-for-each-dev">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>July 2015</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>bus_for_each_dev</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.4.104</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>bus_for_each_dev</refname>
 <refpurpose>
  device iterator.
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>int <function>bus_for_each_dev </function></funcdef>
   <paramdef>struct bus_type * <parameter>bus</parameter></paramdef>
   <paramdef>struct device * <parameter>start</parameter></paramdef>
   <paramdef>void * <parameter>data</parameter></paramdef>
   <paramdef>int (*<parameter>fn</parameter>)
     <funcparams>struct device *, void *</funcparams></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>bus</parameter></term>
   <listitem>
    <para>
     bus type.
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>start</parameter></term>
   <listitem>
    <para>
     device to start iterating from.
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>data</parameter></term>
   <listitem>
    <para>
     data for the callback.
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>fn</parameter></term>
   <listitem>
    <para>
     function to be called for each device.
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
<title>Description</title>
<para>
   Iterate over <parameter>bus</parameter>'s list of devices, and call <parameter>fn</parameter> for each,
   passing it <parameter>data</parameter>. If <parameter>start</parameter> is not NULL, we use that device to
   begin iterating from.
   </para><para>

   We check the return of <parameter>fn</parameter> each time. If it returns anything
   other than 0, we break out and return that value.
</para>
</refsect1>
<refsect1>
<title>NOTE</title>
<para>
   The device that returns a non-zero value is not retained
   in any way, nor is its refcount incremented. If the caller needs
   to retain this data, it should do so, and increment the reference
   count in the supplied callback.
</para>
</refsect1>
</refentry>

<refentry id="API-bus-find-device">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>July 2015</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>bus_find_device</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.4.104</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>bus_find_device</refname>
 <refpurpose>
     device iterator for locating a particular device.
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>struct device * <function>bus_find_device </function></funcdef>
   <paramdef>struct bus_type * <parameter>bus</parameter></paramdef>
   <paramdef>struct device * <parameter>start</parameter></paramdef>
   <paramdef>void * <parameter>data</parameter></paramdef>
   <paramdef>int (*<parameter>match</parameter>)
     <funcparams>struct device *dev, void *data</funcparams></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>bus</parameter></term>
   <listitem>
    <para>
     bus type
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>start</parameter></term>
   <listitem>
    <para>
     Device to begin with
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>data</parameter></term>
   <listitem>
    <para>
     Data to pass to match function
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>match</parameter></term>
   <listitem>
    <para>
     Callback function to check device
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
<title>Description</title>
<para>
   This is similar to the <function>bus_for_each_dev</function> function above, but it
   returns a reference to a device that is 'found' for later use, as
   determined by the <parameter>match</parameter> callback.
   </para><para>

   The callback should return 0 if the device doesn't match and non-zero
   if it does.  If the callback returns non-zero, this function will
   return to the caller and not iterate over any more devices.
</para>
</refsect1>
</refentry>

<refentry id="API-bus-find-device-by-name">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>July 2015</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>bus_find_device_by_name</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.4.104</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>bus_find_device_by_name</refname>
 <refpurpose>
     device iterator for locating a particular device of a specific name
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>struct device * <function>bus_find_device_by_name </function></funcdef>
   <paramdef>struct bus_type * <parameter>bus</parameter></paramdef>
   <paramdef>struct device * <parameter>start</parameter></paramdef>
   <paramdef>const char * <parameter>name</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>bus</parameter></term>
   <listitem>
    <para>
     bus type
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>start</parameter></term>
   <listitem>
    <para>
     Device to begin with
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>name</parameter></term>
   <listitem>
    <para>
     name of the device to match
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
<title>Description</title>
<para>
   This is similar to the <function>bus_find_device</function> function above, but it handles
   searching by a name automatically, no need to write another strcmp matching
   function.
</para>
</refsect1>
</refentry>

<refentry id="API-subsys-find-device-by-id">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>July 2015</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>subsys_find_device_by_id</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.4.104</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>subsys_find_device_by_id</refname>
 <refpurpose>
     find a device with a specific enumeration number
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>struct device * <function>subsys_find_device_by_id </function></funcdef>
   <paramdef>struct bus_type * <parameter>subsys</parameter></paramdef>
   <paramdef>unsigned int <parameter>id</parameter></paramdef>
   <paramdef>struct device * <parameter>hint</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>subsys</parameter></term>
   <listitem>
    <para>
     subsystem
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>id</parameter></term>
   <listitem>
    <para>
     index 'id' in struct device
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>hint</parameter></term>
   <listitem>
    <para>
     device to check first
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
<title>Description</title>
<para>
   Check the hint's next object and if it is a match return it directly,
   otherwise, fall back to a full list search. Either way a reference for
   the returned object is taken.
</para>
</refsect1>
</refentry>

<refentry id="API-bus-for-each-drv">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>July 2015</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>bus_for_each_drv</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.4.104</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>bus_for_each_drv</refname>
 <refpurpose>
     driver iterator
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>int <function>bus_for_each_drv </function></funcdef>
   <paramdef>struct bus_type * <parameter>bus</parameter></paramdef>
   <paramdef>struct device_driver * <parameter>start</parameter></paramdef>
   <paramdef>void * <parameter>data</parameter></paramdef>
   <paramdef>int (*<parameter>fn</parameter>)
     <funcparams>struct device_driver *, void *</funcparams></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>bus</parameter></term>
   <listitem>
    <para>
     bus we're dealing with.
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>start</parameter></term>
   <listitem>
    <para>
     driver to start iterating on.
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>data</parameter></term>
   <listitem>
    <para>
     data to pass to the callback.
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>fn</parameter></term>
   <listitem>
    <para>
     function to call for each driver.
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
<title>Description</title>
<para>
   This is nearly identical to the device iterator above.
   We iterate over each driver that belongs to <parameter>bus</parameter>, and call
   <parameter>fn</parameter> for each. If <parameter>fn</parameter> returns anything but 0, we break out
   and return it. If <parameter>start</parameter> is not NULL, we use it as the head
   of the list.
</para>
</refsect1>
<refsect1>
<title>NOTE</title>
<para>
   we don't return the driver that returns a non-zero
   value, nor do we leave the reference count incremented for that
   driver. If the caller needs to know that info, it must set it
   in the callback. It must also be sure to increment the refcount
   so it doesn't disappear before returning to the caller.
</para>
</refsect1>
</refentry>

<refentry id="API-bus-rescan-devices">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>July 2015</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>bus_rescan_devices</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.4.104</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>bus_rescan_devices</refname>
 <refpurpose>
     rescan devices on the bus for possible drivers
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>int <function>bus_rescan_devices </function></funcdef>
   <paramdef>struct bus_type * <parameter>bus</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>bus</parameter></term>
   <listitem>
    <para>
     the bus to scan.
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
<title>Description</title>
<para>
   This function will look for devices on the bus with no driver
   attached and rescan it against existing drivers to see if it matches
   any by calling <function>device_attach</function> for the unbound devices.
</para>
</refsect1>
</refentry>

<refentry id="API-device-reprobe">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>July 2015</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>device_reprobe</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.4.104</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>device_reprobe</refname>
 <refpurpose>
     remove driver for a device and probe for a new driver
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>int <function>device_reprobe </function></funcdef>
   <paramdef>struct device * <parameter>dev</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>dev</parameter></term>
   <listitem>
    <para>
     the device to reprobe
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
<title>Description</title>
<para>
   This function detaches the attached driver (if any) for the given
   device and restarts the driver probing process.  It is intended
   to use if probing criteria changed during a devices lifetime and
   driver attachment should change accordingly.
</para>
</refsect1>
</refentry>

<refentry id="API---bus-register">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>July 2015</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>__bus_register</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.4.104</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>__bus_register</refname>
 <refpurpose>
     register a driver-core subsystem
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>int <function>__bus_register </function></funcdef>
   <paramdef>struct bus_type * <parameter>bus</parameter></paramdef>
   <paramdef>struct lock_class_key * <parameter>key</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>bus</parameter></term>
   <listitem>
    <para>
     bus to register
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>key</parameter></term>
   <listitem>
    <para>
     lockdep class key
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
<title>Description</title>
<para>
   Once we have that, we register the bus with the kobject
   infrastructure, then register the children subsystems it has:
   the devices and drivers that belong to the subsystem.
</para>
</refsect1>
</refentry>

<refentry id="API-bus-unregister">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>July 2015</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>bus_unregister</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.4.104</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>bus_unregister</refname>
 <refpurpose>
     remove a bus from the system
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>void <function>bus_unregister </function></funcdef>
   <paramdef>struct bus_type * <parameter>bus</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>bus</parameter></term>
   <listitem>
    <para>
     bus.
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
<title>Description</title>
<para>
   Unregister the child subsystems and the bus itself.
   Finally, we call <function>bus_put</function> to release the refcount
</para>
</refsect1>
</refentry>

<refentry id="API-subsys-dev-iter-init">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>July 2015</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>subsys_dev_iter_init</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.4.104</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>subsys_dev_iter_init</refname>
 <refpurpose>
     initialize subsys device iterator
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>void <function>subsys_dev_iter_init </function></funcdef>
   <paramdef>struct subsys_dev_iter * <parameter>iter</parameter></paramdef>
   <paramdef>struct bus_type * <parameter>subsys</parameter></paramdef>
   <paramdef>struct device * <parameter>start</parameter></paramdef>
   <paramdef>const struct device_type * <parameter>type</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>iter</parameter></term>
   <listitem>
    <para>
     subsys iterator to initialize
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>subsys</parameter></term>
   <listitem>
    <para>
     the subsys we wanna iterate over
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>start</parameter></term>
   <listitem>
    <para>
     the device to start iterating from, if any
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>type</parameter></term>
   <listitem>
    <para>
     device_type of the devices to iterate over, NULL for all
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
<title>Description</title>
<para>
   Initialize subsys iterator <parameter>iter</parameter> such that it iterates over devices
   of <parameter>subsys</parameter>.  If <parameter>start</parameter> is set, the list iteration will start there,
   otherwise if it is NULL, the iteration starts at the beginning of
   the list.
</para>
</refsect1>
</refentry>

<refentry id="API-subsys-dev-iter-next">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>July 2015</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>subsys_dev_iter_next</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.4.104</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>subsys_dev_iter_next</refname>
 <refpurpose>
     iterate to the next device
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>struct device * <function>subsys_dev_iter_next </function></funcdef>
   <paramdef>struct subsys_dev_iter * <parameter>iter</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>iter</parameter></term>
   <listitem>
    <para>
     subsys iterator to proceed
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
<title>Description</title>
<para>
   Proceed <parameter>iter</parameter> to the next device and return it.  Returns NULL if
   iteration is complete.
   </para><para>

   The returned device is referenced and won't be released till
   iterator is proceed to the next device or exited.  The caller is
   free to do whatever it wants to do with the device including
   calling back into subsys code.
</para>
</refsect1>
</refentry>

<refentry id="API-subsys-dev-iter-exit">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>July 2015</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>subsys_dev_iter_exit</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.4.104</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>subsys_dev_iter_exit</refname>
 <refpurpose>
     finish iteration
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>void <function>subsys_dev_iter_exit </function></funcdef>
   <paramdef>struct subsys_dev_iter * <parameter>iter</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>iter</parameter></term>
   <listitem>
    <para>
     subsys iterator to finish
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
<title>Description</title>
<para>
   Finish an iteration.  Always call this function after iteration is
   complete whether the iteration ran till the end or not.
</para>
</refsect1>
</refentry>

<refentry id="API-subsys-system-register">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>July 2015</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>subsys_system_register</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.4.104</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>subsys_system_register</refname>
 <refpurpose>
     register a subsystem at /sys/devices/system/
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>int <function>subsys_system_register </function></funcdef>
   <paramdef>struct bus_type * <parameter>subsys</parameter></paramdef>
   <paramdef>const struct attribute_group ** <parameter>groups</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>subsys</parameter></term>
   <listitem>
    <para>
     system subsystem
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>groups</parameter></term>
   <listitem>
    <para>
     default attributes for the root device
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
<title>Description</title>
<para>
   All 'system' subsystems have a /sys/devices/system/&lt;name&gt; root device
   with the name of the subsystem. The root device can carry subsystem-
   wide attributes. All registered devices are below this single root
   device and are named after the subsystem with a simple enumeration
   number appended. The registered devices are not explicitely named;
   only 'id' in the device needs to be set.
   </para><para>

   Do not use this interface for anything new, it exists for compatibility
   with bad ideas only. New subsystems should use plain subsystems; and
   add the subsystem-wide attributes should be added to the subsystem
   directory itself and not some create fake root-device placed in
   /sys/devices/system/&lt;name&gt;.
</para>
</refsect1>
</refentry>

     </sect1>
     <sect1><title>Device Drivers DMA Management</title>
<!-- drivers/base/dma-buf.c -->
<refentry id="API-dma-buf-export">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>July 2015</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>dma_buf_export</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.4.104</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>dma_buf_export</refname>
 <refpurpose>
  Creates a new dma_buf, and associates an anon file with this buffer, so it can be exported. Also connect the allocator specific data and ops to the buffer.
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>struct dma_buf * <function>dma_buf_export </function></funcdef>
   <paramdef>void * <parameter>priv</parameter></paramdef>
   <paramdef>const struct dma_buf_ops * <parameter>ops</parameter></paramdef>
   <paramdef>size_t <parameter>size</parameter></paramdef>
   <paramdef>int <parameter>flags</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>priv</parameter></term>
   <listitem>
    <para>
     [in]	Attach private data of allocator to this buffer
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>ops</parameter></term>
   <listitem>
    <para>
     [in]	Attach allocator-defined dma buf ops to the new buffer.
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>size</parameter></term>
   <listitem>
    <para>
     [in]	Size of the buffer
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>flags</parameter></term>
   <listitem>
    <para>
     [in]	mode flags for the file.
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
<title>Description</title>
<para>
   Returns, on success, a newly created dma_buf object, which wraps the
   supplied private data and operations for dma_buf_ops. On either missing
   ops, or error in allocating struct dma_buf, will return negative error.
</para>
</refsect1>
</refentry>

<refentry id="API-dma-buf-fd">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>July 2015</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>dma_buf_fd</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.4.104</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>dma_buf_fd</refname>
 <refpurpose>
     returns a file descriptor for the given dma_buf
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>int <function>dma_buf_fd </function></funcdef>
   <paramdef>struct dma_buf * <parameter>dmabuf</parameter></paramdef>
   <paramdef>int <parameter>flags</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>dmabuf</parameter></term>
   <listitem>
    <para>
     [in]	pointer to dma_buf for which fd is required.
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>flags</parameter></term>
   <listitem>
    <para>
     [in]    flags to give to fd
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
<title>Description</title>
<para>
   On success, returns an associated 'fd'. Else, returns error.
</para>
</refsect1>
</refentry>

<refentry id="API-dma-buf-get">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>July 2015</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>dma_buf_get</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.4.104</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>dma_buf_get</refname>
 <refpurpose>
     returns the dma_buf structure related to an fd
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>struct dma_buf * <function>dma_buf_get </function></funcdef>
   <paramdef>int <parameter>fd</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>fd</parameter></term>
   <listitem>
    <para>
     [in]	fd associated with the dma_buf to be returned
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
<title>Description</title>
<para>
   On success, returns the dma_buf structure associated with an fd; uses
   file's refcounting done by fget to increase refcount. returns ERR_PTR
   otherwise.
</para>
</refsect1>
</refentry>

<refentry id="API-dma-buf-put">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>July 2015</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>dma_buf_put</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.4.104</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>dma_buf_put</refname>
 <refpurpose>
     decreases refcount of the buffer
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>void <function>dma_buf_put </function></funcdef>
   <paramdef>struct dma_buf * <parameter>dmabuf</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>dmabuf</parameter></term>
   <listitem>
    <para>
     [in]	buffer to reduce refcount of
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
<title>Description</title>
<para>
   Uses file's refcounting done implicitly by <function>fput</function>
</para>
</refsect1>
</refentry>

<refentry id="API-dma-buf-attach">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>July 2015</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>dma_buf_attach</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.4.104</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>dma_buf_attach</refname>
 <refpurpose>
     Add the device to dma_buf's attachments list; optionally, calls <function>attach</function> of dma_buf_ops to allow device-specific attach functionality
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>struct dma_buf_attachment * <function>dma_buf_attach </function></funcdef>
   <paramdef>struct dma_buf * <parameter>dmabuf</parameter></paramdef>
   <paramdef>struct device * <parameter>dev</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>dmabuf</parameter></term>
   <listitem>
    <para>
     [in]	buffer to attach device to.
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>dev</parameter></term>
   <listitem>
    <para>
     [in]	device to be attached.
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
<title>Description</title>
<para>
   Returns struct dma_buf_attachment * for this attachment; may return negative
   error codes.
</para>
</refsect1>
</refentry>

<refentry id="API-dma-buf-detach">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>July 2015</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>dma_buf_detach</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.4.104</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>dma_buf_detach</refname>
 <refpurpose>
     Remove the given attachment from dmabuf's attachments list; optionally calls <function>detach</function> of dma_buf_ops for device-specific detach
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>void <function>dma_buf_detach </function></funcdef>
   <paramdef>struct dma_buf * <parameter>dmabuf</parameter></paramdef>
   <paramdef>struct dma_buf_attachment * <parameter>attach</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>dmabuf</parameter></term>
   <listitem>
    <para>
     [in]	buffer to detach from.
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>attach</parameter></term>
   <listitem>
    <para>
     [in]	attachment to be detached; is free'd after this call.
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
</refentry>

<refentry id="API-dma-buf-map-attachment">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>July 2015</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>dma_buf_map_attachment</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.4.104</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>dma_buf_map_attachment</refname>
 <refpurpose>
     Returns the scatterlist table of the attachment; mapped into _device_ address space. Is a wrapper for <function>map_dma_buf</function> of the dma_buf_ops.
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>struct sg_table * <function>dma_buf_map_attachment </function></funcdef>
   <paramdef>struct dma_buf_attachment * <parameter>attach</parameter></paramdef>
   <paramdef>enum dma_data_direction <parameter>direction</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>attach</parameter></term>
   <listitem>
    <para>
     [in]	attachment whose scatterlist is to be returned
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>direction</parameter></term>
   <listitem>
    <para>
     [in]	direction of DMA transfer
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
<title>Description</title>
<para>
   Returns sg_table containing the scatterlist to be returned; may return NULL
   or ERR_PTR.
</para>
</refsect1>
</refentry>

<refentry id="API-dma-buf-unmap-attachment">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>July 2015</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>dma_buf_unmap_attachment</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.4.104</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>dma_buf_unmap_attachment</refname>
 <refpurpose>
     unmaps and decreases usecount of the buffer;might deallocate the scatterlist associated. Is a wrapper for <function>unmap_dma_buf</function> of dma_buf_ops.
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>void <function>dma_buf_unmap_attachment </function></funcdef>
   <paramdef>struct dma_buf_attachment * <parameter>attach</parameter></paramdef>
   <paramdef>struct sg_table * <parameter>sg_table</parameter></paramdef>
   <paramdef>enum dma_data_direction <parameter>direction</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>attach</parameter></term>
   <listitem>
    <para>
     [in]	attachment to unmap buffer from
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>sg_table</parameter></term>
   <listitem>
    <para>
     [in]	scatterlist info of the buffer to unmap
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>direction</parameter></term>
   <listitem>
    <para>
     [in]    direction of DMA transfer
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
</refentry>

<refentry id="API-dma-buf-begin-cpu-access">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>July 2015</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>dma_buf_begin_cpu_access</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.4.104</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>dma_buf_begin_cpu_access</refname>
 <refpurpose>
     Must be called before accessing a dma_buf from the cpu in the kernel context. Calls begin_cpu_access to allow exporter-specific preparations. Coherency is only guaranteed in the specified range for the specified access direction.
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>int <function>dma_buf_begin_cpu_access </function></funcdef>
   <paramdef>struct dma_buf * <parameter>dmabuf</parameter></paramdef>
   <paramdef>size_t <parameter>start</parameter></paramdef>
   <paramdef>size_t <parameter>len</parameter></paramdef>
   <paramdef>enum dma_data_direction <parameter>direction</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>dmabuf</parameter></term>
   <listitem>
    <para>
     -- undescribed --
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>start</parameter></term>
   <listitem>
    <para>
     [in]	start of range for cpu access.
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>len</parameter></term>
   <listitem>
    <para>
     [in]	length of range for cpu access.
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>direction</parameter></term>
   <listitem>
    <para>
     [in]	length of range for cpu access.
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
<title>Description</title>
<para>
   Can return negative error values, returns 0 on success.
</para>
</refsect1>
</refentry>

<refentry id="API-dma-buf-end-cpu-access">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>July 2015</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>dma_buf_end_cpu_access</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.4.104</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>dma_buf_end_cpu_access</refname>
 <refpurpose>
     Must be called after accessing a dma_buf from the cpu in the kernel context. Calls end_cpu_access to allow exporter-specific actions. Coherency is only guaranteed in the specified range for the specified access direction.
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>void <function>dma_buf_end_cpu_access </function></funcdef>
   <paramdef>struct dma_buf * <parameter>dmabuf</parameter></paramdef>
   <paramdef>size_t <parameter>start</parameter></paramdef>
   <paramdef>size_t <parameter>len</parameter></paramdef>
   <paramdef>enum dma_data_direction <parameter>direction</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>dmabuf</parameter></term>
   <listitem>
    <para>
     -- undescribed --
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>start</parameter></term>
   <listitem>
    <para>
     [in]	start of range for cpu access.
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>len</parameter></term>
   <listitem>
    <para>
     [in]	length of range for cpu access.
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>direction</parameter></term>
   <listitem>
    <para>
     [in]	length of range for cpu access.
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
<title>Description</title>
<para>
   This call must always succeed.
</para>
</refsect1>
</refentry>

<refentry id="API-dma-buf-kmap-atomic">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>July 2015</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>dma_buf_kmap_atomic</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.4.104</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>dma_buf_kmap_atomic</refname>
 <refpurpose>
     Map a page of the buffer object into kernel address space. The same restrictions as for kmap_atomic and friends apply.
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>void * <function>dma_buf_kmap_atomic </function></funcdef>
   <paramdef>struct dma_buf * <parameter>dmabuf</parameter></paramdef>
   <paramdef>unsigned long <parameter>page_num</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>dmabuf</parameter></term>
   <listitem>
    <para>
     -- undescribed --
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>page_num</parameter></term>
   <listitem>
    <para>
     [in]	page in PAGE_SIZE units to map.
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
<title>Description</title>
<para>
   This call must always succeed, any necessary preparations that might fail
   need to be done in begin_cpu_access.
</para>
</refsect1>
</refentry>

<refentry id="API-dma-buf-kunmap-atomic">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>July 2015</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>dma_buf_kunmap_atomic</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.4.104</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>dma_buf_kunmap_atomic</refname>
 <refpurpose>
     Unmap a page obtained by dma_buf_kmap_atomic.
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>void <function>dma_buf_kunmap_atomic </function></funcdef>
   <paramdef>struct dma_buf * <parameter>dmabuf</parameter></paramdef>
   <paramdef>unsigned long <parameter>page_num</parameter></paramdef>
   <paramdef>void * <parameter>vaddr</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>dmabuf</parameter></term>
   <listitem>
    <para>
     -- undescribed --
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>page_num</parameter></term>
   <listitem>
    <para>
     [in]	page in PAGE_SIZE units to unmap.
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>vaddr</parameter></term>
   <listitem>
    <para>
     [in]	kernel space pointer obtained from dma_buf_kmap_atomic.
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
<title>Description</title>
<para>
   This call must always succeed.
</para>
</refsect1>
</refentry>

<refentry id="API-dma-buf-kmap">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>July 2015</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>dma_buf_kmap</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.4.104</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>dma_buf_kmap</refname>
 <refpurpose>
     Map a page of the buffer object into kernel address space. The same restrictions as for kmap and friends apply.
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>void * <function>dma_buf_kmap </function></funcdef>
   <paramdef>struct dma_buf * <parameter>dmabuf</parameter></paramdef>
   <paramdef>unsigned long <parameter>page_num</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>dmabuf</parameter></term>
   <listitem>
    <para>
     -- undescribed --
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>page_num</parameter></term>
   <listitem>
    <para>
     [in]	page in PAGE_SIZE units to map.
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
<title>Description</title>
<para>
   This call must always succeed, any necessary preparations that might fail
   need to be done in begin_cpu_access.
</para>
</refsect1>
</refentry>

<refentry id="API-dma-buf-kunmap">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>July 2015</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>dma_buf_kunmap</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.4.104</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>dma_buf_kunmap</refname>
 <refpurpose>
     Unmap a page obtained by dma_buf_kmap.
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>void <function>dma_buf_kunmap </function></funcdef>
   <paramdef>struct dma_buf * <parameter>dmabuf</parameter></paramdef>
   <paramdef>unsigned long <parameter>page_num</parameter></paramdef>
   <paramdef>void * <parameter>vaddr</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>dmabuf</parameter></term>
   <listitem>
    <para>
     -- undescribed --
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>page_num</parameter></term>
   <listitem>
    <para>
     [in]	page in PAGE_SIZE units to unmap.
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>vaddr</parameter></term>
   <listitem>
    <para>
     [in]	kernel space pointer obtained from dma_buf_kmap.
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
<title>Description</title>
<para>
   This call must always succeed.
</para>
</refsect1>
</refentry>

<refentry id="API-dma-buf-mmap">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>July 2015</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>dma_buf_mmap</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.4.104</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>dma_buf_mmap</refname>
 <refpurpose>
     Setup up a userspace mmap with the given vma
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>int <function>dma_buf_mmap </function></funcdef>
   <paramdef>struct dma_buf * <parameter>dmabuf</parameter></paramdef>
   <paramdef>struct vm_area_struct * <parameter>vma</parameter></paramdef>
   <paramdef>unsigned long <parameter>pgoff</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>dmabuf</parameter></term>
   <listitem>
    <para>
     -- undescribed --
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>vma</parameter></term>
   <listitem>
    <para>
     [in]	vma for the mmap
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>pgoff</parameter></term>
   <listitem>
    <para>
     [in]	offset in pages where this mmap should start within the
     dma-buf buffer.
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
<title>Description</title>
<para>
   This function adjusts the passed in vma so that it points at the file of the
   dma_buf operation. It alsog adjusts the starting pgoff and does bounds
   checking on the size of the vma. Then it calls the exporters mmap function to
   set up the mapping.
   </para><para>

   Can return negative error values, returns 0 on success.
</para>
</refsect1>
</refentry>

<!-- drivers/base/dma-coherent.c -->
<refentry id="API-dma-alloc-from-coherent">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>July 2015</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>dma_alloc_from_coherent</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.4.104</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>dma_alloc_from_coherent</refname>
 <refpurpose>
  try to allocate memory from the per-device coherent area
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>int <function>dma_alloc_from_coherent </function></funcdef>
   <paramdef>struct device * <parameter>dev</parameter></paramdef>
   <paramdef>ssize_t <parameter>size</parameter></paramdef>
   <paramdef>dma_addr_t * <parameter>dma_handle</parameter></paramdef>
   <paramdef>void ** <parameter>ret</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>dev</parameter></term>
   <listitem>
    <para>
     device from which we allocate memory
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>size</parameter></term>
   <listitem>
    <para>
     size of requested memory area
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>dma_handle</parameter></term>
   <listitem>
    <para>
     This will be filled with the correct dma handle
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>ret</parameter></term>
   <listitem>
    <para>
     This pointer will be filled with the virtual address
     to allocated area.
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
<title>Description</title>
<para>
   This function should be only called from per-arch <function>dma_alloc_coherent</function>
   to support allocation from per-device coherent memory pools.
   </para><para>

   Returns 0 if dma_alloc_coherent should continue with allocating from
   generic memory areas, or !0 if dma_alloc_coherent should return <parameter>ret</parameter>.
</para>
</refsect1>
</refentry>

<refentry id="API-dma-release-from-coherent">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>July 2015</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>dma_release_from_coherent</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.4.104</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>dma_release_from_coherent</refname>
 <refpurpose>
     try to free the memory allocated from per-device coherent memory pool
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>int <function>dma_release_from_coherent </function></funcdef>
   <paramdef>struct device * <parameter>dev</parameter></paramdef>
   <paramdef>int <parameter>order</parameter></paramdef>
   <paramdef>void * <parameter>vaddr</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>dev</parameter></term>
   <listitem>
    <para>
     device from which the memory was allocated
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>order</parameter></term>
   <listitem>
    <para>
     the order of pages allocated
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>vaddr</parameter></term>
   <listitem>
    <para>
     virtual address of allocated pages
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
<title>Description</title>
<para>
   This checks whether the memory was allocated from the per-device
   coherent memory pool and if so, releases that memory.
   </para><para>

   Returns 1 if we correctly released the memory, or 0 if
   <function>dma_release_coherent</function> should proceed with releasing memory from
   generic pools.
</para>
</refsect1>
</refentry>

<!-- drivers/base/dma-mapping.c -->
<refentry id="API-dmam-alloc-coherent">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>July 2015</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>dmam_alloc_coherent</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.4.104</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>dmam_alloc_coherent</refname>
 <refpurpose>
  Managed <function>dma_alloc_coherent</function>
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>void * <function>dmam_alloc_coherent </function></funcdef>
   <paramdef>struct device * <parameter>dev</parameter></paramdef>
   <paramdef>size_t <parameter>size</parameter></paramdef>
   <paramdef>dma_addr_t * <parameter>dma_handle</parameter></paramdef>
   <paramdef>gfp_t <parameter>gfp</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>dev</parameter></term>
   <listitem>
    <para>
     Device to allocate coherent memory for
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>size</parameter></term>
   <listitem>
    <para>
     Size of allocation
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>dma_handle</parameter></term>
   <listitem>
    <para>
     Out argument for allocated DMA handle
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>gfp</parameter></term>
   <listitem>
    <para>
     Allocation flags
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
<title>Description</title>
<para>
   Managed <function>dma_alloc_coherent</function>.  Memory allocated using this function
   will be automatically released on driver detach.
</para>
</refsect1>
<refsect1>
<title>RETURNS</title>
<para>
   Pointer to allocated memory on success, NULL on failure.
</para>
</refsect1>
</refentry>

<refentry id="API-dmam-free-coherent">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>July 2015</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>dmam_free_coherent</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.4.104</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>dmam_free_coherent</refname>
 <refpurpose>
     Managed <function>dma_free_coherent</function>
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>void <function>dmam_free_coherent </function></funcdef>
   <paramdef>struct device * <parameter>dev</parameter></paramdef>
   <paramdef>size_t <parameter>size</parameter></paramdef>
   <paramdef>void * <parameter>vaddr</parameter></paramdef>
   <paramdef>dma_addr_t <parameter>dma_handle</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>dev</parameter></term>
   <listitem>
    <para>
     Device to free coherent memory for
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>size</parameter></term>
   <listitem>
    <para>
     Size of allocation
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>vaddr</parameter></term>
   <listitem>
    <para>
     Virtual address of the memory to free
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>dma_handle</parameter></term>
   <listitem>
    <para>
     DMA handle of the memory to free
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
<title>Description</title>
<para>
   Managed <function>dma_free_coherent</function>.
</para>
</refsect1>
</refentry>

<refentry id="API-dmam-alloc-noncoherent">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>July 2015</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>dmam_alloc_noncoherent</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.4.104</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>dmam_alloc_noncoherent</refname>
 <refpurpose>
     Managed <function>dma_alloc_non_coherent</function>
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>void * <function>dmam_alloc_noncoherent </function></funcdef>
   <paramdef>struct device * <parameter>dev</parameter></paramdef>
   <paramdef>size_t <parameter>size</parameter></paramdef>
   <paramdef>dma_addr_t * <parameter>dma_handle</parameter></paramdef>
   <paramdef>gfp_t <parameter>gfp</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>dev</parameter></term>
   <listitem>
    <para>
     Device to allocate non_coherent memory for
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>size</parameter></term>
   <listitem>
    <para>
     Size of allocation
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>dma_handle</parameter></term>
   <listitem>
    <para>
     Out argument for allocated DMA handle
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>gfp</parameter></term>
   <listitem>
    <para>
     Allocation flags
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
<title>Description</title>
<para>
   Managed <function>dma_alloc_non_coherent</function>.  Memory allocated using this
   function will be automatically released on driver detach.
</para>
</refsect1>
<refsect1>
<title>RETURNS</title>
<para>
   Pointer to allocated memory on success, NULL on failure.
</para>
</refsect1>
</refentry>

<refentry id="API-dmam-free-noncoherent">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>July 2015</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>dmam_free_noncoherent</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.4.104</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>dmam_free_noncoherent</refname>
 <refpurpose>
     Managed <function>dma_free_noncoherent</function>
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>void <function>dmam_free_noncoherent </function></funcdef>
   <paramdef>struct device * <parameter>dev</parameter></paramdef>
   <paramdef>size_t <parameter>size</parameter></paramdef>
   <paramdef>void * <parameter>vaddr</parameter></paramdef>
   <paramdef>dma_addr_t <parameter>dma_handle</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>dev</parameter></term>
   <listitem>
    <para>
     Device to free noncoherent memory for
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>size</parameter></term>
   <listitem>
    <para>
     Size of allocation
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>vaddr</parameter></term>
   <listitem>
    <para>
     Virtual address of the memory to free
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>dma_handle</parameter></term>
   <listitem>
    <para>
     DMA handle of the memory to free
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
<title>Description</title>
<para>
   Managed <function>dma_free_noncoherent</function>.
</para>
</refsect1>
</refentry>

<refentry id="API-dmam-declare-coherent-memory">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>July 2015</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>dmam_declare_coherent_memory</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.4.104</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>dmam_declare_coherent_memory</refname>
 <refpurpose>
     Managed <function>dma_declare_coherent_memory</function>
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>int <function>dmam_declare_coherent_memory </function></funcdef>
   <paramdef>struct device * <parameter>dev</parameter></paramdef>
   <paramdef>dma_addr_t <parameter>bus_addr</parameter></paramdef>
   <paramdef>dma_addr_t <parameter>device_addr</parameter></paramdef>
   <paramdef>size_t <parameter>size</parameter></paramdef>
   <paramdef>int <parameter>flags</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>dev</parameter></term>
   <listitem>
    <para>
     Device to declare coherent memory for
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>bus_addr</parameter></term>
   <listitem>
    <para>
     Bus address of coherent memory to be declared
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>device_addr</parameter></term>
   <listitem>
    <para>
     Device address of coherent memory to be declared
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>size</parameter></term>
   <listitem>
    <para>
     Size of coherent memory to be declared
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>flags</parameter></term>
   <listitem>
    <para>
     Flags
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
<title>Description</title>
<para>
   Managed <function>dma_declare_coherent_memory</function>.
</para>
</refsect1>
<refsect1>
<title>RETURNS</title>
<para>
   0 on success, -errno on failure.
</para>
</refsect1>
</refentry>

<refentry id="API-dmam-release-declared-memory">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>July 2015</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>dmam_release_declared_memory</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.4.104</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>dmam_release_declared_memory</refname>
 <refpurpose>
     Managed <function>dma_release_declared_memory</function>.
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>void <function>dmam_release_declared_memory </function></funcdef>
   <paramdef>struct device * <parameter>dev</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>dev</parameter></term>
   <listitem>
    <para>
     Device to release declared coherent memory for
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
<title>Description</title>
<para>
   Managed <function>dmam_release_declared_memory</function>.
</para>
</refsect1>
</refentry>

     </sect1>
     <sect1><title>Device Drivers Power Management</title>
<!-- drivers/base/power/main.c -->
<refentry id="API-dpm-resume-start">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>July 2015</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>dpm_resume_start</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.4.104</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>dpm_resume_start</refname>
 <refpurpose>
  Execute <quote>noirq</quote> and <quote>early</quote> device callbacks.
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>void <function>dpm_resume_start </function></funcdef>
   <paramdef>pm_message_t <parameter>state</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>state</parameter></term>
   <listitem>
    <para>
     PM transition of the system being carried out.
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
</refentry>

<refentry id="API-dpm-resume-end">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>July 2015</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>dpm_resume_end</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.4.104</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>dpm_resume_end</refname>
 <refpurpose>
     Execute <quote>resume</quote> callbacks and complete system transition.
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>void <function>dpm_resume_end </function></funcdef>
   <paramdef>pm_message_t <parameter>state</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>state</parameter></term>
   <listitem>
    <para>
     PM transition of the system being carried out.
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
<title>Description</title>
<para>
   Execute <quote>resume</quote> callbacks for all devices and complete the PM transition of
   the system.
</para>
</refsect1>
</refentry>

<refentry id="API-dpm-suspend-end">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>July 2015</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>dpm_suspend_end</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.4.104</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>dpm_suspend_end</refname>
 <refpurpose>
     Execute <quote>late</quote> and <quote>noirq</quote> device suspend callbacks.
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>int <function>dpm_suspend_end </function></funcdef>
   <paramdef>pm_message_t <parameter>state</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>state</parameter></term>
   <listitem>
    <para>
     PM transition of the system being carried out.
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
</refentry>

<refentry id="API-dpm-suspend-start">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>July 2015</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>dpm_suspend_start</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.4.104</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>dpm_suspend_start</refname>
 <refpurpose>
     Prepare devices for PM transition and suspend them.
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>int <function>dpm_suspend_start </function></funcdef>
   <paramdef>pm_message_t <parameter>state</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>state</parameter></term>
   <listitem>
    <para>
     PM transition of the system being carried out.
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
<title>Description</title>
<para>
   Prepare all non-sysdev devices for system PM transition and execute <quote>suspend</quote>
   callbacks for them.
</para>
</refsect1>
</refentry>

<refentry id="API-device-pm-wait-for-dev">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>July 2015</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>device_pm_wait_for_dev</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.4.104</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>device_pm_wait_for_dev</refname>
 <refpurpose>
     Wait for suspend/resume of a device to complete.
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>int <function>device_pm_wait_for_dev </function></funcdef>
   <paramdef>struct device * <parameter>subordinate</parameter></paramdef>
   <paramdef>struct device * <parameter>dev</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>subordinate</parameter></term>
   <listitem>
    <para>
     Device that needs to wait for <parameter>dev</parameter>.
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>dev</parameter></term>
   <listitem>
    <para>
     Device to wait for.
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
</refentry>

     </sect1>
     <sect1><title>Device Drivers ACPI Support</title>
<!-- Internal functions only
X!Edrivers/acpi/sleep/main.c
X!Edrivers/acpi/sleep/wakeup.c
X!Edrivers/acpi/motherboard.c
X!Edrivers/acpi/bus.c
-->
<!-- drivers/acpi/scan.c -->
<refentry id="API-acpi-bus-register-driver">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>July 2015</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>acpi_bus_register_driver</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.4.104</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>acpi_bus_register_driver</refname>
 <refpurpose>
  register a driver with the ACPI bus
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>int <function>acpi_bus_register_driver </function></funcdef>
   <paramdef>struct acpi_driver * <parameter>driver</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>driver</parameter></term>
   <listitem>
    <para>
     driver being registered
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
<title>Description</title>
<para>
   Registers a driver with the ACPI bus.  Searches the namespace for all
   devices that match the driver's criteria and binds.  Returns zero for
   success or a negative error status for failure.
</para>
</refsect1>
</refentry>

<refentry id="API-acpi-bus-unregister-driver">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>July 2015</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>acpi_bus_unregister_driver</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.4.104</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>acpi_bus_unregister_driver</refname>
 <refpurpose>
     unregisters a driver with the APIC bus
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>void <function>acpi_bus_unregister_driver </function></funcdef>
   <paramdef>struct acpi_driver * <parameter>driver</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>driver</parameter></term>
   <listitem>
    <para>
     driver to unregister
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
<title>Description</title>
<para>
   Unregisters a driver with the ACPI bus.  Searches the namespace for all
   devices that match the driver's criteria and unbinds.
</para>
</refsect1>
</refentry>

<!-- drivers/acpi/scan.c -->
<refentry id="API-acpi-bus-driver-init">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>July 2015</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>acpi_bus_driver_init</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.4.104</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>acpi_bus_driver_init</refname>
 <refpurpose>
  add a device to a driver
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>int <function>acpi_bus_driver_init </function></funcdef>
   <paramdef>struct acpi_device * <parameter>device</parameter></paramdef>
   <paramdef>struct acpi_driver * <parameter>driver</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>device</parameter></term>
   <listitem>
    <para>
     the device to add and initialize
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>driver</parameter></term>
   <listitem>
    <para>
     driver for the device
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
<title>Description</title>
<para>
   Used to initialize a device via its device driver.  Called whenever a
   driver is bound to a device.  Invokes the driver's <function>add</function> ops.
</para>
</refsect1>
</refentry>

<!-- No correct structured comments
X!Edrivers/acpi/pci_bind.c
-->
     </sect1>
     <sect1><title>Device drivers PnP support</title>
<!-- drivers/pnp/core.c -->
<refentry id="API-pnp-register-protocol">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>July 2015</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>pnp_register_protocol</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.4.104</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>pnp_register_protocol</refname>
 <refpurpose>
  adds a pnp protocol to the pnp layer
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>int <function>pnp_register_protocol </function></funcdef>
   <paramdef>struct pnp_protocol * <parameter>protocol</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>protocol</parameter></term>
   <listitem>
    <para>
     pointer to the corresponding pnp_protocol structure
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
<title>Ex protocols</title>
<para>
   ISAPNP, PNPBIOS, etc
</para>
</refsect1>
</refentry>

<refentry id="API-pnp-unregister-protocol">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>July 2015</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>pnp_unregister_protocol</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.4.104</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>pnp_unregister_protocol</refname>
 <refpurpose>
     removes a pnp protocol from the pnp layer
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>void <function>pnp_unregister_protocol </function></funcdef>
   <paramdef>struct pnp_protocol * <parameter>protocol</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>protocol</parameter></term>
   <listitem>
    <para>
     pointer to the corresponding pnp_protocol structure
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
</refentry>

<!-- No correct structured comments
X!Edrivers/pnp/system.c
 -->
<!-- drivers/pnp/card.c -->
<refentry id="API-pnp-request-card-device">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>July 2015</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>pnp_request_card_device</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.4.104</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>pnp_request_card_device</refname>
 <refpurpose>
  Searches for a PnP device under the specified card
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>struct pnp_dev * <function>pnp_request_card_device </function></funcdef>
   <paramdef>struct pnp_card_link * <parameter>clink</parameter></paramdef>
   <paramdef>const char * <parameter>id</parameter></paramdef>
   <paramdef>struct pnp_dev * <parameter>from</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>clink</parameter></term>
   <listitem>
    <para>
     pointer to the card link, cannot be NULL
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>id</parameter></term>
   <listitem>
    <para>
     pointer to a PnP ID structure that explains the rules for finding the device
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>from</parameter></term>
   <listitem>
    <para>
     Starting place to search from. If NULL it will start from the beginning.
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
</refentry>

<refentry id="API-pnp-release-card-device">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>July 2015</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>pnp_release_card_device</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.4.104</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>pnp_release_card_device</refname>
 <refpurpose>
     call this when the driver no longer needs the device
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>void <function>pnp_release_card_device </function></funcdef>
   <paramdef>struct pnp_dev * <parameter>dev</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>dev</parameter></term>
   <listitem>
    <para>
     pointer to the PnP device structure
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
</refentry>

<refentry id="API-pnp-register-card-driver">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>July 2015</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>pnp_register_card_driver</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.4.104</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>pnp_register_card_driver</refname>
 <refpurpose>
     registers a PnP card driver with the PnP Layer
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>int <function>pnp_register_card_driver </function></funcdef>
   <paramdef>struct pnp_card_driver * <parameter>drv</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>drv</parameter></term>
   <listitem>
    <para>
     pointer to the driver to register
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
</refentry>

<refentry id="API-pnp-unregister-card-driver">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>July 2015</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>pnp_unregister_card_driver</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.4.104</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>pnp_unregister_card_driver</refname>
 <refpurpose>
     unregisters a PnP card driver from the PnP Layer
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>void <function>pnp_unregister_card_driver </function></funcdef>
   <paramdef>struct pnp_card_driver * <parameter>drv</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>drv</parameter></term>
   <listitem>
    <para>
     pointer to the driver to unregister
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
</refentry>

<!-- drivers/pnp/driver.c -->
<refentry id="API-pnp-add-id">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>July 2015</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>pnp_add_id</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.4.104</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>pnp_add_id</refname>
 <refpurpose>
  adds an EISA id to the specified device
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>struct pnp_id * <function>pnp_add_id </function></funcdef>
   <paramdef>struct pnp_dev * <parameter>dev</parameter></paramdef>
   <paramdef>const char * <parameter>id</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>dev</parameter></term>
   <listitem>
    <para>
     pointer to the desired device
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>id</parameter></term>
   <listitem>
    <para>
     pointer to an EISA id string
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
</refentry>

<!-- drivers/pnp/manager.c -->
<refentry id="API-pnp-start-dev">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>July 2015</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>pnp_start_dev</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.4.104</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>pnp_start_dev</refname>
 <refpurpose>
  low-level start of the PnP device
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>int <function>pnp_start_dev </function></funcdef>
   <paramdef>struct pnp_dev * <parameter>dev</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>dev</parameter></term>
   <listitem>
    <para>
     pointer to the desired device
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
<title>Description</title>
<para>
   assumes that resources have already been allocated
</para>
</refsect1>
</refentry>

<refentry id="API-pnp-stop-dev">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>July 2015</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>pnp_stop_dev</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.4.104</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>pnp_stop_dev</refname>
 <refpurpose>
     low-level disable of the PnP device
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>int <function>pnp_stop_dev </function></funcdef>
   <paramdef>struct pnp_dev * <parameter>dev</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>dev</parameter></term>
   <listitem>
    <para>
     pointer to the desired device
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
<title>Description</title>
<para>
   does not free resources
</para>
</refsect1>
</refentry>

<refentry id="API-pnp-activate-dev">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>July 2015</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>pnp_activate_dev</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.4.104</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>pnp_activate_dev</refname>
 <refpurpose>
     activates a PnP device for use
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>int <function>pnp_activate_dev </function></funcdef>
   <paramdef>struct pnp_dev * <parameter>dev</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>dev</parameter></term>
   <listitem>
    <para>
     pointer to the desired device
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
<title>Description</title>
<para>
   does not validate or set resources so be careful.
</para>
</refsect1>
</refentry>

<refentry id="API-pnp-disable-dev">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>July 2015</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>pnp_disable_dev</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.4.104</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>pnp_disable_dev</refname>
 <refpurpose>
     disables device
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>int <function>pnp_disable_dev </function></funcdef>
   <paramdef>struct pnp_dev * <parameter>dev</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>dev</parameter></term>
   <listitem>
    <para>
     pointer to the desired device
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
<title>Description</title>
<para>
   inform the correct pnp protocol so that resources can be used by other devices
</para>
</refsect1>
</refentry>

<!-- drivers/pnp/support.c -->
<refentry id="API-pnp-is-active">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>July 2015</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>pnp_is_active</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.4.104</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>pnp_is_active</refname>
 <refpurpose>
  Determines if a device is active based on its current resources
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>int <function>pnp_is_active </function></funcdef>
   <paramdef>struct pnp_dev * <parameter>dev</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>dev</parameter></term>
   <listitem>
    <para>
     pointer to the desired PnP device
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
</refentry>

     </sect1>
     <sect1><title>Userspace IO devices</title>
<!-- drivers/uio/uio.c -->
<refentry id="API-uio-event-notify">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>July 2015</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>uio_event_notify</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.4.104</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>uio_event_notify</refname>
 <refpurpose>
  trigger an interrupt event
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>void <function>uio_event_notify </function></funcdef>
   <paramdef>struct uio_info * <parameter>info</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>info</parameter></term>
   <listitem>
    <para>
     UIO device capabilities
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
</refentry>

<refentry id="API---uio-register-device">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>July 2015</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>__uio_register_device</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.4.104</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>__uio_register_device</refname>
 <refpurpose>
     register a new userspace IO device
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>int <function>__uio_register_device </function></funcdef>
   <paramdef>struct module * <parameter>owner</parameter></paramdef>
   <paramdef>struct device * <parameter>parent</parameter></paramdef>
   <paramdef>struct uio_info * <parameter>info</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>owner</parameter></term>
   <listitem>
    <para>
     module that creates the new device
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>parent</parameter></term>
   <listitem>
    <para>
     parent device
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>info</parameter></term>
   <listitem>
    <para>
     UIO device capabilities
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
<title>Description</title>
<para>
   returns zero on success or a negative error code.
</para>
</refsect1>
</refentry>

<refentry id="API-uio-unregister-device">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>July 2015</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>uio_unregister_device</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.4.104</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>uio_unregister_device</refname>
 <refpurpose>
     unregister a industrial IO device
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>void <function>uio_unregister_device </function></funcdef>
   <paramdef>struct uio_info * <parameter>info</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>info</parameter></term>
   <listitem>
    <para>
     UIO device capabilities
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
</refentry>

<!-- include/linux/uio_driver.h -->
<refentry id="API-struct-uio-mem">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>July 2015</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>struct uio_mem</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.4.104</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>struct uio_mem</refname>
 <refpurpose>
  description of a UIO memory region
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <programlisting>
struct uio_mem {
  const char * name;
  phys_addr_t addr;
  unsigned long size;
  int memtype;
  void __iomem * internal_addr;
  struct uio_map * map;
};  </programlisting>
</refsynopsisdiv>
 <refsect1>
  <title>Members</title>
  <variablelist>
    <varlistentry>      <term>name</term>
      <listitem><para>
name of the memory region for identification
      </para></listitem>
    </varlistentry>
    <varlistentry>      <term>addr</term>
      <listitem><para>
address of the device's memory (phys_addr is used since
addr can be logical, virtual, or physical &amp; phys_addr_t
should always be large enough to handle any of the
address types)
      </para></listitem>
    </varlistentry>
    <varlistentry>      <term>size</term>
      <listitem><para>
size of IO
      </para></listitem>
    </varlistentry>
    <varlistentry>      <term>memtype</term>
      <listitem><para>
type of memory addr points to
      </para></listitem>
    </varlistentry>
    <varlistentry>      <term>internal_addr</term>
      <listitem><para>
ioremap-ped version of addr, for driver internal use
      </para></listitem>
    </varlistentry>
    <varlistentry>      <term>map</term>
      <listitem><para>
for use by the UIO core only.
      </para></listitem>
    </varlistentry>
  </variablelist>
 </refsect1>
</refentry>

<refentry id="API-struct-uio-port">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>July 2015</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>struct uio_port</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.4.104</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>struct uio_port</refname>
 <refpurpose>
     description of a UIO port region
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <programlisting>
struct uio_port {
  const char * name;
  unsigned long start;
  unsigned long size;
  int porttype;
  struct uio_portio * portio;
};  </programlisting>
</refsynopsisdiv>
 <refsect1>
  <title>Members</title>
  <variablelist>
    <varlistentry>      <term>name</term>
      <listitem><para>
   name of the port region for identification
      </para></listitem>
    </varlistentry>
    <varlistentry>      <term>start</term>
      <listitem><para>
   start of port region
      </para></listitem>
    </varlistentry>
    <varlistentry>      <term>size</term>
      <listitem><para>
   size of port region
      </para></listitem>
    </varlistentry>
    <varlistentry>      <term>porttype</term>
      <listitem><para>
   type of port (see UIO_PORT_* below)
      </para></listitem>
    </varlistentry>
    <varlistentry>      <term>portio</term>
      <listitem><para>
   for use by the UIO core only.
      </para></listitem>
    </varlistentry>
  </variablelist>
 </refsect1>
</refentry>

<refentry id="API-struct-uio-info">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>July 2015</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>struct uio_info</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.4.104</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>struct uio_info</refname>
 <refpurpose>
     UIO device capabilities
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <programlisting>
struct uio_info {
  struct uio_device * uio_dev;
  const char * name;
  const char * version;
  struct uio_mem mem[MAX_UIO_MAPS];
  struct uio_port port[MAX_UIO_PORT_REGIONS];
  long irq;
  unsigned long irq_flags;
  void * priv;
  irqreturn_t (* handler) (int irq, struct uio_info *dev_info);
  int (* mmap) (struct uio_info *info, struct vm_area_struct *vma);
  int (* open) (struct uio_info *info, struct inode *inode);
  int (* release) (struct uio_info *info, struct inode *inode);
  int (* irqcontrol) (struct uio_info *info, s32 irq_on);
};  </programlisting>
</refsynopsisdiv>
 <refsect1>
  <title>Members</title>
  <variablelist>
    <varlistentry>      <term>uio_dev</term>
      <listitem><para>
   the UIO device this info belongs to
      </para></listitem>
    </varlistentry>
    <varlistentry>      <term>name</term>
      <listitem><para>
   device name
      </para></listitem>
    </varlistentry>
    <varlistentry>      <term>version</term>
      <listitem><para>
   device driver version
      </para></listitem>
    </varlistentry>
    <varlistentry>      <term>mem[MAX_UIO_MAPS]</term>
      <listitem><para>
   list of mappable memory regions, size==0 for end of list
      </para></listitem>
    </varlistentry>
    <varlistentry>      <term>port[MAX_UIO_PORT_REGIONS]</term>
      <listitem><para>
   list of port regions, size==0 for end of list
      </para></listitem>
    </varlistentry>
    <varlistentry>      <term>irq</term>
      <listitem><para>
   interrupt number or UIO_IRQ_CUSTOM
      </para></listitem>
    </varlistentry>
    <varlistentry>      <term>irq_flags</term>
      <listitem><para>
   flags for <function>request_irq</function>
      </para></listitem>
    </varlistentry>
    <varlistentry>      <term>priv</term>
      <listitem><para>
   optional private data
      </para></listitem>
    </varlistentry>
    <varlistentry>      <term>handler</term>
      <listitem><para>
   the device's irq handler
      </para></listitem>
    </varlistentry>
    <varlistentry>      <term>mmap</term>
      <listitem><para>
   mmap operation for this uio device
      </para></listitem>
    </varlistentry>
    <varlistentry>      <term>open</term>
      <listitem><para>
   open operation for this uio device
      </para></listitem>
    </varlistentry>
    <varlistentry>      <term>release</term>
      <listitem><para>
   release operation for this uio device
      </para></listitem>
    </varlistentry>
    <varlistentry>      <term>irqcontrol</term>
      <listitem><para>
   disable/enable irqs when 0/1 is written to /dev/uioX
      </para></listitem>
    </varlistentry>
  </variablelist>
 </refsect1>
</refentry>

     </sect1>
  </chapter>

  <chapter id="parportdev">
     <title>Parallel Port Devices</title>
<!-- include/linux/parport.h -->
<refentry id="API-parport-yield">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>July 2015</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>parport_yield</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.4.104</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>parport_yield</refname>
 <refpurpose>
  relinquish a parallel port temporarily
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>int <function>parport_yield </function></funcdef>
   <paramdef>struct pardevice * <parameter>dev</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>dev</parameter></term>
   <listitem>
    <para>
     a device on the parallel port
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
<title>Description</title>
<para>
   This function relinquishes the port if it would be helpful to other
   drivers to do so.  Afterwards it tries to reclaim the port using
   <function>parport_claim</function>, and the return value is the same as for
   <function>parport_claim</function>.  If it fails, the port is left unclaimed and it is
   the driver's responsibility to reclaim the port.
   </para><para>

   The <function>parport_yield</function> and <function>parport_yield_blocking</function> functions are for
   marking points in the driver at which other drivers may claim the
   port and use their devices.  Yielding the port is similar to
   releasing it and reclaiming it, but is more efficient because no
   action is taken if there are no other devices needing the port.  In
   fact, nothing is done even if there are other devices waiting but
   the current device is still within its <quote>timeslice</quote>.  The default
   timeslice is half a second, but it can be adjusted via the /proc
   interface.
</para>
</refsect1>
</refentry>

<refentry id="API-parport-yield-blocking">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>July 2015</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>parport_yield_blocking</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.4.104</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>parport_yield_blocking</refname>
 <refpurpose>
     relinquish a parallel port temporarily
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>int <function>parport_yield_blocking </function></funcdef>
   <paramdef>struct pardevice * <parameter>dev</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>dev</parameter></term>
   <listitem>
    <para>
     a device on the parallel port
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
<title>Description</title>
<para>
   This function relinquishes the port if it would be helpful to other
   drivers to do so.  Afterwards it tries to reclaim the port using
   <function>parport_claim_or_block</function>, and the return value is the same as for
   <function>parport_claim_or_block</function>.
</para>
</refsect1>
</refentry>

<!-- drivers/parport/ieee1284.c -->
<refentry id="API-parport-wait-event">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>July 2015</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>parport_wait_event</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.4.104</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>parport_wait_event</refname>
 <refpurpose>
  wait for an event on a parallel port
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>int <function>parport_wait_event </function></funcdef>
   <paramdef>struct parport * <parameter>port</parameter></paramdef>
   <paramdef>signed long <parameter>timeout</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>port</parameter></term>
   <listitem>
    <para>
     port to wait on
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>timeout</parameter></term>
   <listitem>
    <para>
     time to wait (in jiffies)
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
<title>Description</title>
<para>
   This function waits for up to <parameter>timeout</parameter> jiffies for an
   interrupt to occur on a parallel port.  If the port timeout is
   set to zero, it returns immediately.
   </para><para>

   If an interrupt occurs before the timeout period elapses, this
   function returns zero immediately.  If it times out, it returns
   one.  An error code less than zero indicates an error (most
   likely a pending signal), and the calling code should finish
   what it's doing as soon as it can.
</para>
</refsect1>
</refentry>

<refentry id="API-parport-wait-peripheral">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>July 2015</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>parport_wait_peripheral</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.4.104</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>parport_wait_peripheral</refname>
 <refpurpose>
     wait for status lines to change in 35ms
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>int <function>parport_wait_peripheral </function></funcdef>
   <paramdef>struct parport * <parameter>port</parameter></paramdef>
   <paramdef>unsigned char <parameter>mask</parameter></paramdef>
   <paramdef>unsigned char <parameter>result</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>port</parameter></term>
   <listitem>
    <para>
     port to watch
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>mask</parameter></term>
   <listitem>
    <para>
     status lines to watch
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>result</parameter></term>
   <listitem>
    <para>
     desired values of chosen status lines
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
<title>Description</title>
<para>
   This function waits until the masked status lines have the
   desired values, or until 35ms have elapsed (see IEEE 1284-1994
   page 24 to 25 for why this value in particular is hardcoded).
   The <parameter>mask</parameter> and <parameter>result</parameter> parameters are bitmasks, with the bits
   defined by the constants in parport.h: <constant>PARPORT_STATUS_BUSY</constant>,
   and so on.
   </para><para>

   The port is polled quickly to start off with, in anticipation
   of a fast response from the peripheral.  This fast polling
   time is configurable (using /proc), and defaults to 500usec.
   If the timeout for this port (see <function>parport_set_timeout</function>) is
   zero, the fast polling time is 35ms, and this function does
   not call <function>schedule</function>.
   </para><para>

   If the timeout for this port is non-zero, after the fast
   polling fails it uses <function>parport_wait_event</function> to wait for up to
   10ms, waking up if an interrupt occurs.
</para>
</refsect1>
</refentry>

<refentry id="API-parport-negotiate">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>July 2015</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>parport_negotiate</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.4.104</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>parport_negotiate</refname>
 <refpurpose>
     negotiate an IEEE 1284 mode
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>int <function>parport_negotiate </function></funcdef>
   <paramdef>struct parport * <parameter>port</parameter></paramdef>
   <paramdef>int <parameter>mode</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>port</parameter></term>
   <listitem>
    <para>
     port to use
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>mode</parameter></term>
   <listitem>
    <para>
     mode to negotiate to
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
<title>Description</title>
<para>
   Use this to negotiate to a particular IEEE 1284 transfer mode.
   The <parameter>mode</parameter> parameter should be one of the constants in
   parport.h starting <constant>IEEE1284_MODE_xxx</constant>.
   </para><para>

   The return value is 0 if the peripheral has accepted the
   negotiation to the mode specified, -1 if the peripheral is not
   IEEE 1284 compliant (or not present), or 1 if the peripheral
   has rejected the negotiation.
</para>
</refsect1>
</refentry>

<refentry id="API-parport-write">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>July 2015</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>parport_write</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.4.104</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>parport_write</refname>
 <refpurpose>
     write a block of data to a parallel port
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>ssize_t <function>parport_write </function></funcdef>
   <paramdef>struct parport * <parameter>port</parameter></paramdef>
   <paramdef>const void * <parameter>buffer</parameter></paramdef>
   <paramdef>size_t <parameter>len</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>port</parameter></term>
   <listitem>
    <para>
     port to write to
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>buffer</parameter></term>
   <listitem>
    <para>
     data buffer (in kernel space)
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>len</parameter></term>
   <listitem>
    <para>
     number of bytes of data to transfer
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
<title>Description</title>
<para>
   This will write up to <parameter>len</parameter> bytes of <parameter>buffer</parameter> to the port
   specified, using the IEEE 1284 transfer mode most recently
   negotiated to (using <function>parport_negotiate</function>), as long as that
   mode supports forward transfers (host to peripheral).
   </para><para>

   It is the caller's responsibility to ensure that the first
   <parameter>len</parameter> bytes of <parameter>buffer</parameter> are valid.
   </para><para>

   This function returns the number of bytes transferred (if zero
   or positive), or else an error code.
</para>
</refsect1>
</refentry>

<refentry id="API-parport-read">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>July 2015</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>parport_read</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.4.104</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>parport_read</refname>
 <refpurpose>
     read a block of data from a parallel port
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>ssize_t <function>parport_read </function></funcdef>
   <paramdef>struct parport * <parameter>port</parameter></paramdef>
   <paramdef>void * <parameter>buffer</parameter></paramdef>
   <paramdef>size_t <parameter>len</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>port</parameter></term>
   <listitem>
    <para>
     port to read from
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>buffer</parameter></term>
   <listitem>
    <para>
     data buffer (in kernel space)
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>len</parameter></term>
   <listitem>
    <para>
     number of bytes of data to transfer
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
<title>Description</title>
<para>
   This will read up to <parameter>len</parameter> bytes of <parameter>buffer</parameter> to the port
   specified, using the IEEE 1284 transfer mode most recently
   negotiated to (using <function>parport_negotiate</function>), as long as that
   mode supports reverse transfers (peripheral to host).
   </para><para>

   It is the caller's responsibility to ensure that the first
   <parameter>len</parameter> bytes of <parameter>buffer</parameter> are available to write to.
   </para><para>

   This function returns the number of bytes transferred (if zero
   or positive), or else an error code.
</para>
</refsect1>
</refentry>

<refentry id="API-parport-set-timeout">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>July 2015</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>parport_set_timeout</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.4.104</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>parport_set_timeout</refname>
 <refpurpose>
     set the inactivity timeout for a device
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>long <function>parport_set_timeout </function></funcdef>
   <paramdef>struct pardevice * <parameter>dev</parameter></paramdef>
   <paramdef>long <parameter>inactivity</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>dev</parameter></term>
   <listitem>
    <para>
     device on a port
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>inactivity</parameter></term>
   <listitem>
    <para>
     inactivity timeout (in jiffies)
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
<title>Description</title>
<para>
   This sets the inactivity timeout for a particular device on a
   port.  This affects functions like <function>parport_wait_peripheral</function>.
   The special value 0 means not to call <function>schedule</function> while dealing
   with this device.
   </para><para>

   The return value is the previous inactivity timeout.
   </para><para>

   Any callers of <function>parport_wait_event</function> for this device are woken
   up.
</para>
</refsect1>
</refentry>

<!-- drivers/parport/share.c -->
<refentry id="API-parport-register-driver">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>July 2015</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>parport_register_driver</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.4.104</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>parport_register_driver</refname>
 <refpurpose>
  register a parallel port device driver
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>int <function>parport_register_driver </function></funcdef>
   <paramdef>struct parport_driver * <parameter>drv</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>drv</parameter></term>
   <listitem>
    <para>
     structure describing the driver
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
<title>Description</title>
<para>
   This can be called by a parallel port device driver in order
   to receive notifications about ports being found in the
   system, as well as ports no longer available.
   </para><para>

   The <parameter>drv</parameter> structure is allocated by the caller and must not be
   deallocated until after calling <function>parport_unregister_driver</function>.
   </para><para>

   The driver's <function>attach</function> function may block.  The port that
   <function>attach</function> is given will be valid for the duration of the
   callback, but if the driver wants to take a copy of the
   pointer it must call <function>parport_get_port</function> to do so.  Calling
   <function>parport_register_device</function> on that port will do this for you.
   </para><para>

   The driver's <function>detach</function> function may block.  The port that
   <function>detach</function> is given will be valid for the duration of the
   callback, but if the driver wants to take a copy of the
   pointer it must call <function>parport_get_port</function> to do so.
   </para><para>

   Returns 0 on success.  Currently it always succeeds.
</para>
</refsect1>
</refentry>

<refentry id="API-parport-unregister-driver">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>July 2015</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>parport_unregister_driver</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.4.104</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>parport_unregister_driver</refname>
 <refpurpose>
     deregister a parallel port device driver
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>void <function>parport_unregister_driver </function></funcdef>
   <paramdef>struct parport_driver * <parameter>drv</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>drv</parameter></term>
   <listitem>
    <para>
     structure describing the driver that was given to
     <function>parport_register_driver</function>
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
<title>Description</title>
<para>
   This should be called by a parallel port device driver that
   has registered itself using <function>parport_register_driver</function> when it
   is about to be unloaded.
   </para><para>

   When it returns, the driver's <function>attach</function> routine will no longer
   be called, and for each port that <function>attach</function> was called for, the
   <function>detach</function> routine will have been called.
   </para><para>

   All the driver's <function>attach</function> and <function>detach</function> calls are guaranteed to have
   finished by the time this function returns.
</para>
</refsect1>
</refentry>

<refentry id="API-parport-get-port">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>July 2015</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>parport_get_port</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.4.104</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>parport_get_port</refname>
 <refpurpose>
     increment a port's reference count
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>struct parport * <function>parport_get_port </function></funcdef>
   <paramdef>struct parport * <parameter>port</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>port</parameter></term>
   <listitem>
    <para>
     the port
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
<title>Description</title>
<para>
   This ensures that a struct parport pointer remains valid
   until the matching <function>parport_put_port</function> call.
</para>
</refsect1>
</refentry>

<refentry id="API-parport-put-port">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>July 2015</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>parport_put_port</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.4.104</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>parport_put_port</refname>
 <refpurpose>
     decrement a port's reference count
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>void <function>parport_put_port </function></funcdef>
   <paramdef>struct parport * <parameter>port</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>port</parameter></term>
   <listitem>
    <para>
     the port
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
<title>Description</title>
<para>
   This should be called once for each call to <function>parport_get_port</function>,
   once the port is no longer needed.
</para>
</refsect1>
</refentry>

<refentry id="API-parport-register-port">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>July 2015</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>parport_register_port</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.4.104</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>parport_register_port</refname>
 <refpurpose>
     register a parallel port
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>struct parport * <function>parport_register_port </function></funcdef>
   <paramdef>unsigned long <parameter>base</parameter></paramdef>
   <paramdef>int <parameter>irq</parameter></paramdef>
   <paramdef>int <parameter>dma</parameter></paramdef>
   <paramdef>struct parport_operations * <parameter>ops</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>base</parameter></term>
   <listitem>
    <para>
     base I/O address
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>irq</parameter></term>
   <listitem>
    <para>
     IRQ line
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>dma</parameter></term>
   <listitem>
    <para>
     DMA channel
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>ops</parameter></term>
   <listitem>
    <para>
     pointer to the port driver's port operations structure
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
<title>Description</title>
<para>
   When a parallel port (lowlevel) driver finds a port that
   should be made available to parallel port device drivers, it
   should call <function>parport_register_port</function>.  The <parameter>base</parameter>, <parameter>irq</parameter>, and
   <parameter>dma</parameter> parameters are for the convenience of port drivers, and
   for ports where they aren't meaningful needn't be set to
   anything special.  They can be altered afterwards by adjusting
   the relevant members of the parport structure that is returned
   and represents the port.  They should not be tampered with
   after calling parport_announce_port, however.
   </para><para>

   If there are parallel port device drivers in the system that
   have registered themselves using <function>parport_register_driver</function>,
   they are not told about the port at this time; that is done by
   <function>parport_announce_port</function>.
   </para><para>

   The <parameter>ops</parameter> structure is allocated by the caller, and must not be
   deallocated before calling <function>parport_remove_port</function>.
   </para><para>

   If there is no memory to allocate a new parport structure,
   this function will return <constant>NULL</constant>.
</para>
</refsect1>
</refentry>

<refentry id="API-parport-announce-port">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>July 2015</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>parport_announce_port</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.4.104</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>parport_announce_port</refname>
 <refpurpose>
     tell device drivers about a parallel port
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>void <function>parport_announce_port </function></funcdef>
   <paramdef>struct parport * <parameter>port</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>port</parameter></term>
   <listitem>
    <para>
     parallel port to announce
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
<title>Description</title>
<para>
   After a port driver has registered a parallel port with
   parport_register_port, and performed any necessary
   initialisation or adjustments, it should call
   <function>parport_announce_port</function> in order to notify all device drivers
   that have called <function>parport_register_driver</function>.  Their <function>attach</function>
   functions will be called, with <parameter>port</parameter> as the parameter.
</para>
</refsect1>
</refentry>

<refentry id="API-parport-remove-port">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>July 2015</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>parport_remove_port</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.4.104</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>parport_remove_port</refname>
 <refpurpose>
     deregister a parallel port
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>void <function>parport_remove_port </function></funcdef>
   <paramdef>struct parport * <parameter>port</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>port</parameter></term>
   <listitem>
    <para>
     parallel port to deregister
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
<title>Description</title>
<para>
   When a parallel port driver is forcibly unloaded, or a
   parallel port becomes inaccessible, the port driver must call
   this function in order to deal with device drivers that still
   want to use it.
   </para><para>

   The parport structure associated with the port has its
   operations structure replaced with one containing 'null'
   operations that return errors or just don't do anything.
   </para><para>

   Any drivers that have registered themselves using
   <function>parport_register_driver</function> are notified that the port is no
   longer accessible by having their <function>detach</function> routines called
   with <parameter>port</parameter> as the parameter.
</para>
</refsect1>
</refentry>

<refentry id="API-parport-register-device">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>July 2015</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>parport_register_device</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.4.104</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>parport_register_device</refname>
 <refpurpose>
     register a device on a parallel port
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>struct pardevice * <function>parport_register_device </function></funcdef>
   <paramdef>struct parport * <parameter>port</parameter></paramdef>
   <paramdef>const char * <parameter>name</parameter></paramdef>
   <paramdef>int (*<parameter>pf</parameter>)
     <funcparams>void *</funcparams></paramdef>
   <paramdef>void (*<parameter>kf</parameter>)
     <funcparams>void *</funcparams></paramdef>
   <paramdef>void (*<parameter>irq_func</parameter>)
     <funcparams>void *</funcparams></paramdef>
   <paramdef>int <parameter>flags</parameter></paramdef>
   <paramdef>void * <parameter>handle</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>port</parameter></term>
   <listitem>
    <para>
     port to which the device is attached
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>name</parameter></term>
   <listitem>
    <para>
     a name to refer to the device
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>pf</parameter></term>
   <listitem>
    <para>
     preemption callback
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>kf</parameter></term>
   <listitem>
    <para>
     kick callback (wake-up)
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>irq_func</parameter></term>
   <listitem>
    <para>
     interrupt handler
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>flags</parameter></term>
   <listitem>
    <para>
     registration flags
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>handle</parameter></term>
   <listitem>
    <para>
     data for callback functions
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
<title>Description</title>
<para>
   This function, called by parallel port device drivers,
   declares that a device is connected to a port, and tells the
   system all it needs to know.
   </para><para>

   The <parameter>name</parameter> is allocated by the caller and must not be
   deallocated until the caller calls <parameter>parport_unregister_device</parameter>
   for that device.
   </para><para>

   The preemption callback function, <parameter>pf</parameter>, is called when this
   device driver has claimed access to the port but another
   device driver wants to use it.  It is given <parameter>handle</parameter> as its
   parameter, and should return zero if it is willing for the
   system to release the port to another driver on its behalf.
   If it wants to keep control of the port it should return
   non-zero, and no action will be taken.  It is good manners for
   the driver to try to release the port at the earliest
   opportunity after its preemption callback rejects a preemption
   attempt.  Note that if a preemption callback is happy for
   preemption to go ahead, there is no need to release the port;
   it is done automatically.  This function may not block, as it
   may be called from interrupt context.  If the device driver
   does not support preemption, <parameter>pf</parameter> can be <constant>NULL</constant>.
   </para><para>

   The wake-up (<quote>kick</quote>) callback function, <parameter>kf</parameter>, is called when
   the port is available to be claimed for exclusive access; that
   is, <function>parport_claim</function> is guaranteed to succeed when called from
   inside the wake-up callback function.  If the driver wants to
   claim the port it should do so; otherwise, it need not take
   any action.  This function may not block, as it may be called
   from interrupt context.  If the device driver does not want to
   be explicitly invited to claim the port in this way, <parameter>kf</parameter> can
   be <constant>NULL</constant>.
   </para><para>

   The interrupt handler, <parameter>irq_func</parameter>, is called when an interrupt
   arrives from the parallel port.  Note that if a device driver
   wants to use interrupts it should use <function>parport_enable_irq</function>,
   and can also check the irq member of the parport structure
   representing the port.
   </para><para>

   The parallel port (lowlevel) driver is the one that has called
   <function>request_irq</function> and whose interrupt handler is called first.
   This handler does whatever needs to be done to the hardware to
   acknowledge the interrupt (for PC-style ports there is nothing
   special to be done).  It then tells the IEEE 1284 code about
   the interrupt, which may involve reacting to an IEEE 1284
   event depending on the current IEEE 1284 phase.  After this,
   it calls <parameter>irq_func</parameter>.  Needless to say, <parameter>irq_func</parameter> will be called
   from interrupt context, and may not block.
   </para><para>

   The <constant>PARPORT_DEV_EXCL</constant> flag is for preventing port sharing, and
   so should only be used when sharing the port with other device
   drivers is impossible and would lead to incorrect behaviour.
   Use it sparingly!  Normally, <parameter>flags</parameter> will be zero.
   </para><para>

   This function returns a pointer to a structure that represents
   the device on the port, or <constant>NULL</constant> if there is not enough memory
   to allocate space for that structure.
</para>
</refsect1>
</refentry>

<refentry id="API-parport-unregister-device">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>July 2015</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>parport_unregister_device</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.4.104</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>parport_unregister_device</refname>
 <refpurpose>
     deregister a device on a parallel port
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>void <function>parport_unregister_device </function></funcdef>
   <paramdef>struct pardevice * <parameter>dev</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>dev</parameter></term>
   <listitem>
    <para>
     pointer to structure representing device
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
<title>Description</title>
<para>
   This undoes the effect of <function>parport_register_device</function>.
</para>
</refsect1>
</refentry>

<refentry id="API-parport-find-number">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>July 2015</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>parport_find_number</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.4.104</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>parport_find_number</refname>
 <refpurpose>
     find a parallel port by number
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>struct parport * <function>parport_find_number </function></funcdef>
   <paramdef>int <parameter>number</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>number</parameter></term>
   <listitem>
    <para>
     parallel port number
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
<title>Description</title>
<para>
   This returns the parallel port with the specified number, or
   <constant>NULL</constant> if there is none.
   </para><para>

   There is an implicit <function>parport_get_port</function> done already; to throw
   away the reference to the port that <function>parport_find_number</function>
   gives you, use <function>parport_put_port</function>.
</para>
</refsect1>
</refentry>

<refentry id="API-parport-find-base">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>July 2015</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>parport_find_base</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.4.104</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>parport_find_base</refname>
 <refpurpose>
     find a parallel port by base address
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>struct parport * <function>parport_find_base </function></funcdef>
   <paramdef>unsigned long <parameter>base</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>base</parameter></term>
   <listitem>
    <para>
     base I/O address
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
<title>Description</title>
<para>
   This returns the parallel port with the specified base
   address, or <constant>NULL</constant> if there is none.
   </para><para>

   There is an implicit <function>parport_get_port</function> done already; to throw
   away the reference to the port that <function>parport_find_base</function>
   gives you, use <function>parport_put_port</function>.
</para>
</refsect1>
</refentry>

<refentry id="API-parport-claim">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>July 2015</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>parport_claim</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.4.104</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>parport_claim</refname>
 <refpurpose>
     claim access to a parallel port device
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>int <function>parport_claim </function></funcdef>
   <paramdef>struct pardevice * <parameter>dev</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>dev</parameter></term>
   <listitem>
    <para>
     pointer to structure representing a device on the port
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
<title>Description</title>
<para>
   This function will not block and so can be used from interrupt
   context.  If <function>parport_claim</function> succeeds in claiming access to
   the port it returns zero and the port is available to use.  It
   may fail (returning non-zero) if the port is in use by another
   driver and that driver is not willing to relinquish control of
   the port.
</para>
</refsect1>
</refentry>

<refentry id="API-parport-claim-or-block">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>July 2015</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>parport_claim_or_block</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.4.104</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>parport_claim_or_block</refname>
 <refpurpose>
     claim access to a parallel port device
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>int <function>parport_claim_or_block </function></funcdef>
   <paramdef>struct pardevice * <parameter>dev</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>dev</parameter></term>
   <listitem>
    <para>
     pointer to structure representing a device on the port
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
<title>Description</title>
<para>
   This behaves like <function>parport_claim</function>, but will block if necessary
   to wait for the port to be free.  A return value of 1
   indicates that it slept; 0 means that it succeeded without
   needing to sleep.  A negative error code indicates failure.
</para>
</refsect1>
</refentry>

<refentry id="API-parport-release">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>July 2015</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>parport_release</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.4.104</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>parport_release</refname>
 <refpurpose>
     give up access to a parallel port device
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>void <function>parport_release </function></funcdef>
   <paramdef>struct pardevice * <parameter>dev</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>dev</parameter></term>
   <listitem>
    <para>
     pointer to structure representing parallel port device
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
<title>Description</title>
<para>
   This function cannot fail, but it should not be called without
   the port claimed.  Similarly, if the port is already claimed
   you should not try claiming it again.
</para>
</refsect1>
</refentry>

<!-- drivers/parport/daisy.c -->
<refentry id="API-parport-open">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>July 2015</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>parport_open</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.4.104</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>parport_open</refname>
 <refpurpose>
  find a device by canonical device number
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>struct pardevice * <function>parport_open </function></funcdef>
   <paramdef>int <parameter>devnum</parameter></paramdef>
   <paramdef>const char * <parameter>name</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>devnum</parameter></term>
   <listitem>
    <para>
     canonical device number
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>name</parameter></term>
   <listitem>
    <para>
     name to associate with the device
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
<title>Description</title>
<para>
   This function is similar to <function>parport_register_device</function>, except
   that it locates a device by its number rather than by the port
   it is attached to.
   </para><para>

   All parameters except for <parameter>devnum</parameter> are the same as for
   <function>parport_register_device</function>.  The return value is the same as
   for <function>parport_register_device</function>.
</para>
</refsect1>
</refentry>

<refentry id="API-parport-close">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>July 2015</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>parport_close</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.4.104</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>parport_close</refname>
 <refpurpose>
     close a device opened with <function>parport_open</function>
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>void <function>parport_close </function></funcdef>
   <paramdef>struct pardevice * <parameter>dev</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>dev</parameter></term>
   <listitem>
    <para>
     device to close
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
<title>Description</title>
<para>
   This is to <function>parport_open</function> as <function>parport_unregister_device</function> is to
   <function>parport_register_device</function>.
</para>
</refsect1>
</refentry>

  </chapter>

  <chapter id="message_devices">
	<title>Message-based devices</title>
     <sect1><title>Fusion message devices</title>
<!-- drivers/message/fusion/mptbase.c -->
<refentry id="API-mpt-register">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>July 2015</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>mpt_register</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.4.104</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>mpt_register</refname>
 <refpurpose>
  Register protocol-specific main callback handler.
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>u8 <function>mpt_register </function></funcdef>
   <paramdef>MPT_CALLBACK <parameter>cbfunc</parameter></paramdef>
   <paramdef>MPT_DRIVER_CLASS <parameter>dclass</parameter></paramdef>
   <paramdef>char * <parameter>func_name</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>cbfunc</parameter></term>
   <listitem>
    <para>
     callback function pointer
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>dclass</parameter></term>
   <listitem>
    <para>
     Protocol driver's class (<constant>MPT_DRIVER_CLASS</constant> enum value)
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>func_name</parameter></term>
   <listitem>
    <para>
     call function's name
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
<title>Description</title>
<para>
   This routine is called by a protocol-specific driver (SCSI host,
   LAN, SCSI target) to register its reply callback routine.  Each
   protocol-specific driver must do this before it will be able to
   use any IOC resources, such as obtaining request frames.
</para>
</refsect1>
<refsect1>
<title>NOTES</title>
<para>
   The SCSI protocol driver currently calls this routine thrice
   in order to register separate callbacks; one for <quote>normal</quote> SCSI IO;
   one for MptScsiTaskMgmt requests; one for Scan/DV requests.
   </para><para>

   Returns u8 valued <quote>handle</quote> in the range (and S.O.D. order)
   {N,...,7,6,5,...,1} if successful.
   A return value of MPT_MAX_PROTOCOL_DRIVERS (including zero!) should be
   considered an error by the caller.
</para>
</refsect1>
</refentry>

<refentry id="API-mpt-deregister">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>July 2015</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>mpt_deregister</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.4.104</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>mpt_deregister</refname>
 <refpurpose>
     Deregister a protocol drivers resources.
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>void <function>mpt_deregister </function></funcdef>
   <paramdef>u8 <parameter>cb_idx</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>cb_idx</parameter></term>
   <listitem>
    <para>
     previously registered callback handle
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
<title>Description</title>
<para>
   Each protocol-specific driver should call this routine when its
   module is unloaded.
</para>
</refsect1>
</refentry>

<refentry id="API-mpt-event-register">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>July 2015</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>mpt_event_register</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.4.104</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>mpt_event_register</refname>
 <refpurpose>
     Register protocol-specific event callback handler.
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>int <function>mpt_event_register </function></funcdef>
   <paramdef>u8 <parameter>cb_idx</parameter></paramdef>
   <paramdef>MPT_EVHANDLER <parameter>ev_cbfunc</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>cb_idx</parameter></term>
   <listitem>
    <para>
     previously registered (via mpt_register) callback handle
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>ev_cbfunc</parameter></term>
   <listitem>
    <para>
     callback function
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
<title>Description</title>
<para>
   This routine can be called by one or more protocol-specific drivers
   if/when they choose to be notified of MPT events.
   </para><para>

   Returns 0 for success.
</para>
</refsect1>
</refentry>

<refentry id="API-mpt-event-deregister">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>July 2015</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>mpt_event_deregister</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.4.104</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>mpt_event_deregister</refname>
 <refpurpose>
     Deregister protocol-specific event callback handler
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>void <function>mpt_event_deregister </function></funcdef>
   <paramdef>u8 <parameter>cb_idx</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>cb_idx</parameter></term>
   <listitem>
    <para>
     previously registered callback handle
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
<title>Description</title>
<para>
   Each protocol-specific driver should call this routine
   when it does not (or can no longer) handle events,
   or when its module is unloaded.
</para>
</refsect1>
</refentry>

<refentry id="API-mpt-reset-register">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>July 2015</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>mpt_reset_register</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.4.104</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>mpt_reset_register</refname>
 <refpurpose>
     Register protocol-specific IOC reset handler.
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>int <function>mpt_reset_register </function></funcdef>
   <paramdef>u8 <parameter>cb_idx</parameter></paramdef>
   <paramdef>MPT_RESETHANDLER <parameter>reset_func</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>cb_idx</parameter></term>
   <listitem>
    <para>
     previously registered (via mpt_register) callback handle
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>reset_func</parameter></term>
   <listitem>
    <para>
     reset function
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
<title>Description</title>
<para>
   This routine can be called by one or more protocol-specific drivers
   if/when they choose to be notified of IOC resets.
   </para><para>

   Returns 0 for success.
</para>
</refsect1>
</refentry>

<refentry id="API-mpt-reset-deregister">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>July 2015</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>mpt_reset_deregister</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.4.104</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>mpt_reset_deregister</refname>
 <refpurpose>
     Deregister protocol-specific IOC reset handler.
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>void <function>mpt_reset_deregister </function></funcdef>
   <paramdef>u8 <parameter>cb_idx</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>cb_idx</parameter></term>
   <listitem>
    <para>
     previously registered callback handle
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
<title>Description</title>
<para>
   Each protocol-specific driver should call this routine
   when it does not (or can no longer) handle IOC reset handling,
   or when its module is unloaded.
</para>
</refsect1>
</refentry>

<refentry id="API-mpt-device-driver-register">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>July 2015</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>mpt_device_driver_register</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.4.104</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>mpt_device_driver_register</refname>
 <refpurpose>
     Register device driver hooks
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>int <function>mpt_device_driver_register </function></funcdef>
   <paramdef>struct mpt_pci_driver * <parameter>dd_cbfunc</parameter></paramdef>
   <paramdef>u8 <parameter>cb_idx</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>dd_cbfunc</parameter></term>
   <listitem>
    <para>
     driver callbacks struct
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>cb_idx</parameter></term>
   <listitem>
    <para>
     MPT protocol driver index
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
</refentry>

<refentry id="API-mpt-device-driver-deregister">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>July 2015</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>mpt_device_driver_deregister</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.4.104</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>mpt_device_driver_deregister</refname>
 <refpurpose>
     DeRegister device driver hooks
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>void <function>mpt_device_driver_deregister </function></funcdef>
   <paramdef>u8 <parameter>cb_idx</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>cb_idx</parameter></term>
   <listitem>
    <para>
     MPT protocol driver index
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
</refentry>

<refentry id="API-mpt-get-msg-frame">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>July 2015</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>mpt_get_msg_frame</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.4.104</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>mpt_get_msg_frame</refname>
 <refpurpose>
     Obtain an MPT request frame from the pool
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>MPT_FRAME_HDR* <function>mpt_get_msg_frame </function></funcdef>
   <paramdef>u8 <parameter>cb_idx</parameter></paramdef>
   <paramdef>MPT_ADAPTER * <parameter>ioc</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>cb_idx</parameter></term>
   <listitem>
    <para>
     Handle of registered MPT protocol driver
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>ioc</parameter></term>
   <listitem>
    <para>
     Pointer to MPT adapter structure
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
<title>Description</title>
<para>
   Obtain an MPT request frame from the pool (of 1024) that are
   allocated per MPT adapter.
   </para><para>

   Returns pointer to a MPT request frame or <constant>NULL</constant> if none are available
   or IOC is not active.
</para>
</refsect1>
</refentry>

<refentry id="API-mpt-put-msg-frame">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>July 2015</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>mpt_put_msg_frame</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.4.104</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>mpt_put_msg_frame</refname>
 <refpurpose>
     Send a protocol-specific MPT request frame to an IOC
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>void <function>mpt_put_msg_frame </function></funcdef>
   <paramdef>u8 <parameter>cb_idx</parameter></paramdef>
   <paramdef>MPT_ADAPTER * <parameter>ioc</parameter></paramdef>
   <paramdef>MPT_FRAME_HDR * <parameter>mf</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>cb_idx</parameter></term>
   <listitem>
    <para>
     Handle of registered MPT protocol driver
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>ioc</parameter></term>
   <listitem>
    <para>
     Pointer to MPT adapter structure
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>mf</parameter></term>
   <listitem>
    <para>
     Pointer to MPT request frame
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
<title>Description</title>
<para>
   This routine posts an MPT request frame to the request post FIFO of a
   specific MPT adapter.
</para>
</refsect1>
</refentry>

<refentry id="API-mpt-put-msg-frame-hi-pri">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>July 2015</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>mpt_put_msg_frame_hi_pri</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.4.104</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>mpt_put_msg_frame_hi_pri</refname>
 <refpurpose>
     Send a hi-pri protocol-specific MPT request frame
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>void <function>mpt_put_msg_frame_hi_pri </function></funcdef>
   <paramdef>u8 <parameter>cb_idx</parameter></paramdef>
   <paramdef>MPT_ADAPTER * <parameter>ioc</parameter></paramdef>
   <paramdef>MPT_FRAME_HDR * <parameter>mf</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>cb_idx</parameter></term>
   <listitem>
    <para>
     Handle of registered MPT protocol driver
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>ioc</parameter></term>
   <listitem>
    <para>
     Pointer to MPT adapter structure
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>mf</parameter></term>
   <listitem>
    <para>
     Pointer to MPT request frame
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
<title>Description</title>
<para>
   Send a protocol-specific MPT request frame to an IOC using
   hi-priority request queue.
   </para><para>

   This routine posts an MPT request frame to the request post FIFO of a
   specific MPT adapter.
</para>
</refsect1>
</refentry>

<refentry id="API-mpt-free-msg-frame">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>July 2015</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>mpt_free_msg_frame</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.4.104</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>mpt_free_msg_frame</refname>
 <refpurpose>
     Place MPT request frame back on FreeQ.
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>void <function>mpt_free_msg_frame </function></funcdef>
   <paramdef>MPT_ADAPTER * <parameter>ioc</parameter></paramdef>
   <paramdef>MPT_FRAME_HDR * <parameter>mf</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>ioc</parameter></term>
   <listitem>
    <para>
     Pointer to MPT adapter structure
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>mf</parameter></term>
   <listitem>
    <para>
     Pointer to MPT request frame
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
<title>Description</title>
<para>
   This routine places a MPT request frame back on the MPT adapter's
   FreeQ.
</para>
</refsect1>
</refentry>

<refentry id="API-mpt-send-handshake-request">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>July 2015</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>mpt_send_handshake_request</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.4.104</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>mpt_send_handshake_request</refname>
 <refpurpose>
     Send MPT request via doorbell handshake method.
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>int <function>mpt_send_handshake_request </function></funcdef>
   <paramdef>u8 <parameter>cb_idx</parameter></paramdef>
   <paramdef>MPT_ADAPTER * <parameter>ioc</parameter></paramdef>
   <paramdef>int <parameter>reqBytes</parameter></paramdef>
   <paramdef>u32 * <parameter>req</parameter></paramdef>
   <paramdef>int <parameter>sleepFlag</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>cb_idx</parameter></term>
   <listitem>
    <para>
     Handle of registered MPT protocol driver
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>ioc</parameter></term>
   <listitem>
    <para>
     Pointer to MPT adapter structure
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>reqBytes</parameter></term>
   <listitem>
    <para>
     Size of the request in bytes
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>req</parameter></term>
   <listitem>
    <para>
     Pointer to MPT request frame
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>sleepFlag</parameter></term>
   <listitem>
    <para>
     Use schedule if CAN_SLEEP else use udelay.
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
<title>Description</title>
<para>
   This routine is used exclusively to send MptScsiTaskMgmt
   requests since they are required to be sent via doorbell handshake.
</para>
</refsect1>
<refsect1>
<title>NOTE</title>
<para>
   It is the callers responsibility to byte-swap fields in the
   request which are greater than 1 byte in size.
   </para><para>

   Returns 0 for success, non-zero for failure.
</para>
</refsect1>
</refentry>

<refentry id="API-mpt-verify-adapter">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>July 2015</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>mpt_verify_adapter</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.4.104</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>mpt_verify_adapter</refname>
 <refpurpose>
     Given IOC identifier, set pointer to its adapter structure.
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>int <function>mpt_verify_adapter </function></funcdef>
   <paramdef>int <parameter>iocid</parameter></paramdef>
   <paramdef>MPT_ADAPTER ** <parameter>iocpp</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>iocid</parameter></term>
   <listitem>
    <para>
     IOC unique identifier (integer)
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>iocpp</parameter></term>
   <listitem>
    <para>
     Pointer to pointer to IOC adapter
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
<title>Description</title>
<para>
   Given a unique IOC identifier, set pointer to the associated MPT
   adapter structure.
   </para><para>

   Returns iocid and sets iocpp if iocid is found.
   Returns -1 if iocid is not found.
</para>
</refsect1>
</refentry>

<refentry id="API-mpt-attach">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>July 2015</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>mpt_attach</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.4.104</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>mpt_attach</refname>
 <refpurpose>
     Install a PCI intelligent MPT adapter.
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>int <function>mpt_attach </function></funcdef>
   <paramdef>struct pci_dev * <parameter>pdev</parameter></paramdef>
   <paramdef>const struct pci_device_id * <parameter>id</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>pdev</parameter></term>
   <listitem>
    <para>
     Pointer to pci_dev structure
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>id</parameter></term>
   <listitem>
    <para>
     PCI device ID information
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
<title>Description</title>
<para>
   This routine performs all the steps necessary to bring the IOC of
   a MPT adapter to a OPERATIONAL state.  This includes registering
   memory regions, registering the interrupt, and allocating request
   and reply memory pools.
   </para><para>

   This routine also pre-fetches the LAN MAC address of a Fibre Channel
   MPT adapter.
   </para><para>

   Returns 0 for success, non-zero for failure.
</para>
</refsect1>
<refsect1>
<title>TODO</title>
<para>
   Add support for polled controllers
</para>
</refsect1>
</refentry>

<refentry id="API-mpt-detach">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>July 2015</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>mpt_detach</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.4.104</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>mpt_detach</refname>
 <refpurpose>
     Remove a PCI intelligent MPT adapter.
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>void <function>mpt_detach </function></funcdef>
   <paramdef>struct pci_dev * <parameter>pdev</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>pdev</parameter></term>
   <listitem>
    <para>
     Pointer to pci_dev structure
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
</refentry>

<refentry id="API-mpt-suspend">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>July 2015</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>mpt_suspend</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.4.104</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>mpt_suspend</refname>
 <refpurpose>
     Fusion MPT base driver suspend routine.
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>int <function>mpt_suspend </function></funcdef>
   <paramdef>struct pci_dev * <parameter>pdev</parameter></paramdef>
   <paramdef>pm_message_t <parameter>state</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>pdev</parameter></term>
   <listitem>
    <para>
     Pointer to pci_dev structure
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>state</parameter></term>
   <listitem>
    <para>
     new state to enter
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
</refentry>

<refentry id="API-mpt-resume">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>July 2015</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>mpt_resume</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.4.104</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>mpt_resume</refname>
 <refpurpose>
     Fusion MPT base driver resume routine.
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>int <function>mpt_resume </function></funcdef>
   <paramdef>struct pci_dev * <parameter>pdev</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>pdev</parameter></term>
   <listitem>
    <para>
     Pointer to pci_dev structure
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
</refentry>

<refentry id="API-mpt-GetIocState">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>July 2015</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>mpt_GetIocState</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.4.104</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>mpt_GetIocState</refname>
 <refpurpose>
     Get the current state of a MPT adapter.
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>u32 <function>mpt_GetIocState </function></funcdef>
   <paramdef>MPT_ADAPTER * <parameter>ioc</parameter></paramdef>
   <paramdef>int <parameter>cooked</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>ioc</parameter></term>
   <listitem>
    <para>
     Pointer to MPT_ADAPTER structure
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>cooked</parameter></term>
   <listitem>
    <para>
     Request raw or cooked IOC state
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
<title>Description</title>
<para>
   Returns all IOC Doorbell register bits if cooked==0, else just the
   Doorbell bits in MPI_IOC_STATE_MASK.
</para>
</refsect1>
</refentry>

<refentry id="API-mpt-alloc-fw-memory">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>July 2015</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>mpt_alloc_fw_memory</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.4.104</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>mpt_alloc_fw_memory</refname>
 <refpurpose>
     allocate firmware memory
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>int <function>mpt_alloc_fw_memory </function></funcdef>
   <paramdef>MPT_ADAPTER * <parameter>ioc</parameter></paramdef>
   <paramdef>int <parameter>size</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>ioc</parameter></term>
   <listitem>
    <para>
     Pointer to MPT_ADAPTER structure
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>size</parameter></term>
   <listitem>
    <para>
     total FW bytes
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
<title>Description</title>
<para>
   If memory has already been allocated, the same (cached) value
   is returned.
   </para><para>

   Return 0 if successful, or non-zero for failure
</para>
</refsect1>
</refentry>

<refentry id="API-mpt-free-fw-memory">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>July 2015</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>mpt_free_fw_memory</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.4.104</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>mpt_free_fw_memory</refname>
 <refpurpose>
     free firmware memory
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>void <function>mpt_free_fw_memory </function></funcdef>
   <paramdef>MPT_ADAPTER * <parameter>ioc</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>ioc</parameter></term>
   <listitem>
    <para>
     Pointer to MPT_ADAPTER structure
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
<title>Description</title>
<para>
   If alt_img is NULL, delete from ioc structure.
   Else, delete a secondary image in same format.
</para>
</refsect1>
</refentry>

<refentry id="API-mptbase-sas-persist-operation">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>July 2015</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>mptbase_sas_persist_operation</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.4.104</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>mptbase_sas_persist_operation</refname>
 <refpurpose>
     Perform operation on SAS Persistent Table
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>int <function>mptbase_sas_persist_operation </function></funcdef>
   <paramdef>MPT_ADAPTER * <parameter>ioc</parameter></paramdef>
   <paramdef>u8 <parameter>persist_opcode</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>ioc</parameter></term>
   <listitem>
    <para>
     Pointer to MPT_ADAPTER structure
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>persist_opcode</parameter></term>
   <listitem>
    <para>
     see below
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
<title>Description</title>
<para>
   MPI_SAS_OP_CLEAR_NOT_PRESENT - Free all persist TargetID mappings for
   devices not currently present.
   MPI_SAS_OP_CLEAR_ALL_PERSISTENT - Clear al persist TargetID mappings
</para>
</refsect1>
<refsect1>
<title>NOTE</title>
<para>
   Don't use not this function during interrupt time.
   </para><para>

   Returns 0 for success, non-zero error
</para>
</refsect1>
</refentry>

<refentry id="API-mpt-raid-phys-disk-pg0">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>July 2015</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>mpt_raid_phys_disk_pg0</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.4.104</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>mpt_raid_phys_disk_pg0</refname>
 <refpurpose>
     returns phys disk page zero
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>int <function>mpt_raid_phys_disk_pg0 </function></funcdef>
   <paramdef>MPT_ADAPTER * <parameter>ioc</parameter></paramdef>
   <paramdef>u8 <parameter>phys_disk_num</parameter></paramdef>
   <paramdef>RaidPhysDiskPage0_t * <parameter>phys_disk</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>ioc</parameter></term>
   <listitem>
    <para>
     Pointer to a Adapter Structure
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>phys_disk_num</parameter></term>
   <listitem>
    <para>
     io unit unique phys disk num generated by the ioc
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>phys_disk</parameter></term>
   <listitem>
    <para>
     requested payload data returned
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
<title>Return</title>
<para>
   0 on success
   -EFAULT if read of config page header fails or data pointer not NULL
   -ENOMEM if pci_alloc failed
</para>
</refsect1>
</refentry>

<refentry id="API-mpt-raid-phys-disk-get-num-paths">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>July 2015</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>mpt_raid_phys_disk_get_num_paths</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.4.104</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>mpt_raid_phys_disk_get_num_paths</refname>
 <refpurpose>
     returns number paths associated to this phys_num
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>int <function>mpt_raid_phys_disk_get_num_paths </function></funcdef>
   <paramdef>MPT_ADAPTER * <parameter>ioc</parameter></paramdef>
   <paramdef>u8 <parameter>phys_disk_num</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>ioc</parameter></term>
   <listitem>
    <para>
     Pointer to a Adapter Structure
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>phys_disk_num</parameter></term>
   <listitem>
    <para>
     io unit unique phys disk num generated by the ioc
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
<title>Return</title>
<para>
   returns number paths
</para>
</refsect1>
</refentry>

<refentry id="API-mpt-raid-phys-disk-pg1">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>July 2015</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>mpt_raid_phys_disk_pg1</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.4.104</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>mpt_raid_phys_disk_pg1</refname>
 <refpurpose>
     returns phys disk page 1
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>int <function>mpt_raid_phys_disk_pg1 </function></funcdef>
   <paramdef>MPT_ADAPTER * <parameter>ioc</parameter></paramdef>
   <paramdef>u8 <parameter>phys_disk_num</parameter></paramdef>
   <paramdef>RaidPhysDiskPage1_t * <parameter>phys_disk</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>ioc</parameter></term>
   <listitem>
    <para>
     Pointer to a Adapter Structure
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>phys_disk_num</parameter></term>
   <listitem>
    <para>
     io unit unique phys disk num generated by the ioc
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>phys_disk</parameter></term>
   <listitem>
    <para>
     requested payload data returned
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
<title>Return</title>
<para>
   0 on success
   -EFAULT if read of config page header fails or data pointer not NULL
   -ENOMEM if pci_alloc failed
</para>
</refsect1>
</refentry>

<refentry id="API-mpt-findImVolumes">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>July 2015</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>mpt_findImVolumes</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.4.104</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>mpt_findImVolumes</refname>
 <refpurpose>
     Identify IDs of hidden disks and RAID Volumes
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>int <function>mpt_findImVolumes </function></funcdef>
   <paramdef>MPT_ADAPTER * <parameter>ioc</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>ioc</parameter></term>
   <listitem>
    <para>
     Pointer to a Adapter Strucutre
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
<title>Return</title>
<para>
   0 on success
   -EFAULT if read of config page header fails or data pointer not NULL
   -ENOMEM if pci_alloc failed
</para>
</refsect1>
</refentry>

<refentry id="API-mpt-config">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>July 2015</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>mpt_config</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.4.104</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>mpt_config</refname>
 <refpurpose>
     Generic function to issue config message
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>int <function>mpt_config </function></funcdef>
   <paramdef>MPT_ADAPTER * <parameter>ioc</parameter></paramdef>
   <paramdef>CONFIGPARMS * <parameter>pCfg</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>ioc</parameter></term>
   <listitem>
    <para>
     Pointer to an adapter structure
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>pCfg</parameter></term>
   <listitem>
    <para>
     Pointer to a configuration structure. Struct contains
     action, page address, direction, physical address
     and pointer to a configuration page header
     Page header is updated.
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
<title>Description</title>
<para>
   Returns 0 for success
   -EPERM if not allowed due to ISR context
   -EAGAIN if no msg frames currently available
   -EFAULT for non-successful reply or no reply (timeout)
</para>
</refsect1>
</refentry>

<refentry id="API-mpt-print-ioc-summary">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>July 2015</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>mpt_print_ioc_summary</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.4.104</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>mpt_print_ioc_summary</refname>
 <refpurpose>
     Write ASCII summary of IOC to a buffer.
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>void <function>mpt_print_ioc_summary </function></funcdef>
   <paramdef>MPT_ADAPTER * <parameter>ioc</parameter></paramdef>
   <paramdef>char * <parameter>buffer</parameter></paramdef>
   <paramdef>int * <parameter>size</parameter></paramdef>
   <paramdef>int <parameter>len</parameter></paramdef>
   <paramdef>int <parameter>showlan</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>ioc</parameter></term>
   <listitem>
    <para>
     Pointer to MPT_ADAPTER structure
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>buffer</parameter></term>
   <listitem>
    <para>
     Pointer to buffer where IOC summary info should be written
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>size</parameter></term>
   <listitem>
    <para>
     Pointer to number of bytes we wrote (set by this routine)
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>len</parameter></term>
   <listitem>
    <para>
     Offset at which to start writing in buffer
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>showlan</parameter></term>
   <listitem>
    <para>
     Display LAN stuff?
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
<title>Description</title>
<para>
   This routine writes (english readable) ASCII text, which represents
   a summary of IOC information, to a buffer.
</para>
</refsect1>
</refentry>

<refentry id="API-mpt-set-taskmgmt-in-progress-flag">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>July 2015</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>mpt_set_taskmgmt_in_progress_flag</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.4.104</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>mpt_set_taskmgmt_in_progress_flag</refname>
 <refpurpose>
     set flags associated with task management
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>int <function>mpt_set_taskmgmt_in_progress_flag </function></funcdef>
   <paramdef>MPT_ADAPTER * <parameter>ioc</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>ioc</parameter></term>
   <listitem>
    <para>
     Pointer to MPT_ADAPTER structure
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
<title>Description</title>
<para>
   Returns 0 for SUCCESS or -1 if FAILED.
   </para><para>

   If -1 is return, then it was not possible to set the flags
</para>
</refsect1>
</refentry>

<refentry id="API-mpt-clear-taskmgmt-in-progress-flag">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>July 2015</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>mpt_clear_taskmgmt_in_progress_flag</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.4.104</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>mpt_clear_taskmgmt_in_progress_flag</refname>
 <refpurpose>
     clear flags associated with task management
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>void <function>mpt_clear_taskmgmt_in_progress_flag </function></funcdef>
   <paramdef>MPT_ADAPTER * <parameter>ioc</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>ioc</parameter></term>
   <listitem>
    <para>
     Pointer to MPT_ADAPTER structure
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
</refentry>

<refentry id="API-mpt-halt-firmware">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>July 2015</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>mpt_halt_firmware</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.4.104</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>mpt_halt_firmware</refname>
 <refpurpose>
     Halts the firmware if it is operational and panic the kernel
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>void <function>mpt_halt_firmware </function></funcdef>
   <paramdef>MPT_ADAPTER * <parameter>ioc</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>ioc</parameter></term>
   <listitem>
    <para>
     Pointer to MPT_ADAPTER structure
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
</refentry>

<refentry id="API-mpt-Soft-Hard-ResetHandler">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>July 2015</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>mpt_Soft_Hard_ResetHandler</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.4.104</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>mpt_Soft_Hard_ResetHandler</refname>
 <refpurpose>
     Try less expensive reset
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>int <function>mpt_Soft_Hard_ResetHandler </function></funcdef>
   <paramdef>MPT_ADAPTER * <parameter>ioc</parameter></paramdef>
   <paramdef>int <parameter>sleepFlag</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>ioc</parameter></term>
   <listitem>
    <para>
     Pointer to MPT_ADAPTER structure
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>sleepFlag</parameter></term>
   <listitem>
    <para>
     Indicates if sleep or schedule must be called.
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
<title>Description</title>
<para>
   Returns 0 for SUCCESS or -1 if FAILED.
   Try for softreset first, only if it fails go for expensive
   HardReset.
</para>
</refsect1>
</refentry>

<refentry id="API-mpt-HardResetHandler">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>July 2015</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>mpt_HardResetHandler</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.4.104</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>mpt_HardResetHandler</refname>
 <refpurpose>
     Generic reset handler
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>int <function>mpt_HardResetHandler </function></funcdef>
   <paramdef>MPT_ADAPTER * <parameter>ioc</parameter></paramdef>
   <paramdef>int <parameter>sleepFlag</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>ioc</parameter></term>
   <listitem>
    <para>
     Pointer to MPT_ADAPTER structure
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>sleepFlag</parameter></term>
   <listitem>
    <para>
     Indicates if sleep or schedule must be called.
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
<title>Description</title>
<para>
   Issues SCSI Task Management call based on input arg values.
   If TaskMgmt fails, returns associated SCSI request.
</para>
</refsect1>
<refsect1>
<title>Remark</title>
<para>
   _HardResetHandler can be invoked from an interrupt thread (timer)
   or a non-interrupt thread.  In the former, must not call <function>schedule</function>.
</para>
</refsect1>
<refsect1>
<title>Note</title>
<para>
   A return of -1 is a FATAL error case, as it means a
   FW reload/initialization failed.
   </para><para>

   Returns 0 for SUCCESS or -1 if FAILED.
</para>
</refsect1>
</refentry>

<!-- drivers/message/fusion/mptbase.c -->
<refentry id="API-mpt-get-cb-idx">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>July 2015</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>mpt_get_cb_idx</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.4.104</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>mpt_get_cb_idx</refname>
 <refpurpose>
  obtain cb_idx for registered driver
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>u8 <function>mpt_get_cb_idx </function></funcdef>
   <paramdef>MPT_DRIVER_CLASS <parameter>dclass</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>dclass</parameter></term>
   <listitem>
    <para>
     class driver enum
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
<title>Description</title>
<para>
   Returns cb_idx, or zero means it wasn't found
</para>
</refsect1>
</refentry>

<refentry id="API-mpt-is-discovery-complete">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>July 2015</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>mpt_is_discovery_complete</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.4.104</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>mpt_is_discovery_complete</refname>
 <refpurpose>
     determine if discovery has completed
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>int <function>mpt_is_discovery_complete </function></funcdef>
   <paramdef>MPT_ADAPTER * <parameter>ioc</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>ioc</parameter></term>
   <listitem>
    <para>
     per adatper instance
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
<title>Description</title>
<para>
   Returns 1 when discovery completed, else zero.
</para>
</refsect1>
</refentry>

<refentry id="API-mpt-remove-dead-ioc-func">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>July 2015</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>mpt_remove_dead_ioc_func</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.4.104</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>mpt_remove_dead_ioc_func</refname>
 <refpurpose>
     kthread context to remove dead ioc
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>int <function>mpt_remove_dead_ioc_func </function></funcdef>
   <paramdef>void * <parameter>arg</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>arg</parameter></term>
   <listitem>
    <para>
     input argument, used to derive ioc
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
<title>Description</title>
<para>
   Return 0 if controller is removed from pci subsystem.
   Return -1 for other case.
</para>
</refsect1>
</refentry>

<refentry id="API-mpt-fault-reset-work">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>July 2015</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>mpt_fault_reset_work</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.4.104</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>mpt_fault_reset_work</refname>
 <refpurpose>
     work performed on workq after ioc fault
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>void <function>mpt_fault_reset_work </function></funcdef>
   <paramdef>struct work_struct * <parameter>work</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>work</parameter></term>
   <listitem>
    <para>
     input argument, used to derive ioc
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
</refentry>

<refentry id="API-mpt-interrupt">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>July 2015</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>mpt_interrupt</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.4.104</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>mpt_interrupt</refname>
 <refpurpose>
     MPT adapter (IOC) specific interrupt handler.
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>irqreturn_t <function>mpt_interrupt </function></funcdef>
   <paramdef>int <parameter>irq</parameter></paramdef>
   <paramdef>void * <parameter>bus_id</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>irq</parameter></term>
   <listitem>
    <para>
     irq number (not used)
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>bus_id</parameter></term>
   <listitem>
    <para>
     bus identifier cookie == pointer to MPT_ADAPTER structure
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
<title>Description</title>
<para>
   This routine is registered via the <function>request_irq</function> kernel API call,
   and handles all interrupts generated from a specific MPT adapter
   (also referred to as a IO Controller or IOC).
   This routine must clear the interrupt from the adapter and does
   so by reading the reply FIFO.  Multiple replies may be processed
   per single call to this routine.
   </para><para>

   This routine handles register-level access of the adapter but
   dispatches (calls) a protocol-specific callback routine to handle
   the protocol-specific details of the MPT request completion.
</para>
</refsect1>
</refentry>

<refentry id="API-mptbase-reply">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>July 2015</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>mptbase_reply</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.4.104</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>mptbase_reply</refname>
 <refpurpose>
     MPT base driver's callback routine
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>int <function>mptbase_reply </function></funcdef>
   <paramdef>MPT_ADAPTER * <parameter>ioc</parameter></paramdef>
   <paramdef>MPT_FRAME_HDR * <parameter>req</parameter></paramdef>
   <paramdef>MPT_FRAME_HDR * <parameter>reply</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>ioc</parameter></term>
   <listitem>
    <para>
     Pointer to MPT_ADAPTER structure
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>req</parameter></term>
   <listitem>
    <para>
     Pointer to original MPT request frame
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>reply</parameter></term>
   <listitem>
    <para>
     Pointer to MPT reply frame (NULL if TurboReply)
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
<title>Description</title>
<para>
   MPT base driver's callback routine; all base driver
   <quote>internal</quote> request/reply processing is routed here.
   Currently used for EventNotification and EventAck handling.
   </para><para>

   Returns 1 indicating original alloc'd request frame ptr
   should be freed, or 0 if it shouldn't.
</para>
</refsect1>
</refentry>

<refentry id="API-mpt-add-sge">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>July 2015</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>mpt_add_sge</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.4.104</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>mpt_add_sge</refname>
 <refpurpose>
     Place a simple 32 bit SGE at address pAddr.
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>void <function>mpt_add_sge </function></funcdef>
   <paramdef>void * <parameter>pAddr</parameter></paramdef>
   <paramdef>u32 <parameter>flagslength</parameter></paramdef>
   <paramdef>dma_addr_t <parameter>dma_addr</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>pAddr</parameter></term>
   <listitem>
    <para>
     virtual address for SGE
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>flagslength</parameter></term>
   <listitem>
    <para>
     SGE flags and data transfer length
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>dma_addr</parameter></term>
   <listitem>
    <para>
     Physical address
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
<title>Description</title>
<para>
   This routine places a MPT request frame back on the MPT adapter's
   FreeQ.
</para>
</refsect1>
</refentry>

<refentry id="API-mpt-add-sge-64bit">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>July 2015</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>mpt_add_sge_64bit</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.4.104</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>mpt_add_sge_64bit</refname>
 <refpurpose>
     Place a simple 64 bit SGE at address pAddr.
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>void <function>mpt_add_sge_64bit </function></funcdef>
   <paramdef>void * <parameter>pAddr</parameter></paramdef>
   <paramdef>u32 <parameter>flagslength</parameter></paramdef>
   <paramdef>dma_addr_t <parameter>dma_addr</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>pAddr</parameter></term>
   <listitem>
    <para>
     virtual address for SGE
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>flagslength</parameter></term>
   <listitem>
    <para>
     SGE flags and data transfer length
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>dma_addr</parameter></term>
   <listitem>
    <para>
     Physical address
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
<title>Description</title>
<para>
   This routine places a MPT request frame back on the MPT adapter's
   FreeQ.
</para>
</refsect1>
</refentry>

<refentry id="API-mpt-add-sge-64bit-1078">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>July 2015</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>mpt_add_sge_64bit_1078</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.4.104</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>mpt_add_sge_64bit_1078</refname>
 <refpurpose>
     Place a simple 64 bit SGE at address pAddr (1078 workaround).
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>void <function>mpt_add_sge_64bit_1078 </function></funcdef>
   <paramdef>void * <parameter>pAddr</parameter></paramdef>
   <paramdef>u32 <parameter>flagslength</parameter></paramdef>
   <paramdef>dma_addr_t <parameter>dma_addr</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>pAddr</parameter></term>
   <listitem>
    <para>
     virtual address for SGE
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>flagslength</parameter></term>
   <listitem>
    <para>
     SGE flags and data transfer length
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>dma_addr</parameter></term>
   <listitem>
    <para>
     Physical address
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
<title>Description</title>
<para>
   This routine places a MPT request frame back on the MPT adapter's
   FreeQ.
</para>
</refsect1>
</refentry>

<refentry id="API-mpt-add-chain">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>July 2015</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>mpt_add_chain</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.4.104</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>mpt_add_chain</refname>
 <refpurpose>
     Place a 32 bit chain SGE at address pAddr.
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>void <function>mpt_add_chain </function></funcdef>
   <paramdef>void * <parameter>pAddr</parameter></paramdef>
   <paramdef>u8 <parameter>next</parameter></paramdef>
   <paramdef>u16 <parameter>length</parameter></paramdef>
   <paramdef>dma_addr_t <parameter>dma_addr</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>pAddr</parameter></term>
   <listitem>
    <para>
     virtual address for SGE
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>next</parameter></term>
   <listitem>
    <para>
     nextChainOffset value (u32's)
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>length</parameter></term>
   <listitem>
    <para>
     length of next SGL segment
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>dma_addr</parameter></term>
   <listitem>
    <para>
     Physical address
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
</refentry>

<refentry id="API-mpt-add-chain-64bit">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>July 2015</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>mpt_add_chain_64bit</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.4.104</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>mpt_add_chain_64bit</refname>
 <refpurpose>
     Place a 64 bit chain SGE at address pAddr.
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>void <function>mpt_add_chain_64bit </function></funcdef>
   <paramdef>void * <parameter>pAddr</parameter></paramdef>
   <paramdef>u8 <parameter>next</parameter></paramdef>
   <paramdef>u16 <parameter>length</parameter></paramdef>
   <paramdef>dma_addr_t <parameter>dma_addr</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>pAddr</parameter></term>
   <listitem>
    <para>
     virtual address for SGE
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>next</parameter></term>
   <listitem>
    <para>
     nextChainOffset value (u32's)
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>length</parameter></term>
   <listitem>
    <para>
     length of next SGL segment
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>dma_addr</parameter></term>
   <listitem>
    <para>
     Physical address
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
</refentry>

<refentry id="API-mpt-host-page-access-control">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>July 2015</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>mpt_host_page_access_control</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.4.104</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>mpt_host_page_access_control</refname>
 <refpurpose>
     control the IOC's Host Page Buffer access
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>int <function>mpt_host_page_access_control </function></funcdef>
   <paramdef>MPT_ADAPTER * <parameter>ioc</parameter></paramdef>
   <paramdef>u8 <parameter>access_control_value</parameter></paramdef>
   <paramdef>int <parameter>sleepFlag</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>ioc</parameter></term>
   <listitem>
    <para>
     Pointer to MPT adapter structure
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>access_control_value</parameter></term>
   <listitem>
    <para>
     define bits below
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>sleepFlag</parameter></term>
   <listitem>
    <para>
     Specifies whether the process can sleep
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
<title>Description</title>
<para>
   Provides mechanism for the host driver to control the IOC's
   Host Page Buffer access.
   </para><para>

   Access Control Value - bits[15:12]
   0h Reserved
   1h Enable Access { MPI_DB_HPBAC_ENABLE_ACCESS }
   2h Disable Access { MPI_DB_HPBAC_DISABLE_ACCESS }
   3h Free Buffer { MPI_DB_HPBAC_FREE_BUFFER }
   </para><para>

   Returns 0 for success, non-zero for failure.
</para>
</refsect1>
</refentry>

<refentry id="API-mpt-host-page-alloc">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>July 2015</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>mpt_host_page_alloc</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.4.104</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>mpt_host_page_alloc</refname>
 <refpurpose>
     allocate system memory for the fw
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>int <function>mpt_host_page_alloc </function></funcdef>
   <paramdef>MPT_ADAPTER * <parameter>ioc</parameter></paramdef>
   <paramdef>pIOCInit_t <parameter>ioc_init</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>ioc</parameter></term>
   <listitem>
    <para>
     Pointer to pointer to IOC adapter
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>ioc_init</parameter></term>
   <listitem>
    <para>
     Pointer to ioc init config page
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
<title>Description</title>
<para>
   If we already allocated memory in past, then resend the same pointer.
   Returns 0 for success, non-zero for failure.
</para>
</refsect1>
</refentry>

<refentry id="API-mpt-get-product-name">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>July 2015</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>mpt_get_product_name</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.4.104</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>mpt_get_product_name</refname>
 <refpurpose>
     returns product string
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>void <function>mpt_get_product_name </function></funcdef>
   <paramdef>u16 <parameter>vendor</parameter></paramdef>
   <paramdef>u16 <parameter>device</parameter></paramdef>
   <paramdef>u8 <parameter>revision</parameter></paramdef>
   <paramdef>char * <parameter>prod_name</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>vendor</parameter></term>
   <listitem>
    <para>
     pci vendor id
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>device</parameter></term>
   <listitem>
    <para>
     pci device id
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>revision</parameter></term>
   <listitem>
    <para>
     pci revision id
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>prod_name</parameter></term>
   <listitem>
    <para>
     string returned
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
<title>Description</title>
<para>
   Returns product string displayed when driver loads,
   in /proc/mpt/summary and /sysfs/class/scsi_host/host&lt;X&gt;/version_product
</para>
</refsect1>
</refentry>

<refentry id="API-mpt-mapresources">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>July 2015</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>mpt_mapresources</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.4.104</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>mpt_mapresources</refname>
 <refpurpose>
     map in memory mapped io
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>int <function>mpt_mapresources </function></funcdef>
   <paramdef>MPT_ADAPTER * <parameter>ioc</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>ioc</parameter></term>
   <listitem>
    <para>
     Pointer to pointer to IOC adapter
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
</refentry>

<refentry id="API-mpt-do-ioc-recovery">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>July 2015</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>mpt_do_ioc_recovery</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.4.104</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>mpt_do_ioc_recovery</refname>
 <refpurpose>
     Initialize or recover MPT adapter.
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>int <function>mpt_do_ioc_recovery </function></funcdef>
   <paramdef>MPT_ADAPTER * <parameter>ioc</parameter></paramdef>
   <paramdef>u32 <parameter>reason</parameter></paramdef>
   <paramdef>int <parameter>sleepFlag</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>ioc</parameter></term>
   <listitem>
    <para>
     Pointer to MPT adapter structure
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>reason</parameter></term>
   <listitem>
    <para>
     Event word / reason
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>sleepFlag</parameter></term>
   <listitem>
    <para>
     Use schedule if CAN_SLEEP else use udelay.
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
<title>Description</title>
<para>
   This routine performs all the steps necessary to bring the IOC
   to a OPERATIONAL state.
   </para><para>

   This routine also pre-fetches the LAN MAC address of a Fibre Channel
   MPT adapter.
</para>
</refsect1>
<refsect1>
<title>Returns</title>
<para>
   0 for success
   -1 if failed to get board READY
   -2 if READY but IOCFacts Failed
   -3 if READY but PrimeIOCFifos Failed
   -4 if READY but IOCInit Failed
   -5 if failed to enable_device and/or request_selected_regions
   -6 if failed to upload firmware
</para>
</refsect1>
</refentry>

<refentry id="API-mpt-detect-bound-ports">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>July 2015</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>mpt_detect_bound_ports</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.4.104</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>mpt_detect_bound_ports</refname>
 <refpurpose>
     Search for matching PCI bus/dev_function
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>void <function>mpt_detect_bound_ports </function></funcdef>
   <paramdef>MPT_ADAPTER * <parameter>ioc</parameter></paramdef>
   <paramdef>struct pci_dev * <parameter>pdev</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>ioc</parameter></term>
   <listitem>
    <para>
     Pointer to MPT adapter structure
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>pdev</parameter></term>
   <listitem>
    <para>
     Pointer to (struct pci_dev) structure
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
<title>Description</title>
<para>
   Search for PCI bus/dev_function which matches
   PCI bus/dev_function (+/-1) for newly discovered 929,
   929X, 1030 or 1035.
   </para><para>

   If match on PCI dev_function +/-1 is found, bind the two MPT adapters
   using alt_ioc pointer fields in their <constant>MPT_ADAPTER</constant> structures.
</para>
</refsect1>
</refentry>

<refentry id="API-mpt-adapter-disable">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>July 2015</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>mpt_adapter_disable</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.4.104</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>mpt_adapter_disable</refname>
 <refpurpose>
     Disable misbehaving MPT adapter.
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>void <function>mpt_adapter_disable </function></funcdef>
   <paramdef>MPT_ADAPTER * <parameter>ioc</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>ioc</parameter></term>
   <listitem>
    <para>
     Pointer to MPT adapter structure
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
</refentry>

<refentry id="API-mpt-adapter-dispose">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>July 2015</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>mpt_adapter_dispose</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.4.104</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>mpt_adapter_dispose</refname>
 <refpurpose>
     Free all resources associated with an MPT adapter
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>void <function>mpt_adapter_dispose </function></funcdef>
   <paramdef>MPT_ADAPTER * <parameter>ioc</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>ioc</parameter></term>
   <listitem>
    <para>
     Pointer to MPT adapter structure
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
<title>Description</title>
<para>
   This routine unregisters h/w resources and frees all alloc'd memory
   associated with a MPT adapter structure.
</para>
</refsect1>
</refentry>

<refentry id="API-MptDisplayIocCapabilities">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>July 2015</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>MptDisplayIocCapabilities</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.4.104</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>MptDisplayIocCapabilities</refname>
 <refpurpose>
     Disply IOC's capabilities.
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>void <function>MptDisplayIocCapabilities </function></funcdef>
   <paramdef>MPT_ADAPTER * <parameter>ioc</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>ioc</parameter></term>
   <listitem>
    <para>
     Pointer to MPT adapter structure
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
</refentry>

<refentry id="API-MakeIocReady">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>July 2015</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>MakeIocReady</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.4.104</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>MakeIocReady</refname>
 <refpurpose>
     Get IOC to a READY state, using KickStart if needed.
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>int <function>MakeIocReady </function></funcdef>
   <paramdef>MPT_ADAPTER * <parameter>ioc</parameter></paramdef>
   <paramdef>int <parameter>force</parameter></paramdef>
   <paramdef>int <parameter>sleepFlag</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>ioc</parameter></term>
   <listitem>
    <para>
     Pointer to MPT_ADAPTER structure
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>force</parameter></term>
   <listitem>
    <para>
     Force hard KickStart of IOC
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>sleepFlag</parameter></term>
   <listitem>
    <para>
     Specifies whether the process can sleep
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
<title>Returns</title>
<para>
   1 - DIAG reset and READY
   0 - READY initially OR soft reset and READY
   -1 - Any failure on KickStart
   -2 - Msg Unit Reset Failed
   -3 - IO Unit Reset Failed
   -4 - IOC owned by a PEER
</para>
</refsect1>
</refentry>

<refentry id="API-GetIocFacts">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>July 2015</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>GetIocFacts</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.4.104</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>GetIocFacts</refname>
 <refpurpose>
     Send IOCFacts request to MPT adapter.
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>int <function>GetIocFacts </function></funcdef>
   <paramdef>MPT_ADAPTER * <parameter>ioc</parameter></paramdef>
   <paramdef>int <parameter>sleepFlag</parameter></paramdef>
   <paramdef>int <parameter>reason</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>ioc</parameter></term>
   <listitem>
    <para>
     Pointer to MPT_ADAPTER structure
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>sleepFlag</parameter></term>
   <listitem>
    <para>
     Specifies whether the process can sleep
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>reason</parameter></term>
   <listitem>
    <para>
     If recovery, only update facts.
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
<title>Description</title>
<para>
   Returns 0 for success, non-zero for failure.
</para>
</refsect1>
</refentry>

<refentry id="API-GetPortFacts">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>July 2015</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>GetPortFacts</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.4.104</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>GetPortFacts</refname>
 <refpurpose>
     Send PortFacts request to MPT adapter.
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>int <function>GetPortFacts </function></funcdef>
   <paramdef>MPT_ADAPTER * <parameter>ioc</parameter></paramdef>
   <paramdef>int <parameter>portnum</parameter></paramdef>
   <paramdef>int <parameter>sleepFlag</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>ioc</parameter></term>
   <listitem>
    <para>
     Pointer to MPT_ADAPTER structure
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>portnum</parameter></term>
   <listitem>
    <para>
     Port number
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>sleepFlag</parameter></term>
   <listitem>
    <para>
     Specifies whether the process can sleep
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
<title>Description</title>
<para>
   Returns 0 for success, non-zero for failure.
</para>
</refsect1>
</refentry>

<refentry id="API-SendIocInit">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>July 2015</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>SendIocInit</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.4.104</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>SendIocInit</refname>
 <refpurpose>
     Send IOCInit request to MPT adapter.
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>int <function>SendIocInit </function></funcdef>
   <paramdef>MPT_ADAPTER * <parameter>ioc</parameter></paramdef>
   <paramdef>int <parameter>sleepFlag</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>ioc</parameter></term>
   <listitem>
    <para>
     Pointer to MPT_ADAPTER structure
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>sleepFlag</parameter></term>
   <listitem>
    <para>
     Specifies whether the process can sleep
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
<title>Description</title>
<para>
   Send IOCInit followed by PortEnable to bring IOC to OPERATIONAL state.
   </para><para>

   Returns 0 for success, non-zero for failure.
</para>
</refsect1>
</refentry>

<refentry id="API-SendPortEnable">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>July 2015</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>SendPortEnable</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.4.104</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>SendPortEnable</refname>
 <refpurpose>
     Send PortEnable request to MPT adapter port.
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>int <function>SendPortEnable </function></funcdef>
   <paramdef>MPT_ADAPTER * <parameter>ioc</parameter></paramdef>
   <paramdef>int <parameter>portnum</parameter></paramdef>
   <paramdef>int <parameter>sleepFlag</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>ioc</parameter></term>
   <listitem>
    <para>
     Pointer to MPT_ADAPTER structure
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>portnum</parameter></term>
   <listitem>
    <para>
     Port number to enable
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>sleepFlag</parameter></term>
   <listitem>
    <para>
     Specifies whether the process can sleep
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
<title>Description</title>
<para>
   Send PortEnable to bring IOC to OPERATIONAL state.
   </para><para>

   Returns 0 for success, non-zero for failure.
</para>
</refsect1>
</refentry>

<refentry id="API-mpt-do-upload">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>July 2015</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>mpt_do_upload</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.4.104</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>mpt_do_upload</refname>
 <refpurpose>
     Construct and Send FWUpload request to MPT adapter port.
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>int <function>mpt_do_upload </function></funcdef>
   <paramdef>MPT_ADAPTER * <parameter>ioc</parameter></paramdef>
   <paramdef>int <parameter>sleepFlag</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>ioc</parameter></term>
   <listitem>
    <para>
     Pointer to MPT_ADAPTER structure
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>sleepFlag</parameter></term>
   <listitem>
    <para>
     Specifies whether the process can sleep
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
<title>Description</title>
<para>
   Returns 0 for success, &gt;0 for handshake failure
   &lt;0 for fw upload failure.
</para>
</refsect1>
<refsect1>
<title>Remark</title>
<para>
   If bound IOC and a successful FWUpload was performed
   on the bound IOC, the second image is discarded
   and memory is free'd. Both channels must upload to prevent
   IOC from running in degraded mode.
</para>
</refsect1>
</refentry>

<refentry id="API-mpt-downloadboot">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>July 2015</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>mpt_downloadboot</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.4.104</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>mpt_downloadboot</refname>
 <refpurpose>
     DownloadBoot code
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>int <function>mpt_downloadboot </function></funcdef>
   <paramdef>MPT_ADAPTER * <parameter>ioc</parameter></paramdef>
   <paramdef>MpiFwHeader_t * <parameter>pFwHeader</parameter></paramdef>
   <paramdef>int <parameter>sleepFlag</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>ioc</parameter></term>
   <listitem>
    <para>
     Pointer to MPT_ADAPTER structure
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>pFwHeader</parameter></term>
   <listitem>
    <para>
     Pointer to firmware header info
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>sleepFlag</parameter></term>
   <listitem>
    <para>
     Specifies whether the process can sleep
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
<title>Description</title>
<para>
   FwDownloadBoot requires Programmed IO access.
   </para><para>

   Returns 0 for success
   -1 FW Image size is 0
   -2 No valid cached_fw Pointer
   &lt;0 for fw upload failure.
</para>
</refsect1>
</refentry>

<refentry id="API-KickStart">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>July 2015</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>KickStart</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.4.104</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>KickStart</refname>
 <refpurpose>
     Perform hard reset of MPT adapter.
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>int <function>KickStart </function></funcdef>
   <paramdef>MPT_ADAPTER * <parameter>ioc</parameter></paramdef>
   <paramdef>int <parameter>force</parameter></paramdef>
   <paramdef>int <parameter>sleepFlag</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>ioc</parameter></term>
   <listitem>
    <para>
     Pointer to MPT_ADAPTER structure
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>force</parameter></term>
   <listitem>
    <para>
     Force hard reset
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>sleepFlag</parameter></term>
   <listitem>
    <para>
     Specifies whether the process can sleep
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
<title>Description</title>
<para>
   This routine places MPT adapter in diagnostic mode via the
   WriteSequence register, and then performs a hard reset of adapter
   via the Diagnostic register.
</para>
</refsect1>
<refsect1>
<title>Inputs</title>
<para>
   sleepflag - CAN_SLEEP (non-interrupt thread)
   or NO_SLEEP (interrupt thread, use mdelay)
   force - 1 if doorbell active, board fault state
   board operational, IOC_RECOVERY or
   IOC_BRINGUP and there is an alt_ioc.
   0 else
</para>
</refsect1>
<refsect1>
<title>Returns</title>
<para>
   1 - hard reset, READY
   0 - no reset due to History bit, READY
   -1 - no reset due to History bit but not READY
   OR reset but failed to come READY
   -2 - no reset, could not enter DIAG mode
   -3 - reset but bad FW bit
</para>
</refsect1>
</refentry>

<refentry id="API-mpt-diag-reset">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>July 2015</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>mpt_diag_reset</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.4.104</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>mpt_diag_reset</refname>
 <refpurpose>
     Perform hard reset of the adapter.
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>int <function>mpt_diag_reset </function></funcdef>
   <paramdef>MPT_ADAPTER * <parameter>ioc</parameter></paramdef>
   <paramdef>int <parameter>ignore</parameter></paramdef>
   <paramdef>int <parameter>sleepFlag</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>ioc</parameter></term>
   <listitem>
    <para>
     Pointer to MPT_ADAPTER structure
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>ignore</parameter></term>
   <listitem>
    <para>
     Set if to honor and clear to ignore
     the reset history bit
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>sleepFlag</parameter></term>
   <listitem>
    <para>
     CAN_SLEEP if called in a non-interrupt thread,
     else set to NO_SLEEP (use mdelay instead)
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
<title>Description</title>
<para>
   This routine places the adapter in diagnostic mode via the
   WriteSequence register and then performs a hard reset of adapter
   via the Diagnostic register. Adapter should be in ready state
   upon successful completion.
</para>
</refsect1>
<refsect1>
<title>Returns</title>
<para>
   1  hard reset successful
   0  no reset performed because reset history bit set
   -2  enabling diagnostic mode failed
   -3  diagnostic reset failed
</para>
</refsect1>
</refentry>

<refentry id="API-SendIocReset">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>July 2015</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>SendIocReset</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.4.104</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>SendIocReset</refname>
 <refpurpose>
     Send IOCReset request to MPT adapter.
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>int <function>SendIocReset </function></funcdef>
   <paramdef>MPT_ADAPTER * <parameter>ioc</parameter></paramdef>
   <paramdef>u8 <parameter>reset_type</parameter></paramdef>
   <paramdef>int <parameter>sleepFlag</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>ioc</parameter></term>
   <listitem>
    <para>
     Pointer to MPT_ADAPTER structure
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>reset_type</parameter></term>
   <listitem>
    <para>
     reset type, expected values are
     <constant>MPI_FUNCTION_IOC_MESSAGE_UNIT_RESET</constant> or <constant>MPI_FUNCTION_IO_UNIT_RESET</constant>
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>sleepFlag</parameter></term>
   <listitem>
    <para>
     Specifies whether the process can sleep
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
<title>Description</title>
<para>
   Send IOCReset request to the MPT adapter.
   </para><para>

   Returns 0 for success, non-zero for failure.
</para>
</refsect1>
</refentry>

<refentry id="API-initChainBuffers">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>July 2015</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>initChainBuffers</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.4.104</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>initChainBuffers</refname>
 <refpurpose>
     Allocate memory for and initialize chain buffers
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>int <function>initChainBuffers </function></funcdef>
   <paramdef>MPT_ADAPTER * <parameter>ioc</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>ioc</parameter></term>
   <listitem>
    <para>
     Pointer to MPT_ADAPTER structure
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
<title>Description</title>
<para>
   Allocates memory for and initializes chain buffers,
   chain buffer control arrays and spinlock.
</para>
</refsect1>
</refentry>

<refentry id="API-PrimeIocFifos">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>July 2015</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>PrimeIocFifos</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.4.104</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>PrimeIocFifos</refname>
 <refpurpose>
     Initialize IOC request and reply FIFOs.
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>int <function>PrimeIocFifos </function></funcdef>
   <paramdef>MPT_ADAPTER * <parameter>ioc</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>ioc</parameter></term>
   <listitem>
    <para>
     Pointer to MPT_ADAPTER structure
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
<title>Description</title>
<para>
   This routine allocates memory for the MPT reply and request frame
   pools (if necessary), and primes the IOC reply FIFO with
   reply frames.
   </para><para>

   Returns 0 for success, non-zero for failure.
</para>
</refsect1>
</refentry>

<refentry id="API-mpt-handshake-req-reply-wait">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>July 2015</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>mpt_handshake_req_reply_wait</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.4.104</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>mpt_handshake_req_reply_wait</refname>
 <refpurpose>
     Send MPT request to and receive reply from IOC via doorbell handshake method.
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>int <function>mpt_handshake_req_reply_wait </function></funcdef>
   <paramdef>MPT_ADAPTER * <parameter>ioc</parameter></paramdef>
   <paramdef>int <parameter>reqBytes</parameter></paramdef>
   <paramdef>u32 * <parameter>req</parameter></paramdef>
   <paramdef>int <parameter>replyBytes</parameter></paramdef>
   <paramdef>u16 * <parameter>u16reply</parameter></paramdef>
   <paramdef>int <parameter>maxwait</parameter></paramdef>
   <paramdef>int <parameter>sleepFlag</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>ioc</parameter></term>
   <listitem>
    <para>
     Pointer to MPT_ADAPTER structure
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>reqBytes</parameter></term>
   <listitem>
    <para>
     Size of the request in bytes
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>req</parameter></term>
   <listitem>
    <para>
     Pointer to MPT request frame
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>replyBytes</parameter></term>
   <listitem>
    <para>
     Expected size of the reply in bytes
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>u16reply</parameter></term>
   <listitem>
    <para>
     Pointer to area where reply should be written
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>maxwait</parameter></term>
   <listitem>
    <para>
     Max wait time for a reply (in seconds)
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>sleepFlag</parameter></term>
   <listitem>
    <para>
     Specifies whether the process can sleep
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
<title>NOTES</title>
<para>
   It is the callers responsibility to byte-swap fields in the
   request which are greater than 1 byte in size.  It is also the
   callers responsibility to byte-swap response fields which are
   greater than 1 byte in size.
   </para><para>

   Returns 0 for success, non-zero for failure.
</para>
</refsect1>
</refentry>

<refentry id="API-WaitForDoorbellAck">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>July 2015</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>WaitForDoorbellAck</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.4.104</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>WaitForDoorbellAck</refname>
 <refpurpose>
     Wait for IOC doorbell handshake acknowledge
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>int <function>WaitForDoorbellAck </function></funcdef>
   <paramdef>MPT_ADAPTER * <parameter>ioc</parameter></paramdef>
   <paramdef>int <parameter>howlong</parameter></paramdef>
   <paramdef>int <parameter>sleepFlag</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>ioc</parameter></term>
   <listitem>
    <para>
     Pointer to MPT_ADAPTER structure
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>howlong</parameter></term>
   <listitem>
    <para>
     How long to wait (in seconds)
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>sleepFlag</parameter></term>
   <listitem>
    <para>
     Specifies whether the process can sleep
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
<title>Description</title>
<para>
   This routine waits (up to ~2 seconds max) for IOC doorbell
   handshake ACKnowledge, indicated by the IOP_DOORBELL_STATUS
   bit in its IntStatus register being clear.
   </para><para>

   Returns a negative value on failure, else wait loop count.
</para>
</refsect1>
</refentry>

<refentry id="API-WaitForDoorbellInt">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>July 2015</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>WaitForDoorbellInt</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.4.104</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>WaitForDoorbellInt</refname>
 <refpurpose>
     Wait for IOC to set its doorbell interrupt bit
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>int <function>WaitForDoorbellInt </function></funcdef>
   <paramdef>MPT_ADAPTER * <parameter>ioc</parameter></paramdef>
   <paramdef>int <parameter>howlong</parameter></paramdef>
   <paramdef>int <parameter>sleepFlag</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>ioc</parameter></term>
   <listitem>
    <para>
     Pointer to MPT_ADAPTER structure
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>howlong</parameter></term>
   <listitem>
    <para>
     How long to wait (in seconds)
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>sleepFlag</parameter></term>
   <listitem>
    <para>
     Specifies whether the process can sleep
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
<title>Description</title>
<para>
   This routine waits (up to ~2 seconds max) for IOC doorbell interrupt
   (MPI_HIS_DOORBELL_INTERRUPT) to be set in the IntStatus register.
   </para><para>

   Returns a negative value on failure, else wait loop count.
</para>
</refsect1>
</refentry>

<refentry id="API-WaitForDoorbellReply">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>July 2015</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>WaitForDoorbellReply</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.4.104</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>WaitForDoorbellReply</refname>
 <refpurpose>
     Wait for and capture an IOC handshake reply.
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>int <function>WaitForDoorbellReply </function></funcdef>
   <paramdef>MPT_ADAPTER * <parameter>ioc</parameter></paramdef>
   <paramdef>int <parameter>howlong</parameter></paramdef>
   <paramdef>int <parameter>sleepFlag</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>ioc</parameter></term>
   <listitem>
    <para>
     Pointer to MPT_ADAPTER structure
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>howlong</parameter></term>
   <listitem>
    <para>
     How long to wait (in seconds)
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>sleepFlag</parameter></term>
   <listitem>
    <para>
     Specifies whether the process can sleep
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
<title>Description</title>
<para>
   This routine polls the IOC for a handshake reply, 16 bits at a time.
   Reply is cached to IOC private area large enough to hold a maximum
   of 128 bytes of reply data.
   </para><para>

   Returns a negative value on failure, else size of reply in WORDS.
</para>
</refsect1>
</refentry>

<refentry id="API-GetLanConfigPages">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>July 2015</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>GetLanConfigPages</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.4.104</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>GetLanConfigPages</refname>
 <refpurpose>
     Fetch LANConfig pages.
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>int <function>GetLanConfigPages </function></funcdef>
   <paramdef>MPT_ADAPTER * <parameter>ioc</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>ioc</parameter></term>
   <listitem>
    <para>
     Pointer to MPT_ADAPTER structure
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
<title>Return</title>
<para>
   0 for success
   -ENOMEM if no memory available
   -EPERM if not allowed due to ISR context
   -EAGAIN if no msg frames currently available
   -EFAULT for non-successful reply or no reply (timeout)
</para>
</refsect1>
</refentry>

<refentry id="API-GetIoUnitPage2">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>July 2015</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>GetIoUnitPage2</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.4.104</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>GetIoUnitPage2</refname>
 <refpurpose>
     Retrieve BIOS version and boot order information.
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>int <function>GetIoUnitPage2 </function></funcdef>
   <paramdef>MPT_ADAPTER * <parameter>ioc</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>ioc</parameter></term>
   <listitem>
    <para>
     Pointer to MPT_ADAPTER structure
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
<title>Returns</title>
<para>
   0 for success
   -ENOMEM if no memory available
   -EPERM if not allowed due to ISR context
   -EAGAIN if no msg frames currently available
   -EFAULT for non-successful reply or no reply (timeout)
</para>
</refsect1>
</refentry>

<refentry id="API-mpt-GetScsiPortSettings">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>July 2015</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>mpt_GetScsiPortSettings</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.4.104</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>mpt_GetScsiPortSettings</refname>
 <refpurpose>
     read SCSI Port Page 0 and 2
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>int <function>mpt_GetScsiPortSettings </function></funcdef>
   <paramdef>MPT_ADAPTER * <parameter>ioc</parameter></paramdef>
   <paramdef>int <parameter>portnum</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>ioc</parameter></term>
   <listitem>
    <para>
     Pointer to a Adapter Strucutre
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>portnum</parameter></term>
   <listitem>
    <para>
     IOC port number
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
<title>Return</title>
<para>
   -EFAULT if read of config page header fails
   or if no nvram
   If read of SCSI Port Page 0 fails,
   NVRAM = MPT_HOST_NVRAM_INVALID  (0xFFFFFFFF)
</para>
</refsect1>
<refsect1>
<title>Adapter settings</title>
<para>
   async, narrow
   Return 1
   If read of SCSI Port Page 2 fails,
   Adapter settings valid
   NVRAM = MPT_HOST_NVRAM_INVALID  (0xFFFFFFFF)
   Return 1
   Else
   Both valid
   Return 0
   CHECK - what type of locking mechanisms should be used????
</para>
</refsect1>
</refentry>

<refentry id="API-mpt-readScsiDevicePageHeaders">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>July 2015</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>mpt_readScsiDevicePageHeaders</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.4.104</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>mpt_readScsiDevicePageHeaders</refname>
 <refpurpose>
     save version and length of SDP1
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>int <function>mpt_readScsiDevicePageHeaders </function></funcdef>
   <paramdef>MPT_ADAPTER * <parameter>ioc</parameter></paramdef>
   <paramdef>int <parameter>portnum</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>ioc</parameter></term>
   <listitem>
    <para>
     Pointer to a Adapter Strucutre
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>portnum</parameter></term>
   <listitem>
    <para>
     IOC port number
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
<title>Return</title>
<para>
   -EFAULT if read of config page header fails
   or 0 if success.
</para>
</refsect1>
</refentry>

<refentry id="API-mpt-inactive-raid-list-free">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>July 2015</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>mpt_inactive_raid_list_free</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.4.104</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>mpt_inactive_raid_list_free</refname>
 <refpurpose>
     This clears this link list.
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>void <function>mpt_inactive_raid_list_free </function></funcdef>
   <paramdef>MPT_ADAPTER * <parameter>ioc</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>ioc</parameter></term>
   <listitem>
    <para>
     pointer to per adapter structure
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
</refentry>

<refentry id="API-mpt-inactive-raid-volumes">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>July 2015</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>mpt_inactive_raid_volumes</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.4.104</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>mpt_inactive_raid_volumes</refname>
 <refpurpose>
     sets up link list of phy_disk_nums for devices belonging in an inactive volume
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>void <function>mpt_inactive_raid_volumes </function></funcdef>
   <paramdef>MPT_ADAPTER * <parameter>ioc</parameter></paramdef>
   <paramdef>u8 <parameter>channel</parameter></paramdef>
   <paramdef>u8 <parameter>id</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>ioc</parameter></term>
   <listitem>
    <para>
     pointer to per adapter structure
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>channel</parameter></term>
   <listitem>
    <para>
     volume channel
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>id</parameter></term>
   <listitem>
    <para>
     volume target id
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
</refentry>

<refentry id="API-SendEventNotification">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>July 2015</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>SendEventNotification</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.4.104</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>SendEventNotification</refname>
 <refpurpose>
     Send EventNotification (on or off) request to adapter
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>int <function>SendEventNotification </function></funcdef>
   <paramdef>MPT_ADAPTER * <parameter>ioc</parameter></paramdef>
   <paramdef>u8 <parameter>EvSwitch</parameter></paramdef>
   <paramdef>int <parameter>sleepFlag</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>ioc</parameter></term>
   <listitem>
    <para>
     Pointer to MPT_ADAPTER structure
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>EvSwitch</parameter></term>
   <listitem>
    <para>
     Event switch flags
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>sleepFlag</parameter></term>
   <listitem>
    <para>
     Specifies whether the process can sleep
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
</refentry>

<refentry id="API-SendEventAck">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>July 2015</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>SendEventAck</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.4.104</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>SendEventAck</refname>
 <refpurpose>
     Send EventAck request to MPT adapter.
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>int <function>SendEventAck </function></funcdef>
   <paramdef>MPT_ADAPTER * <parameter>ioc</parameter></paramdef>
   <paramdef>EventNotificationReply_t * <parameter>evnp</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>ioc</parameter></term>
   <listitem>
    <para>
     Pointer to MPT_ADAPTER structure
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>evnp</parameter></term>
   <listitem>
    <para>
     Pointer to original EventNotification request
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
</refentry>

<refentry id="API-mpt-ioc-reset">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>July 2015</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>mpt_ioc_reset</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.4.104</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>mpt_ioc_reset</refname>
 <refpurpose>
     Base cleanup for hard reset
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>int <function>mpt_ioc_reset </function></funcdef>
   <paramdef>MPT_ADAPTER * <parameter>ioc</parameter></paramdef>
   <paramdef>int <parameter>reset_phase</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>ioc</parameter></term>
   <listitem>
    <para>
     Pointer to the adapter structure
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>reset_phase</parameter></term>
   <listitem>
    <para>
     Indicates pre- or post-reset functionality
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
<title>Remark</title>
<para>
   Frees resources with internally generated commands.
</para>
</refsect1>
</refentry>

<refentry id="API-procmpt-create">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>July 2015</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>procmpt_create</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.4.104</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>procmpt_create</refname>
 <refpurpose>
     Create <constant>MPT_PROCFS_MPTBASEDIR</constant> entries.
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>int <function>procmpt_create </function></funcdef>
   <paramdef> <parameter>void</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>void</parameter></term>
   <listitem>
    <para>
     no arguments
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
<title>Description</title>
<para>
   </para><para>

   Returns 0 for success, non-zero for failure.
</para>
</refsect1>
</refentry>

<refentry id="API-procmpt-destroy">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>July 2015</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>procmpt_destroy</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.4.104</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>procmpt_destroy</refname>
 <refpurpose>
     Tear down <constant>MPT_PROCFS_MPTBASEDIR</constant> entries.
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>void <function>procmpt_destroy </function></funcdef>
   <paramdef> <parameter>void</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>void</parameter></term>
   <listitem>
    <para>
     no arguments
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
<title>Description</title>
<para>
   </para><para>

   Returns 0 for success, non-zero for failure.
</para>
</refsect1>
</refentry>

<refentry id="API-mpt-SoftResetHandler">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>July 2015</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>mpt_SoftResetHandler</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.4.104</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>mpt_SoftResetHandler</refname>
 <refpurpose>
     Issues a less expensive reset
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>int <function>mpt_SoftResetHandler </function></funcdef>
   <paramdef>MPT_ADAPTER * <parameter>ioc</parameter></paramdef>
   <paramdef>int <parameter>sleepFlag</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>ioc</parameter></term>
   <listitem>
    <para>
     Pointer to MPT_ADAPTER structure
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>sleepFlag</parameter></term>
   <listitem>
    <para>
     Indicates if sleep or schedule must be called.
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
<title>Description</title>
<para>
   Returns 0 for SUCCESS or -1 if FAILED.
   </para><para>

   Message Unit Reset - instructs the IOC to reset the Reply Post and
   Free FIFO's. All the Message Frames on Reply Free FIFO are discarded.
   All posted buffers are freed, and event notification is turned off.
   IOC doesn't reply to any outstanding request. This will transfer IOC
   to READY state.
</para>
</refsect1>
</refentry>

<refentry id="API-ProcessEventNotification">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>July 2015</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>ProcessEventNotification</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.4.104</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>ProcessEventNotification</refname>
 <refpurpose>
     Route EventNotificationReply to all event handlers
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>int <function>ProcessEventNotification </function></funcdef>
   <paramdef>MPT_ADAPTER * <parameter>ioc</parameter></paramdef>
   <paramdef>EventNotificationReply_t * <parameter>pEventReply</parameter></paramdef>
   <paramdef>int * <parameter>evHandlers</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>ioc</parameter></term>
   <listitem>
    <para>
     Pointer to MPT_ADAPTER structure
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>pEventReply</parameter></term>
   <listitem>
    <para>
     Pointer to EventNotification reply frame
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>evHandlers</parameter></term>
   <listitem>
    <para>
     Pointer to integer, number of event handlers
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
<title>Description</title>
<para>
   Routes a received EventNotificationReply to all currently registered
   event handlers.
   Returns sum of event handlers return values.
</para>
</refsect1>
</refentry>

<refentry id="API-mpt-fc-log-info">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>July 2015</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>mpt_fc_log_info</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.4.104</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>mpt_fc_log_info</refname>
 <refpurpose>
     Log information returned from Fibre Channel IOC.
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>void <function>mpt_fc_log_info </function></funcdef>
   <paramdef>MPT_ADAPTER * <parameter>ioc</parameter></paramdef>
   <paramdef>u32 <parameter>log_info</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>ioc</parameter></term>
   <listitem>
    <para>
     Pointer to MPT_ADAPTER structure
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>log_info</parameter></term>
   <listitem>
    <para>
     U32 LogInfo reply word from the IOC
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
<title>Description</title>
<para>
   Refer to lsi/mpi_log_fc.h.
</para>
</refsect1>
</refentry>

<refentry id="API-mpt-spi-log-info">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>July 2015</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>mpt_spi_log_info</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.4.104</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>mpt_spi_log_info</refname>
 <refpurpose>
     Log information returned from SCSI Parallel IOC.
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>void <function>mpt_spi_log_info </function></funcdef>
   <paramdef>MPT_ADAPTER * <parameter>ioc</parameter></paramdef>
   <paramdef>u32 <parameter>log_info</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>ioc</parameter></term>
   <listitem>
    <para>
     Pointer to MPT_ADAPTER structure
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>log_info</parameter></term>
   <listitem>
    <para>
     U32 LogInfo word from the IOC
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
<title>Description</title>
<para>
   Refer to lsi/sp_log.h.
</para>
</refsect1>
</refentry>

<refentry id="API-mpt-sas-log-info">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>July 2015</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>mpt_sas_log_info</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.4.104</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>mpt_sas_log_info</refname>
 <refpurpose>
     Log information returned from SAS IOC.
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>void <function>mpt_sas_log_info </function></funcdef>
   <paramdef>MPT_ADAPTER * <parameter>ioc</parameter></paramdef>
   <paramdef>u32 <parameter>log_info</parameter></paramdef>
   <paramdef>u8 <parameter>cb_idx</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>ioc</parameter></term>
   <listitem>
    <para>
     Pointer to MPT_ADAPTER structure
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>log_info</parameter></term>
   <listitem>
    <para>
     U32 LogInfo reply word from the IOC
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>cb_idx</parameter></term>
   <listitem>
    <para>
     callback function's handle
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
<title>Description</title>
<para>
   Refer to lsi/mpi_log_sas.h.
</para>
</refsect1>
</refentry>

<refentry id="API-mpt-iocstatus-info-config">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>July 2015</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>mpt_iocstatus_info_config</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.4.104</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>mpt_iocstatus_info_config</refname>
 <refpurpose>
     IOCSTATUS information for config pages
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>void <function>mpt_iocstatus_info_config </function></funcdef>
   <paramdef>MPT_ADAPTER * <parameter>ioc</parameter></paramdef>
   <paramdef>u32 <parameter>ioc_status</parameter></paramdef>
   <paramdef>MPT_FRAME_HDR * <parameter>mf</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>ioc</parameter></term>
   <listitem>
    <para>
     Pointer to MPT_ADAPTER structure
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>ioc_status</parameter></term>
   <listitem>
    <para>
     U32 IOCStatus word from IOC
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>mf</parameter></term>
   <listitem>
    <para>
     Pointer to MPT request frame
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
<title>Description</title>
<para>
   Refer to lsi/mpi.h.
</para>
</refsect1>
</refentry>

<refentry id="API-mpt-iocstatus-info">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>July 2015</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>mpt_iocstatus_info</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.4.104</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>mpt_iocstatus_info</refname>
 <refpurpose>
     IOCSTATUS information returned from IOC.
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>void <function>mpt_iocstatus_info </function></funcdef>
   <paramdef>MPT_ADAPTER * <parameter>ioc</parameter></paramdef>
   <paramdef>u32 <parameter>ioc_status</parameter></paramdef>
   <paramdef>MPT_FRAME_HDR * <parameter>mf</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>ioc</parameter></term>
   <listitem>
    <para>
     Pointer to MPT_ADAPTER structure
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>ioc_status</parameter></term>
   <listitem>
    <para>
     U32 IOCStatus word from IOC
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>mf</parameter></term>
   <listitem>
    <para>
     Pointer to MPT request frame
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
<title>Description</title>
<para>
   Refer to lsi/mpi.h.
</para>
</refsect1>
</refentry>

<refentry id="API-fusion-init">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>July 2015</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>fusion_init</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.4.104</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>fusion_init</refname>
 <refpurpose>
     Fusion MPT base driver initialization routine.
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>int <function>fusion_init </function></funcdef>
   <paramdef> <parameter>void</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>void</parameter></term>
   <listitem>
    <para>
     no arguments
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
<title>Description</title>
<para>
   </para><para>

   Returns 0 for success, non-zero for failure.
</para>
</refsect1>
</refentry>

<refentry id="API-fusion-exit">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>July 2015</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>fusion_exit</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.4.104</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>fusion_exit</refname>
 <refpurpose>
     Perform driver unload cleanup.
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>void __exit <function>fusion_exit </function></funcdef>
   <paramdef> <parameter>void</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>void</parameter></term>
   <listitem>
    <para>
     no arguments
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
<title>Description</title>
<para>
   </para><para>

   This routine frees all resources associated with each MPT adapter
   and removes all <constant>MPT_PROCFS_MPTBASEDIR</constant> entries.
</para>
</refsect1>
</refentry>

<!-- drivers/message/fusion/mptscsih.c -->
<refentry id="API-mptscsih-info">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>July 2015</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>mptscsih_info</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.4.104</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>mptscsih_info</refname>
 <refpurpose>
  Return information about MPT adapter
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>const char * <function>mptscsih_info </function></funcdef>
   <paramdef>struct Scsi_Host * <parameter>SChost</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>SChost</parameter></term>
   <listitem>
    <para>
     Pointer to Scsi_Host structure
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
<title>Description</title>
<para>
   (linux scsi_host_template.info routine)
   </para><para>

   Returns pointer to buffer where information was written.
</para>
</refsect1>
</refentry>

<refentry id="API-mptscsih-proc-info">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>July 2015</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>mptscsih_proc_info</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.4.104</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>mptscsih_proc_info</refname>
 <refpurpose>
     Return information about MPT adapter
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>int <function>mptscsih_proc_info </function></funcdef>
   <paramdef>struct Scsi_Host * <parameter>host</parameter></paramdef>
   <paramdef>char * <parameter>buffer</parameter></paramdef>
   <paramdef>char ** <parameter>start</parameter></paramdef>
   <paramdef>off_t <parameter>offset</parameter></paramdef>
   <paramdef>int <parameter>length</parameter></paramdef>
   <paramdef>int <parameter>func</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>host</parameter></term>
   <listitem>
    <para>
     scsi host struct
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>buffer</parameter></term>
   <listitem>
    <para>
     if write, user data; if read, buffer for user
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>start</parameter></term>
   <listitem>
    <para>
     returns the buffer address
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>offset</parameter></term>
   <listitem>
    <para>
     if write, 0; if read, the current offset into the buffer from
     the previous read.
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>length</parameter></term>
   <listitem>
    <para>
     if write, return length;
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>func</parameter></term>
   <listitem>
    <para>
     write = 1; read = 0
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
<title>Description</title>
<para>
   (linux scsi_host_template.info routine)
</para>
</refsect1>
</refentry>

<refentry id="API-mptscsih-qcmd">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>July 2015</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>mptscsih_qcmd</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.4.104</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>mptscsih_qcmd</refname>
 <refpurpose>
     Primary Fusion MPT SCSI initiator IO start routine.
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>int <function>mptscsih_qcmd </function></funcdef>
   <paramdef>struct scsi_cmnd * <parameter>SCpnt</parameter></paramdef>
   <paramdef>void (*<parameter>done</parameter>)
     <funcparams>struct scsi_cmnd *</funcparams></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>SCpnt</parameter></term>
   <listitem>
    <para>
     Pointer to scsi_cmnd structure
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>done</parameter></term>
   <listitem>
    <para>
     Pointer SCSI mid-layer IO completion function
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
<title>Description</title>
<para>
   (linux scsi_host_template.queuecommand routine)
   This is the primary SCSI IO start routine.  Create a MPI SCSIIORequest
   from a linux scsi_cmnd request and send it to the IOC.
   </para><para>

   Returns 0. (rtn value discarded by linux scsi mid-layer)
</para>
</refsect1>
</refentry>

<refentry id="API-mptscsih-IssueTaskMgmt">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>July 2015</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>mptscsih_IssueTaskMgmt</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.4.104</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>mptscsih_IssueTaskMgmt</refname>
 <refpurpose>
     Generic send Task Management function.
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>int <function>mptscsih_IssueTaskMgmt </function></funcdef>
   <paramdef>MPT_SCSI_HOST * <parameter>hd</parameter></paramdef>
   <paramdef>u8 <parameter>type</parameter></paramdef>
   <paramdef>u8 <parameter>channel</parameter></paramdef>
   <paramdef>u8 <parameter>id</parameter></paramdef>
   <paramdef>int <parameter>lun</parameter></paramdef>
   <paramdef>int <parameter>ctx2abort</parameter></paramdef>
   <paramdef>ulong <parameter>timeout</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>hd</parameter></term>
   <listitem>
    <para>
     Pointer to MPT_SCSI_HOST structure
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>type</parameter></term>
   <listitem>
    <para>
     Task Management type
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>channel</parameter></term>
   <listitem>
    <para>
     channel number for task management
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>id</parameter></term>
   <listitem>
    <para>
     Logical Target ID for reset (if appropriate)
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>lun</parameter></term>
   <listitem>
    <para>
     Logical Unit for reset (if appropriate)
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>ctx2abort</parameter></term>
   <listitem>
    <para>
     Context for the task to be aborted (if appropriate)
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>timeout</parameter></term>
   <listitem>
    <para>
     timeout for task management control
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
<title>Remark</title>
<para>
   _HardResetHandler can be invoked from an interrupt thread (timer)
   or a non-interrupt thread.  In the former, must not call <function>schedule</function>.
   </para><para>

   Not all fields are meaningfull for all task types.
   </para><para>

   Returns 0 for SUCCESS, or FAILED.
</para>
</refsect1>
</refentry>

<refentry id="API-mptscsih-abort">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>July 2015</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>mptscsih_abort</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.4.104</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>mptscsih_abort</refname>
 <refpurpose>
     Abort linux scsi_cmnd routine, new_eh variant
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>int <function>mptscsih_abort </function></funcdef>
   <paramdef>struct scsi_cmnd * <parameter>SCpnt</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>SCpnt</parameter></term>
   <listitem>
    <para>
     Pointer to scsi_cmnd structure, IO to be aborted
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
<title>Description</title>
<para>
   (linux scsi_host_template.eh_abort_handler routine)
   </para><para>

   Returns SUCCESS or FAILED.
</para>
</refsect1>
</refentry>

<refentry id="API-mptscsih-dev-reset">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>July 2015</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>mptscsih_dev_reset</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.4.104</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>mptscsih_dev_reset</refname>
 <refpurpose>
     Perform a SCSI TARGET_RESET!  new_eh variant
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>int <function>mptscsih_dev_reset </function></funcdef>
   <paramdef>struct scsi_cmnd * <parameter>SCpnt</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>SCpnt</parameter></term>
   <listitem>
    <para>
     Pointer to scsi_cmnd structure, IO which reset is due to
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
<title>Description</title>
<para>
   (linux scsi_host_template.eh_dev_reset_handler routine)
   </para><para>

   Returns SUCCESS or FAILED.
</para>
</refsect1>
</refentry>

<refentry id="API-mptscsih-bus-reset">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>July 2015</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>mptscsih_bus_reset</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.4.104</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>mptscsih_bus_reset</refname>
 <refpurpose>
     Perform a SCSI BUS_RESET!	new_eh variant
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>int <function>mptscsih_bus_reset </function></funcdef>
   <paramdef>struct scsi_cmnd * <parameter>SCpnt</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>SCpnt</parameter></term>
   <listitem>
    <para>
     Pointer to scsi_cmnd structure, IO which reset is due to
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
<title>Description</title>
<para>
   (linux scsi_host_template.eh_bus_reset_handler routine)
   </para><para>

   Returns SUCCESS or FAILED.
</para>
</refsect1>
</refentry>

<refentry id="API-mptscsih-host-reset">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>July 2015</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>mptscsih_host_reset</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.4.104</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>mptscsih_host_reset</refname>
 <refpurpose>
     Perform a SCSI host adapter RESET (new_eh variant)
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>int <function>mptscsih_host_reset </function></funcdef>
   <paramdef>struct scsi_cmnd * <parameter>SCpnt</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>SCpnt</parameter></term>
   <listitem>
    <para>
     Pointer to scsi_cmnd structure, IO which reset is due to
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
<title>Description</title>
<para>
   (linux scsi_host_template.eh_host_reset_handler routine)
   </para><para>

   Returns SUCCESS or FAILED.
</para>
</refsect1>
</refentry>

<refentry id="API-mptscsih-taskmgmt-complete">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>July 2015</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>mptscsih_taskmgmt_complete</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.4.104</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>mptscsih_taskmgmt_complete</refname>
 <refpurpose>
     Registered with Fusion MPT base driver
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>int <function>mptscsih_taskmgmt_complete </function></funcdef>
   <paramdef>MPT_ADAPTER * <parameter>ioc</parameter></paramdef>
   <paramdef>MPT_FRAME_HDR * <parameter>mf</parameter></paramdef>
   <paramdef>MPT_FRAME_HDR * <parameter>mr</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>ioc</parameter></term>
   <listitem>
    <para>
     Pointer to MPT_ADAPTER structure
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>mf</parameter></term>
   <listitem>
    <para>
     Pointer to SCSI task mgmt request frame
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>mr</parameter></term>
   <listitem>
    <para>
     Pointer to SCSI task mgmt reply frame
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
<title>Description</title>
<para>
   This routine is called from mptbase.c::<function>mpt_interrupt</function> at the completion
   of any SCSI task management request.
   This routine is registered with the MPT (base) driver at driver
   load/init time via the <function>mpt_register</function> API call.
   </para><para>

   Returns 1 indicating alloc'd request frame ptr should be freed.
</para>
</refsect1>
</refentry>

<refentry id="API-mptscsih-get-scsi-lookup">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>July 2015</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>mptscsih_get_scsi_lookup</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.4.104</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>mptscsih_get_scsi_lookup</refname>
 <refpurpose>
     retrieves scmd entry
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>struct scsi_cmnd * <function>mptscsih_get_scsi_lookup </function></funcdef>
   <paramdef>MPT_ADAPTER * <parameter>ioc</parameter></paramdef>
   <paramdef>int <parameter>i</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>ioc</parameter></term>
   <listitem>
    <para>
     Pointer to MPT_ADAPTER structure
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>i</parameter></term>
   <listitem>
    <para>
     index into the array
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
<title>Description</title>
<para>
   Returns the scsi_cmd pointer
</para>
</refsect1>
</refentry>

<!-- drivers/message/fusion/mptscsih.c -->
<refentry id="API-mptscsih-info-scsiio">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>July 2015</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>mptscsih_info_scsiio</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.4.104</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>mptscsih_info_scsiio</refname>
 <refpurpose>
  debug print info on reply frame
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>void <function>mptscsih_info_scsiio </function></funcdef>
   <paramdef>MPT_ADAPTER * <parameter>ioc</parameter></paramdef>
   <paramdef>struct scsi_cmnd * <parameter>sc</parameter></paramdef>
   <paramdef>SCSIIOReply_t * <parameter>pScsiReply</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>ioc</parameter></term>
   <listitem>
    <para>
     Pointer to MPT_ADAPTER structure
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>sc</parameter></term>
   <listitem>
    <para>
     original scsi cmnd pointer
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>pScsiReply</parameter></term>
   <listitem>
    <para>
     Pointer to MPT reply frame
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
<title>Description</title>
<para>
   MPT_DEBUG_REPLY needs to be enabled to obtain this info
   </para><para>

   Refer to lsi/mpi.h.
</para>
</refsect1>
</refentry>

<refentry id="API-mptscsih-getclear-scsi-lookup">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>July 2015</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>mptscsih_getclear_scsi_lookup</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.4.104</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>mptscsih_getclear_scsi_lookup</refname>
 <refpurpose>
     retrieves and clears scmd entry from ScsiLookup[] array list
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>struct scsi_cmnd * <function>mptscsih_getclear_scsi_lookup </function></funcdef>
   <paramdef>MPT_ADAPTER * <parameter>ioc</parameter></paramdef>
   <paramdef>int <parameter>i</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>ioc</parameter></term>
   <listitem>
    <para>
     Pointer to MPT_ADAPTER structure
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>i</parameter></term>
   <listitem>
    <para>
     index into the array
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
<title>Description</title>
<para>
   Returns the scsi_cmd pointer
</para>
</refsect1>
</refentry>

<refentry id="API-mptscsih-set-scsi-lookup">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>July 2015</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>mptscsih_set_scsi_lookup</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.4.104</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>mptscsih_set_scsi_lookup</refname>
 <refpurpose>
     write a scmd entry into the ScsiLookup[] array list
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>void <function>mptscsih_set_scsi_lookup </function></funcdef>
   <paramdef>MPT_ADAPTER * <parameter>ioc</parameter></paramdef>
   <paramdef>int <parameter>i</parameter></paramdef>
   <paramdef>struct scsi_cmnd * <parameter>scmd</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>ioc</parameter></term>
   <listitem>
    <para>
     Pointer to MPT_ADAPTER structure
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>i</parameter></term>
   <listitem>
    <para>
     index into the array
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>scmd</parameter></term>
   <listitem>
    <para>
     scsi_cmnd pointer
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
</refentry>

<refentry id="API-SCPNT-TO-LOOKUP-IDX">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>July 2015</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>SCPNT_TO_LOOKUP_IDX</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.4.104</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>SCPNT_TO_LOOKUP_IDX</refname>
 <refpurpose>
     searches for a given scmd in the ScsiLookup[] array list
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>int <function>SCPNT_TO_LOOKUP_IDX </function></funcdef>
   <paramdef>MPT_ADAPTER * <parameter>ioc</parameter></paramdef>
   <paramdef>struct scsi_cmnd * <parameter>sc</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>ioc</parameter></term>
   <listitem>
    <para>
     Pointer to MPT_ADAPTER structure
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>sc</parameter></term>
   <listitem>
    <para>
     scsi_cmnd pointer
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
</refentry>

<refentry id="API-mptscsih-get-completion-code">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>July 2015</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>mptscsih_get_completion_code</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.4.104</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>mptscsih_get_completion_code</refname>
 <refpurpose>
     get completion code from MPT request
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>int <function>mptscsih_get_completion_code </function></funcdef>
   <paramdef>MPT_ADAPTER * <parameter>ioc</parameter></paramdef>
   <paramdef>MPT_FRAME_HDR * <parameter>req</parameter></paramdef>
   <paramdef>MPT_FRAME_HDR * <parameter>reply</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>ioc</parameter></term>
   <listitem>
    <para>
     Pointer to MPT_ADAPTER structure
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>req</parameter></term>
   <listitem>
    <para>
     Pointer to original MPT request frame
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>reply</parameter></term>
   <listitem>
    <para>
     Pointer to MPT reply frame (NULL if TurboReply)
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
</refentry>

<refentry id="API-mptscsih-do-cmd">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>July 2015</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>mptscsih_do_cmd</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.4.104</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>mptscsih_do_cmd</refname>
 <refpurpose>
     Do internal command.
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>int <function>mptscsih_do_cmd </function></funcdef>
   <paramdef>MPT_SCSI_HOST * <parameter>hd</parameter></paramdef>
   <paramdef>INTERNAL_CMD * <parameter>io</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>hd</parameter></term>
   <listitem>
    <para>
     MPT_SCSI_HOST pointer
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>io</parameter></term>
   <listitem>
    <para>
     INTERNAL_CMD pointer.
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
<title>Description</title>
<para>
   Issue the specified internally generated command and do command
   specific cleanup. For bus scan / DV only.
</para>
</refsect1>
<refsect1>
<title>NOTES</title>
<para>
   If command is Inquiry and status is good,
   initialize a target structure, save the data
</para>
</refsect1>
<refsect1>
<title>Remark</title>
<para>
   Single threaded access only.
</para>
</refsect1>
<refsect1>
<title>Return</title>
<para>
   &lt; 0 if an illegal command or no resources
   </para><para>

   0 if good
   </para><para>

   &gt; 0 if command complete but some type of completion error.
</para>
</refsect1>
</refentry>

<refentry id="API-mptscsih-synchronize-cache">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>July 2015</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>mptscsih_synchronize_cache</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.4.104</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>mptscsih_synchronize_cache</refname>
 <refpurpose>
     Send SYNCHRONIZE_CACHE to all disks.
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>void <function>mptscsih_synchronize_cache </function></funcdef>
   <paramdef>MPT_SCSI_HOST * <parameter>hd</parameter></paramdef>
   <paramdef>VirtDevice * <parameter>vdevice</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>hd</parameter></term>
   <listitem>
    <para>
     Pointer to a SCSI HOST structure
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>vdevice</parameter></term>
   <listitem>
    <para>
     virtual target device
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
<title>Description</title>
<para>
   Uses the ISR, but with special processing.
   MUST be single-threaded.
</para>
</refsect1>
</refentry>

<!-- drivers/message/fusion/mptctl.c -->
<refentry id="API-mptctl-syscall-down">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>July 2015</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>mptctl_syscall_down</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.4.104</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>mptctl_syscall_down</refname>
 <refpurpose>
  Down the MPT adapter syscall semaphore.
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>int <function>mptctl_syscall_down </function></funcdef>
   <paramdef>MPT_ADAPTER * <parameter>ioc</parameter></paramdef>
   <paramdef>int <parameter>nonblock</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>ioc</parameter></term>
   <listitem>
    <para>
     Pointer to MPT adapter
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>nonblock</parameter></term>
   <listitem>
    <para>
     boolean, non-zero if O_NONBLOCK is set
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
<title>Description</title>
<para>
   All of the ioctl commands can potentially sleep, which is illegal
   with a spinlock held, thus we perform mutual exclusion here.
   </para><para>

   Returns negative errno on error, or zero for success.
</para>
</refsect1>
</refentry>

<!-- drivers/message/fusion/mptspi.c -->
<refentry id="API-mptspi-setTargetNegoParms">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>July 2015</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>mptspi_setTargetNegoParms</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.4.104</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>mptspi_setTargetNegoParms</refname>
 <refpurpose>
  Update the target negotiation parameters
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>void <function>mptspi_setTargetNegoParms </function></funcdef>
   <paramdef>MPT_SCSI_HOST * <parameter>hd</parameter></paramdef>
   <paramdef>VirtTarget * <parameter>target</parameter></paramdef>
   <paramdef>struct scsi_device * <parameter>sdev</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>hd</parameter></term>
   <listitem>
    <para>
     Pointer to a SCSI Host Structure
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>target</parameter></term>
   <listitem>
    <para>
     per target private data
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>sdev</parameter></term>
   <listitem>
    <para>
     SCSI device
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
<title>Description</title>
<para>
   Update the target negotiation parameters based on the the Inquiry
   data, adapter capabilities, and NVRAM settings.
</para>
</refsect1>
</refentry>

<refentry id="API-mptspi-writeIOCPage4">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>July 2015</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>mptspi_writeIOCPage4</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.4.104</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>mptspi_writeIOCPage4</refname>
 <refpurpose>
     write IOC Page 4
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>int <function>mptspi_writeIOCPage4 </function></funcdef>
   <paramdef>MPT_SCSI_HOST * <parameter>hd</parameter></paramdef>
   <paramdef>u8 <parameter>channel</parameter></paramdef>
   <paramdef>u8 <parameter>id</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>hd</parameter></term>
   <listitem>
    <para>
     Pointer to a SCSI Host Structure
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>channel</parameter></term>
   <listitem>
    <para>
     channel number
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>id</parameter></term>
   <listitem>
    <para>
     write IOC Page4 for this ID &amp; Bus
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
<title>Return</title>
<para>
   -EAGAIN if unable to obtain a Message Frame
   or 0 if success.
</para>
</refsect1>
<refsect1>
<title>Remark</title>
<para>
   We do not wait for a return, write pages sequentially.
</para>
</refsect1>
</refentry>

<refentry id="API-mptspi-initTarget">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>July 2015</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>mptspi_initTarget</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.4.104</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>mptspi_initTarget</refname>
 <refpurpose>
     Target, LUN alloc/free functionality.
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>void <function>mptspi_initTarget </function></funcdef>
   <paramdef>MPT_SCSI_HOST * <parameter>hd</parameter></paramdef>
   <paramdef>VirtTarget * <parameter>vtarget</parameter></paramdef>
   <paramdef>struct scsi_device * <parameter>sdev</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>hd</parameter></term>
   <listitem>
    <para>
     Pointer to MPT_SCSI_HOST structure
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>vtarget</parameter></term>
   <listitem>
    <para>
     per target private data
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>sdev</parameter></term>
   <listitem>
    <para>
     SCSI device
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
<title>NOTE</title>
<para>
   It's only SAFE to call this routine if data points to
   sane &amp; valid STANDARD INQUIRY data!
   </para><para>

   Allocate and initialize memory for this target.
   Save inquiry data.
</para>
</refsect1>
</refentry>

<refentry id="API-mptspi-is-raid">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>July 2015</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>mptspi_is_raid</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.4.104</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>mptspi_is_raid</refname>
 <refpurpose>
     Determines whether target is belonging to volume
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>int <function>mptspi_is_raid </function></funcdef>
   <paramdef>struct _MPT_SCSI_HOST * <parameter>hd</parameter></paramdef>
   <paramdef>u32 <parameter>id</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>hd</parameter></term>
   <listitem>
    <para>
     Pointer to a SCSI HOST structure
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>id</parameter></term>
   <listitem>
    <para>
     target device id
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
<title>Return</title>
<para>
   non-zero = true
   zero = false
</para>
</refsect1>
</refentry>

<refentry id="API-mptspi-print-write-nego">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>July 2015</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>mptspi_print_write_nego</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.4.104</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>mptspi_print_write_nego</refname>
 <refpurpose>
     negotiation parameters debug info that is being sent
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>void <function>mptspi_print_write_nego </function></funcdef>
   <paramdef>struct _MPT_SCSI_HOST * <parameter>hd</parameter></paramdef>
   <paramdef>struct scsi_target * <parameter>starget</parameter></paramdef>
   <paramdef>u32 <parameter>ii</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>hd</parameter></term>
   <listitem>
    <para>
     Pointer to a SCSI HOST structure
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>starget</parameter></term>
   <listitem>
    <para>
     SCSI target
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>ii</parameter></term>
   <listitem>
    <para>
     negotiation parameters
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
</refentry>

<refentry id="API-mptspi-print-read-nego">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>July 2015</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>mptspi_print_read_nego</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.4.104</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>mptspi_print_read_nego</refname>
 <refpurpose>
     negotiation parameters debug info that is being read
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>void <function>mptspi_print_read_nego </function></funcdef>
   <paramdef>struct _MPT_SCSI_HOST * <parameter>hd</parameter></paramdef>
   <paramdef>struct scsi_target * <parameter>starget</parameter></paramdef>
   <paramdef>u32 <parameter>ii</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>hd</parameter></term>
   <listitem>
    <para>
     Pointer to a SCSI HOST structure
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>starget</parameter></term>
   <listitem>
    <para>
     SCSI target
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>ii</parameter></term>
   <listitem>
    <para>
     negotiation parameters
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
</refentry>

<refentry id="API-mptspi-init">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>July 2015</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>mptspi_init</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.4.104</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>mptspi_init</refname>
 <refpurpose>
     Register MPT adapter(s) as SCSI host(s) with SCSI mid-layer.
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>int <function>mptspi_init </function></funcdef>
   <paramdef> <parameter>void</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>void</parameter></term>
   <listitem>
    <para>
     no arguments
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
<title>Description</title>
<para>
   </para><para>

   Returns 0 for success, non-zero for failure.
</para>
</refsect1>
</refentry>

<refentry id="API-mptspi-exit">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>July 2015</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>mptspi_exit</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.4.104</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>mptspi_exit</refname>
 <refpurpose>
     Unregisters MPT adapter(s)
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>void __exit <function>mptspi_exit </function></funcdef>
   <paramdef> <parameter>void</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>void</parameter></term>
   <listitem>
    <para>
     no arguments
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
</refentry>

<!-- drivers/message/fusion/mptfc.c -->
<refentry id="API-mptfc-init">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>July 2015</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>mptfc_init</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.4.104</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>mptfc_init</refname>
 <refpurpose>
  Register MPT adapter(s) as SCSI host(s) with SCSI mid-layer.
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>int <function>mptfc_init </function></funcdef>
   <paramdef> <parameter>void</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>void</parameter></term>
   <listitem>
    <para>
     no arguments
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
<title>Description</title>
<para>
   </para><para>

   Returns 0 for success, non-zero for failure.
</para>
</refsect1>
</refentry>

<refentry id="API-mptfc-remove">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>July 2015</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>mptfc_remove</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.4.104</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>mptfc_remove</refname>
 <refpurpose>
     Remove fc infrastructure for devices
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>void __devexit <function>mptfc_remove </function></funcdef>
   <paramdef>struct pci_dev * <parameter>pdev</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>pdev</parameter></term>
   <listitem>
    <para>
     Pointer to pci_dev structure
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
</refentry>

<refentry id="API-mptfc-exit">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>July 2015</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>mptfc_exit</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.4.104</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>mptfc_exit</refname>
 <refpurpose>
     Unregisters MPT adapter(s)
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>void __exit <function>mptfc_exit </function></funcdef>
   <paramdef> <parameter>void</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>void</parameter></term>
   <listitem>
    <para>
     no arguments
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
</refentry>

<!-- drivers/message/fusion/mptlan.c -->
<refentry id="API-lan-reply">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>July 2015</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>lan_reply</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.4.104</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>lan_reply</refname>
 <refpurpose>
  Handle all data sent from the hardware.
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>int <function>lan_reply </function></funcdef>
   <paramdef>MPT_ADAPTER * <parameter>ioc</parameter></paramdef>
   <paramdef>MPT_FRAME_HDR * <parameter>mf</parameter></paramdef>
   <paramdef>MPT_FRAME_HDR * <parameter>reply</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>ioc</parameter></term>
   <listitem>
    <para>
     Pointer to MPT_ADAPTER structure
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>mf</parameter></term>
   <listitem>
    <para>
     Pointer to original MPT request frame (NULL if TurboReply)
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>reply</parameter></term>
   <listitem>
    <para>
     Pointer to MPT reply frame
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
<title>Description</title>
<para>
   Returns 1 indicating original alloc'd request frame ptr
   should be freed, or 0 if it shouldn't.
</para>
</refsect1>
</refentry>

     </sect1>
     <sect1><title>I2O message devices</title>
<!-- include/linux/i2o.h -->
<refentry id="API-i2o-driver-notify-controller-add">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>July 2015</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>i2o_driver_notify_controller_add</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.4.104</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>i2o_driver_notify_controller_add</refname>
 <refpurpose>
  Send notification of added controller
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>void <function>i2o_driver_notify_controller_add </function></funcdef>
   <paramdef>struct i2o_driver * <parameter>drv</parameter></paramdef>
   <paramdef>struct i2o_controller * <parameter>c</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>drv</parameter></term>
   <listitem>
    <para>
     I2O driver
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>c</parameter></term>
   <listitem>
    <para>
     I2O controller
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
<title>Description</title>
<para>
   Send notification of added controller to a single registered driver.
</para>
</refsect1>
</refentry>

<refentry id="API-i2o-driver-notify-controller-remove">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>July 2015</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>i2o_driver_notify_controller_remove</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.4.104</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>i2o_driver_notify_controller_remove</refname>
 <refpurpose>
     Send notification of removed controller
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>void <function>i2o_driver_notify_controller_remove </function></funcdef>
   <paramdef>struct i2o_driver * <parameter>drv</parameter></paramdef>
   <paramdef>struct i2o_controller * <parameter>c</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>drv</parameter></term>
   <listitem>
    <para>
     I2O driver
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>c</parameter></term>
   <listitem>
    <para>
     I2O controller
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
<title>Description</title>
<para>
   Send notification of removed controller to a single registered driver.
</para>
</refsect1>
</refentry>

<refentry id="API-i2o-driver-notify-device-add">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>July 2015</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>i2o_driver_notify_device_add</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.4.104</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>i2o_driver_notify_device_add</refname>
 <refpurpose>
     Send notification of added device
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>void <function>i2o_driver_notify_device_add </function></funcdef>
   <paramdef>struct i2o_driver * <parameter>drv</parameter></paramdef>
   <paramdef>struct i2o_device * <parameter>i2o_dev</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>drv</parameter></term>
   <listitem>
    <para>
     I2O driver
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>i2o_dev</parameter></term>
   <listitem>
    <para>
     the added i2o_device
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
<title>Description</title>
<para>
   Send notification of added device to a single registered driver.
</para>
</refsect1>
</refentry>

<refentry id="API-i2o-driver-notify-device-remove">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>July 2015</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>i2o_driver_notify_device_remove</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.4.104</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>i2o_driver_notify_device_remove</refname>
 <refpurpose>
     Send notification of removed device
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>void <function>i2o_driver_notify_device_remove </function></funcdef>
   <paramdef>struct i2o_driver * <parameter>drv</parameter></paramdef>
   <paramdef>struct i2o_device * <parameter>i2o_dev</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>drv</parameter></term>
   <listitem>
    <para>
     I2O driver
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>i2o_dev</parameter></term>
   <listitem>
    <para>
     the added i2o_device
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
<title>Description</title>
<para>
   Send notification of removed device to a single registered driver.
</para>
</refsect1>
</refentry>

<refentry id="API-i2o-msg-out-to-virt">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>July 2015</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>i2o_msg_out_to_virt</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.4.104</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>i2o_msg_out_to_virt</refname>
 <refpurpose>
     Turn an I2O message to a virtual address
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>struct i2o_message * <function>i2o_msg_out_to_virt </function></funcdef>
   <paramdef>struct i2o_controller * <parameter>c</parameter></paramdef>
   <paramdef>u32 <parameter>m</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>c</parameter></term>
   <listitem>
    <para>
     controller
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>m</parameter></term>
   <listitem>
    <para>
     message engine value
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
<title>Description</title>
<para>
   Turn a receive message from an I2O controller bus address into
   a Linux virtual address. The shared page frame is a linear block
   so we simply have to shift the offset. This function does not
   work for sender side messages as they are ioremap objects
   provided by the I2O controller.
</para>
</refsect1>
</refentry>

<refentry id="API-i2o-msg-in-to-virt">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>July 2015</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>i2o_msg_in_to_virt</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.4.104</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>i2o_msg_in_to_virt</refname>
 <refpurpose>
     Turn an I2O message to a virtual address
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>struct i2o_message __iomem * <function>i2o_msg_in_to_virt </function></funcdef>
   <paramdef>struct i2o_controller * <parameter>c</parameter></paramdef>
   <paramdef>u32 <parameter>m</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>c</parameter></term>
   <listitem>
    <para>
     controller
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>m</parameter></term>
   <listitem>
    <para>
     message engine value
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
<title>Description</title>
<para>
   Turn a send message from an I2O controller bus address into
   a Linux virtual address. The shared page frame is a linear block
   so we simply have to shift the offset. This function does not
   work for receive side messages as they are kmalloc objects
   in a different pool.
</para>
</refsect1>
</refentry>

<refentry id="API-i2o-msg-get">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>July 2015</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>i2o_msg_get</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.4.104</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>i2o_msg_get</refname>
 <refpurpose>
     obtain an I2O message from the IOP
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>struct i2o_message * <function>i2o_msg_get </function></funcdef>
   <paramdef>struct i2o_controller * <parameter>c</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>c</parameter></term>
   <listitem>
    <para>
     I2O controller
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
<title>Description</title>
<para>
   This function tries to get a message frame. If no message frame is
   available do not wait until one is available (see also i2o_msg_get_wait).
   The returned pointer to the message frame is not in I/O memory, it is
   allocated from a mempool. But because a MFA is allocated from the
   controller too it is guaranteed that <function>i2o_msg_post</function> will never fail.
   </para><para>

   On a success a pointer to the message frame is returned. If the message
   queue is empty -EBUSY is returned and if no memory is available -ENOMEM
   is returned.
</para>
</refsect1>
</refentry>

<refentry id="API-i2o-msg-post">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>July 2015</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>i2o_msg_post</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.4.104</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>i2o_msg_post</refname>
 <refpurpose>
     Post I2O message to I2O controller
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>void <function>i2o_msg_post </function></funcdef>
   <paramdef>struct i2o_controller * <parameter>c</parameter></paramdef>
   <paramdef>struct i2o_message * <parameter>msg</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>c</parameter></term>
   <listitem>
    <para>
     I2O controller to which the message should be send
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>msg</parameter></term>
   <listitem>
    <para>
     message returned by <function>i2o_msg_get</function>
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
<title>Description</title>
<para>
   Post the message to the I2O controller and return immediately.
</para>
</refsect1>
</refentry>

<refentry id="API-i2o-msg-post-wait">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>July 2015</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>i2o_msg_post_wait</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.4.104</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>i2o_msg_post_wait</refname>
 <refpurpose>
     Post and wait a message and wait until return
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>int <function>i2o_msg_post_wait </function></funcdef>
   <paramdef>struct i2o_controller * <parameter>c</parameter></paramdef>
   <paramdef>struct i2o_message * <parameter>msg</parameter></paramdef>
   <paramdef>unsigned long <parameter>timeout</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>c</parameter></term>
   <listitem>
    <para>
     controller
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>msg</parameter></term>
   <listitem>
    <para>
     message to post
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>timeout</parameter></term>
   <listitem>
    <para>
     time in seconds to wait
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
<title>Description</title>
<para>
   This API allows an OSM to post a message and then be told whether or
   not the system received a successful reply. If the message times out
   then the value '-ETIMEDOUT' is returned.
   </para><para>

   Returns 0 on success or negative error code on failure.
</para>
</refsect1>
</refentry>

<refentry id="API-i2o-msg-nop-mfa">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>July 2015</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>i2o_msg_nop_mfa</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.4.104</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>i2o_msg_nop_mfa</refname>
 <refpurpose>
     Returns a fetched MFA back to the controller
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>void <function>i2o_msg_nop_mfa </function></funcdef>
   <paramdef>struct i2o_controller * <parameter>c</parameter></paramdef>
   <paramdef>u32 <parameter>mfa</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>c</parameter></term>
   <listitem>
    <para>
     I2O controller from which the MFA was fetched
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>mfa</parameter></term>
   <listitem>
    <para>
     MFA which should be returned
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
<title>Description</title>
<para>
   This function must be used for preserved messages, because <function>i2o_msg_nop</function>
   also returns the allocated memory back to the msg_pool mempool.
</para>
</refsect1>
</refentry>

<refentry id="API-i2o-msg-nop">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>July 2015</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>i2o_msg_nop</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.4.104</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>i2o_msg_nop</refname>
 <refpurpose>
     Returns a message which is not used
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>void <function>i2o_msg_nop </function></funcdef>
   <paramdef>struct i2o_controller * <parameter>c</parameter></paramdef>
   <paramdef>struct i2o_message * <parameter>msg</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>c</parameter></term>
   <listitem>
    <para>
     I2O controller from which the message was created
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>msg</parameter></term>
   <listitem>
    <para>
     message which should be returned
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
<title>Description</title>
<para>
   If you fetch a message via i2o_msg_get, and can't use it, you must
   return the message with this function. Otherwise the MFA is lost as well
   as the allocated memory from the mempool.
</para>
</refsect1>
</refentry>

<refentry id="API-i2o-flush-reply">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>July 2015</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>i2o_flush_reply</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.4.104</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>i2o_flush_reply</refname>
 <refpurpose>
     Flush reply from I2O controller
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>void <function>i2o_flush_reply </function></funcdef>
   <paramdef>struct i2o_controller * <parameter>c</parameter></paramdef>
   <paramdef>u32 <parameter>m</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>c</parameter></term>
   <listitem>
    <para>
     I2O controller
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>m</parameter></term>
   <listitem>
    <para>
     the message identifier
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
<title>Description</title>
<para>
   The I2O controller must be informed that the reply message is not needed
   anymore. If you forget to flush the reply, the message frame can't be
   used by the controller anymore and is therefore lost.
</para>
</refsect1>
</refentry>

<!-- drivers/message/i2o/core.h -->
<refentry id="API-i2o-iop-free">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>July 2015</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>i2o_iop_free</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.4.104</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>i2o_iop_free</refname>
 <refpurpose>
  Free the i2o_controller struct
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>void <function>i2o_iop_free </function></funcdef>
   <paramdef>struct i2o_controller * <parameter>c</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>c</parameter></term>
   <listitem>
    <para>
     I2O controller to free
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
</refentry>

<!-- drivers/message/i2o/iop.c -->
<refentry id="API-i2o-msg-get-wait">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>July 2015</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>i2o_msg_get_wait</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.4.104</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>i2o_msg_get_wait</refname>
 <refpurpose>
  obtain an I2O message from the IOP
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>struct i2o_message * <function>i2o_msg_get_wait </function></funcdef>
   <paramdef>struct i2o_controller * <parameter>c</parameter></paramdef>
   <paramdef>int <parameter>wait</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>c</parameter></term>
   <listitem>
    <para>
     I2O controller
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>wait</parameter></term>
   <listitem>
    <para>
     how long to wait until timeout
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
<title>Description</title>
<para>
   This function waits up to wait seconds for a message slot to be
   available.
   </para><para>

   On a success the message is returned and the pointer to the message is
   set in msg. The returned message is the physical page frame offset
   address from the read port (see the i2o spec). If no message is
   available returns I2O_QUEUE_EMPTY and msg is leaved untouched.
</para>
</refsect1>
</refentry>

<refentry id="API-i2o-cntxt-list-add">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>July 2015</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>i2o_cntxt_list_add</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.4.104</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>i2o_cntxt_list_add</refname>
 <refpurpose>
     Append a pointer to context list and return a id
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>u32 <function>i2o_cntxt_list_add </function></funcdef>
   <paramdef>struct i2o_controller * <parameter>c</parameter></paramdef>
   <paramdef>void * <parameter>ptr</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>c</parameter></term>
   <listitem>
    <para>
     controller to which the context list belong
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>ptr</parameter></term>
   <listitem>
    <para>
     pointer to add to the context list
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
<title>Description</title>
<para>
   Because the context field in I2O is only 32-bit large, on 64-bit the
   pointer is to large to fit in the context field. The i2o_cntxt_list
   functions therefore map pointers to context fields.
   </para><para>

   Returns context id &gt; 0 on success or 0 on failure.
</para>
</refsect1>
</refentry>

<refentry id="API-i2o-cntxt-list-remove">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>July 2015</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>i2o_cntxt_list_remove</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.4.104</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>i2o_cntxt_list_remove</refname>
 <refpurpose>
     Remove a pointer from the context list
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>u32 <function>i2o_cntxt_list_remove </function></funcdef>
   <paramdef>struct i2o_controller * <parameter>c</parameter></paramdef>
   <paramdef>void * <parameter>ptr</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>c</parameter></term>
   <listitem>
    <para>
     controller to which the context list belong
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>ptr</parameter></term>
   <listitem>
    <para>
     pointer which should be removed from the context list
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
<title>Description</title>
<para>
   Removes a previously added pointer from the context list and returns
   the matching context id.
   </para><para>

   Returns context id on success or 0 on failure.
</para>
</refsect1>
</refentry>

<refentry id="API-i2o-cntxt-list-get">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>July 2015</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>i2o_cntxt_list_get</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.4.104</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>i2o_cntxt_list_get</refname>
 <refpurpose>
     Get a pointer from the context list and remove it
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>void * <function>i2o_cntxt_list_get </function></funcdef>
   <paramdef>struct i2o_controller * <parameter>c</parameter></paramdef>
   <paramdef>u32 <parameter>context</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>c</parameter></term>
   <listitem>
    <para>
     controller to which the context list belong
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>context</parameter></term>
   <listitem>
    <para>
     context id to which the pointer belong
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
<title>Description</title>
<para>
   Returns pointer to the matching context id on success or NULL on
   failure.
</para>
</refsect1>
</refentry>

<refentry id="API-i2o-cntxt-list-get-ptr">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>July 2015</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>i2o_cntxt_list_get_ptr</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.4.104</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>i2o_cntxt_list_get_ptr</refname>
 <refpurpose>
     Get a context id from the context list
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>u32 <function>i2o_cntxt_list_get_ptr </function></funcdef>
   <paramdef>struct i2o_controller * <parameter>c</parameter></paramdef>
   <paramdef>void * <parameter>ptr</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>c</parameter></term>
   <listitem>
    <para>
     controller to which the context list belong
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>ptr</parameter></term>
   <listitem>
    <para>
     pointer to which the context id should be fetched
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
<title>Description</title>
<para>
   Returns context id which matches to the pointer on success or 0 on
   failure.
</para>
</refsect1>
</refentry>

<refentry id="API-i2o-find-iop">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>July 2015</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>i2o_find_iop</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.4.104</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>i2o_find_iop</refname>
 <refpurpose>
     Find an I2O controller by id
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>struct i2o_controller * <function>i2o_find_iop </function></funcdef>
   <paramdef>int <parameter>unit</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>unit</parameter></term>
   <listitem>
    <para>
     unit number of the I2O controller to search for
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
<title>Description</title>
<para>
   Lookup the I2O controller on the controller list.
   </para><para>

   Returns pointer to the I2O controller on success or NULL if not found.
</para>
</refsect1>
</refentry>

<refentry id="API-i2o-iop-find-device">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>July 2015</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>i2o_iop_find_device</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.4.104</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>i2o_iop_find_device</refname>
 <refpurpose>
     Find a I2O device on an I2O controller
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>struct i2o_device * <function>i2o_iop_find_device </function></funcdef>
   <paramdef>struct i2o_controller * <parameter>c</parameter></paramdef>
   <paramdef>u16 <parameter>tid</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>c</parameter></term>
   <listitem>
    <para>
     I2O controller where the I2O device hangs on
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>tid</parameter></term>
   <listitem>
    <para>
     TID of the I2O device to search for
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
<title>Description</title>
<para>
   Searches the devices of the I2O controller for a device with TID tid and
   returns it.
   </para><para>

   Returns a pointer to the I2O device if found, otherwise NULL.
</para>
</refsect1>
</refentry>

<refentry id="API-i2o-status-get">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>July 2015</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>i2o_status_get</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.4.104</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>i2o_status_get</refname>
 <refpurpose>
     Get the status block from the I2O controller
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>int <function>i2o_status_get </function></funcdef>
   <paramdef>struct i2o_controller * <parameter>c</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>c</parameter></term>
   <listitem>
    <para>
     I2O controller
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
<title>Description</title>
<para>
   Issue a status query on the controller. This updates the attached
   status block. The status block could then be accessed through
   c-&gt;status_block.
   </para><para>

   Returns 0 on success or negative error code on failure.
</para>
</refsect1>
</refentry>

<refentry id="API-i2o-event-register">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>July 2015</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>i2o_event_register</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.4.104</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>i2o_event_register</refname>
 <refpurpose>
     Turn on/off event notification for a I2O device
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>int <function>i2o_event_register </function></funcdef>
   <paramdef>struct i2o_device * <parameter>dev</parameter></paramdef>
   <paramdef>struct i2o_driver * <parameter>drv</parameter></paramdef>
   <paramdef>int <parameter>tcntxt</parameter></paramdef>
   <paramdef>u32 <parameter>evt_mask</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>dev</parameter></term>
   <listitem>
    <para>
     I2O device which should receive the event registration request
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>drv</parameter></term>
   <listitem>
    <para>
     driver which want to get notified
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>tcntxt</parameter></term>
   <listitem>
    <para>
     transaction context to use with this notifier
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>evt_mask</parameter></term>
   <listitem>
    <para>
     mask of events
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
<title>Description</title>
<para>
   Create and posts an event registration message to the task. No reply
   is waited for, or expected. If you do not want further notifications,
   call the i2o_event_register again with a evt_mask of 0.
   </para><para>

   Returns 0 on success or negative error code on failure.
</para>
</refsect1>
</refentry>

<!-- drivers/message/i2o/iop.c -->
<refentry id="API-i2o-iop-quiesce">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>July 2015</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>i2o_iop_quiesce</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.4.104</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>i2o_iop_quiesce</refname>
 <refpurpose>
  quiesce controller
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>int <function>i2o_iop_quiesce </function></funcdef>
   <paramdef>struct i2o_controller * <parameter>c</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>c</parameter></term>
   <listitem>
    <para>
     controller
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
<title>Description</title>
<para>
   Quiesce an IOP. Causes IOP to make external operation quiescent
   (i2o 'READY' state). Internal operation of the IOP continues normally.
   </para><para>

   Returns 0 on success or negative error code on failure.
</para>
</refsect1>
</refentry>

<refentry id="API-i2o-iop-enable">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>July 2015</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>i2o_iop_enable</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.4.104</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>i2o_iop_enable</refname>
 <refpurpose>
     move controller from ready to OPERATIONAL
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>int <function>i2o_iop_enable </function></funcdef>
   <paramdef>struct i2o_controller * <parameter>c</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>c</parameter></term>
   <listitem>
    <para>
     I2O controller
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
<title>Description</title>
<para>
   Enable IOP. This allows the IOP to resume external operations and
   reverses the effect of a quiesce. Returns zero or an error code if
   an error occurs.
</para>
</refsect1>
</refentry>

<refentry id="API-i2o-iop-quiesce-all">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>July 2015</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>i2o_iop_quiesce_all</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.4.104</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>i2o_iop_quiesce_all</refname>
 <refpurpose>
     Quiesce all I2O controllers on the system
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>void <function>i2o_iop_quiesce_all </function></funcdef>
   <paramdef> <parameter>void</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>void</parameter></term>
   <listitem>
    <para>
     no arguments
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
<title>Description</title>
<para>
   </para><para>

   Quiesce all I2O controllers which are connected to the system.
</para>
</refsect1>
</refentry>

<refentry id="API-i2o-iop-enable-all">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>July 2015</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>i2o_iop_enable_all</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.4.104</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>i2o_iop_enable_all</refname>
 <refpurpose>
     Enables all controllers on the system
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>void <function>i2o_iop_enable_all </function></funcdef>
   <paramdef> <parameter>void</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>void</parameter></term>
   <listitem>
    <para>
     no arguments
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
<title>Description</title>
<para>
   </para><para>

   Enables all I2O controllers which are connected to the system.
</para>
</refsect1>
</refentry>

<refentry id="API-i2o-iop-clear">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>July 2015</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>i2o_iop_clear</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.4.104</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>i2o_iop_clear</refname>
 <refpurpose>
     Bring I2O controller into HOLD state
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>int <function>i2o_iop_clear </function></funcdef>
   <paramdef>struct i2o_controller * <parameter>c</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>c</parameter></term>
   <listitem>
    <para>
     controller
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
<title>Description</title>
<para>
   Clear an IOP to HOLD state, ie. terminate external operations, clear all
   input queues and prepare for a system restart. IOP's internal operation
   continues normally and the outbound queue is alive. The IOP is not
   expected to rebuild its LCT.
   </para><para>

   Returns 0 on success or negative error code on failure.
</para>
</refsect1>
</refentry>

<refentry id="API-i2o-iop-init-outbound-queue">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>July 2015</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>i2o_iop_init_outbound_queue</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.4.104</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>i2o_iop_init_outbound_queue</refname>
 <refpurpose>
     setup the outbound message queue
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>int <function>i2o_iop_init_outbound_queue </function></funcdef>
   <paramdef>struct i2o_controller * <parameter>c</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>c</parameter></term>
   <listitem>
    <para>
     I2O controller
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
<title>Description</title>
<para>
   Clear and (re)initialize IOP's outbound queue and post the message
   frames to the IOP.
   </para><para>

   Returns 0 on success or negative error code on failure.
</para>
</refsect1>
</refentry>

<refentry id="API-i2o-iop-reset">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>July 2015</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>i2o_iop_reset</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.4.104</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>i2o_iop_reset</refname>
 <refpurpose>
     reset an I2O controller
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>int <function>i2o_iop_reset </function></funcdef>
   <paramdef>struct i2o_controller * <parameter>c</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>c</parameter></term>
   <listitem>
    <para>
     controller to reset
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
<title>Description</title>
<para>
   Reset the IOP into INIT state and wait until IOP gets into RESET state.
   Terminate all external operations, clear IOP's inbound and outbound
   queues, terminate all DDMs, and reload the IOP's operating environment
   and all local DDMs. The IOP rebuilds its LCT.
</para>
</refsect1>
</refentry>

<refentry id="API-i2o-iop-activate">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>July 2015</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>i2o_iop_activate</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.4.104</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>i2o_iop_activate</refname>
 <refpurpose>
     Bring controller up to HOLD
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>int <function>i2o_iop_activate </function></funcdef>
   <paramdef>struct i2o_controller * <parameter>c</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>c</parameter></term>
   <listitem>
    <para>
     controller
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
<title>Description</title>
<para>
   This function brings an I2O controller into HOLD state. The adapter
   is reset if necessary and then the queues and resource table are read.
   </para><para>

   Returns 0 on success or negative error code on failure.
</para>
</refsect1>
</refentry>

<refentry id="API-i2o-iop-systab-set">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>July 2015</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>i2o_iop_systab_set</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.4.104</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>i2o_iop_systab_set</refname>
 <refpurpose>
     Set the I2O System Table of the specified IOP
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>int <function>i2o_iop_systab_set </function></funcdef>
   <paramdef>struct i2o_controller * <parameter>c</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>c</parameter></term>
   <listitem>
    <para>
     I2O controller to which the system table should be send
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
<title>Description</title>
<para>
   Before the systab could be set <function>i2o_systab_build</function> must be called.
   </para><para>

   Returns 0 on success or negative error code on failure.
</para>
</refsect1>
</refentry>

<refentry id="API-i2o-iop-online">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>July 2015</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>i2o_iop_online</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.4.104</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>i2o_iop_online</refname>
 <refpurpose>
     Bring a controller online into OPERATIONAL state.
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>int <function>i2o_iop_online </function></funcdef>
   <paramdef>struct i2o_controller * <parameter>c</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>c</parameter></term>
   <listitem>
    <para>
     I2O controller
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
<title>Description</title>
<para>
   Send the system table and enable the I2O controller.
   </para><para>

   Returns 0 on success or negative error code on failure.
</para>
</refsect1>
</refentry>

<refentry id="API-i2o-iop-remove">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>July 2015</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>i2o_iop_remove</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.4.104</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>i2o_iop_remove</refname>
 <refpurpose>
     Remove the I2O controller from the I2O core
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>void <function>i2o_iop_remove </function></funcdef>
   <paramdef>struct i2o_controller * <parameter>c</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>c</parameter></term>
   <listitem>
    <para>
     I2O controller
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
<title>Description</title>
<para>
   Remove the I2O controller from the I2O core. If devices are attached to
   the controller remove these also and finally reset the controller.
</para>
</refsect1>
</refentry>

<refentry id="API-i2o-systab-build">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>July 2015</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>i2o_systab_build</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.4.104</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>i2o_systab_build</refname>
 <refpurpose>
     Build system table
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>int <function>i2o_systab_build </function></funcdef>
   <paramdef> <parameter>void</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>void</parameter></term>
   <listitem>
    <para>
     no arguments
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
<title>Description</title>
<para>
   </para><para>

   The system table contains information about all the IOPs in the system
   (duh) and is used by the Executives on the IOPs to establish peer2peer
   connections. We're not supporting peer2peer at the moment, but this
   will be needed down the road for things like lan2lan forwarding.
   </para><para>

   Returns 0 on success or negative error code on failure.
</para>
</refsect1>
</refentry>

<refentry id="API-i2o-parse-hrt">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>July 2015</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>i2o_parse_hrt</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.4.104</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>i2o_parse_hrt</refname>
 <refpurpose>
     Parse the hardware resource table.
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>int <function>i2o_parse_hrt </function></funcdef>
   <paramdef>struct i2o_controller * <parameter>c</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>c</parameter></term>
   <listitem>
    <para>
     I2O controller
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
<title>Description</title>
<para>
   We don't do anything with it except dumping it (in debug mode).
   </para><para>

   Returns 0.
</para>
</refsect1>
</refentry>

<refentry id="API-i2o-iop-release">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>July 2015</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>i2o_iop_release</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.4.104</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>i2o_iop_release</refname>
 <refpurpose>
     release the memory for a I2O controller
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>void <function>i2o_iop_release </function></funcdef>
   <paramdef>struct device * <parameter>dev</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>dev</parameter></term>
   <listitem>
    <para>
     I2O controller which should be released
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
<title>Description</title>
<para>
   Release the allocated memory. This function is called if refcount of
   device reaches 0 automatically.
</para>
</refsect1>
</refentry>

<refentry id="API-i2o-iop-alloc">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>July 2015</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>i2o_iop_alloc</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.4.104</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>i2o_iop_alloc</refname>
 <refpurpose>
     Allocate and initialize a i2o_controller struct
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>struct i2o_controller * <function>i2o_iop_alloc </function></funcdef>
   <paramdef> <parameter>void</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>void</parameter></term>
   <listitem>
    <para>
     no arguments
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
<title>Description</title>
<para>
   </para><para>

   Allocate the necessary memory for a i2o_controller struct and
   initialize the lists and message mempool.
   </para><para>

   Returns a pointer to the I2O controller or a negative error code on
   failure.
</para>
</refsect1>
</refentry>

<refentry id="API-i2o-iop-add">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>July 2015</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>i2o_iop_add</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.4.104</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>i2o_iop_add</refname>
 <refpurpose>
     Initialize the I2O controller and add him to the I2O core
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>int <function>i2o_iop_add </function></funcdef>
   <paramdef>struct i2o_controller * <parameter>c</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>c</parameter></term>
   <listitem>
    <para>
     controller
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
<title>Description</title>
<para>
   Initialize the I2O controller and if no error occurs add him to the I2O
   core.
   </para><para>

   Returns 0 on success or negative error code on failure.
</para>
</refsect1>
</refentry>

<refentry id="API-i2o-iop-init">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>July 2015</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>i2o_iop_init</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.4.104</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>i2o_iop_init</refname>
 <refpurpose>
     I2O main initialization function
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>int <function>i2o_iop_init </function></funcdef>
   <paramdef> <parameter>void</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>void</parameter></term>
   <listitem>
    <para>
     no arguments
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
<title>Description</title>
<para>
   </para><para>

   Initialize the I2O drivers (OSM) functions, register the Executive OSM,
   initialize the I2O PCI part and finally initialize I2O device stuff.
   </para><para>

   Returns 0 on success or negative error code on failure.
</para>
</refsect1>
</refentry>

<refentry id="API-i2o-iop-exit">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>July 2015</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>i2o_iop_exit</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.4.104</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>i2o_iop_exit</refname>
 <refpurpose>
     I2O main exit function
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>void __exit <function>i2o_iop_exit </function></funcdef>
   <paramdef> <parameter>void</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>void</parameter></term>
   <listitem>
    <para>
     no arguments
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
<title>Description</title>
<para>
   </para><para>

   Removes I2O controllers from PCI subsystem and shut down OSMs.
</para>
</refsect1>
</refentry>

<!-- drivers/message/i2o/config-osm.c -->
<refentry id="API-i2o-config-init">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>July 2015</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>i2o_config_init</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.4.104</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>i2o_config_init</refname>
 <refpurpose>
  Configuration OSM initialization function
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>int <function>i2o_config_init </function></funcdef>
   <paramdef> <parameter>void</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>void</parameter></term>
   <listitem>
    <para>
     no arguments
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
<title>Description</title>
<para>
   </para><para>

   Registers Configuration OSM in the I2O core and if old ioctl's are
   compiled in initialize them.
   </para><para>

   Returns 0 on success or negative error code on failure.
</para>
</refsect1>
</refentry>

<refentry id="API-i2o-config-exit">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>July 2015</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>i2o_config_exit</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.4.104</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>i2o_config_exit</refname>
 <refpurpose>
     Configuration OSM exit function
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>void <function>i2o_config_exit </function></funcdef>
   <paramdef> <parameter>void</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>void</parameter></term>
   <listitem>
    <para>
     no arguments
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
<title>Description</title>
<para>
   </para><para>

   If old ioctl's are compiled in exit remove them and unregisters
   Configuration OSM from I2O core.
</para>
</refsect1>
</refentry>

<!-- drivers/message/i2o/exec-osm.c -->
<refentry id="API-i2o-msg-post-wait-mem">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>July 2015</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>i2o_msg_post_wait_mem</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.4.104</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>i2o_msg_post_wait_mem</refname>
 <refpurpose>
  Post and wait a message with DMA buffers
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>int <function>i2o_msg_post_wait_mem </function></funcdef>
   <paramdef>struct i2o_controller * <parameter>c</parameter></paramdef>
   <paramdef>struct i2o_message * <parameter>msg</parameter></paramdef>
   <paramdef>unsigned long <parameter>timeout</parameter></paramdef>
   <paramdef>struct i2o_dma * <parameter>dma</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>c</parameter></term>
   <listitem>
    <para>
     controller
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>msg</parameter></term>
   <listitem>
    <para>
     message to post
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>timeout</parameter></term>
   <listitem>
    <para>
     time in seconds to wait
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>dma</parameter></term>
   <listitem>
    <para>
     i2o_dma struct of the DMA buffer to free on failure
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
<title>Description</title>
<para>
   This API allows an OSM to post a message and then be told whether or
   not the system received a successful reply. If the message times out
   then the value '-ETIMEDOUT' is returned. This is a special case. In
   this situation the message may (should) complete at an indefinite time
   in the future. When it completes it will use the memory buffer
   attached to the request. If -ETIMEDOUT is returned then the memory
   buffer must not be freed. Instead the event completion will free them
   for you. In all other cases the buffer are your problem.
   </para><para>

   Returns 0 on success, negative error code on timeout or positive error
   code from reply.
</para>
</refsect1>
</refentry>

<refentry id="API-i2o-exec-lct-get">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>July 2015</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>i2o_exec_lct_get</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.4.104</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>i2o_exec_lct_get</refname>
 <refpurpose>
     Get the IOP's Logical Configuration Table
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>int <function>i2o_exec_lct_get </function></funcdef>
   <paramdef>struct i2o_controller * <parameter>c</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>c</parameter></term>
   <listitem>
    <para>
     I2O controller from which the LCT should be fetched
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
<title>Description</title>
<para>
   Send a LCT NOTIFY request to the controller, and wait
   I2O_TIMEOUT_LCT_GET seconds until arrival of response. If the LCT is
   to large, retry it.
   </para><para>

   Returns 0 on success or negative error code on failure.
</para>
</refsect1>
</refentry>

<!-- drivers/message/i2o/exec-osm.c -->
<refentry id="API-i2o-exec-wait-alloc">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>July 2015</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>i2o_exec_wait_alloc</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.4.104</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>i2o_exec_wait_alloc</refname>
 <refpurpose>
  Allocate a i2o_exec_wait struct an initialize it
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>struct i2o_exec_wait * <function>i2o_exec_wait_alloc </function></funcdef>
   <paramdef> <parameter>void</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>void</parameter></term>
   <listitem>
    <para>
     no arguments
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
<title>Description</title>
<para>
   </para><para>

   Allocate the i2o_exec_wait struct and initialize the wait.
   </para><para>

   Returns i2o_exec_wait pointer on success or negative error code on
   failure.
</para>
</refsect1>
</refentry>

<refentry id="API-i2o-exec-wait-free">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>July 2015</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>i2o_exec_wait_free</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.4.104</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>i2o_exec_wait_free</refname>
 <refpurpose>
     Free an i2o_exec_wait struct
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>void <function>i2o_exec_wait_free </function></funcdef>
   <paramdef>struct i2o_exec_wait * <parameter>wait</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>wait</parameter></term>
   <listitem>
    <para>
     I2O wait data which should be cleaned up
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
</refentry>

<refentry id="API-i2o-msg-post-wait-complete">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>July 2015</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>i2o_msg_post_wait_complete</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.4.104</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>i2o_msg_post_wait_complete</refname>
 <refpurpose>
     Reply to a i2o_msg_post request from IOP
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>int <function>i2o_msg_post_wait_complete </function></funcdef>
   <paramdef>struct i2o_controller * <parameter>c</parameter></paramdef>
   <paramdef>u32 <parameter>m</parameter></paramdef>
   <paramdef>struct i2o_message * <parameter>msg</parameter></paramdef>
   <paramdef>u32 <parameter>context</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>c</parameter></term>
   <listitem>
    <para>
     I2O controller which answers
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>m</parameter></term>
   <listitem>
    <para>
     message id
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>msg</parameter></term>
   <listitem>
    <para>
     pointer to the I2O reply message
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>context</parameter></term>
   <listitem>
    <para>
     transaction context of request
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
<title>Description</title>
<para>
   This function is called in interrupt context only. If the reply reached
   before the timeout, the i2o_exec_wait struct is filled with the message
   and the task will be waked up. The task is now responsible for returning
   the message m back to the controller! If the message reaches us after
   the timeout clean up the i2o_exec_wait struct (including allocated
   DMA buffer).
   </para><para>

   Return 0 on success and if the message m should not be given back to the
   I2O controller, or &gt;0 on success and if the message should be given back
   afterwords. Returns negative error code on failure. In this case the
   message must also be given back to the controller.
</para>
</refsect1>
</refentry>

<refentry id="API-i2o-exec-show-vendor-id">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>July 2015</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>i2o_exec_show_vendor_id</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.4.104</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>i2o_exec_show_vendor_id</refname>
 <refpurpose>
     Displays Vendor ID of controller
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>ssize_t <function>i2o_exec_show_vendor_id </function></funcdef>
   <paramdef>struct device * <parameter>d</parameter></paramdef>
   <paramdef>struct device_attribute * <parameter>attr</parameter></paramdef>
   <paramdef>char * <parameter>buf</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>d</parameter></term>
   <listitem>
    <para>
     device of which the Vendor ID should be displayed
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>attr</parameter></term>
   <listitem>
    <para>
     device_attribute to display
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>buf</parameter></term>
   <listitem>
    <para>
     buffer into which the Vendor ID should be printed
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
<title>Description</title>
<para>
   Returns number of bytes printed into buffer.
</para>
</refsect1>
</refentry>

<refentry id="API-i2o-exec-show-product-id">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>July 2015</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>i2o_exec_show_product_id</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.4.104</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>i2o_exec_show_product_id</refname>
 <refpurpose>
     Displays Product ID of controller
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>ssize_t <function>i2o_exec_show_product_id </function></funcdef>
   <paramdef>struct device * <parameter>d</parameter></paramdef>
   <paramdef>struct device_attribute * <parameter>attr</parameter></paramdef>
   <paramdef>char * <parameter>buf</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>d</parameter></term>
   <listitem>
    <para>
     device of which the Product ID should be displayed
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>attr</parameter></term>
   <listitem>
    <para>
     device_attribute to display
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>buf</parameter></term>
   <listitem>
    <para>
     buffer into which the Product ID should be printed
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
<title>Description</title>
<para>
   Returns number of bytes printed into buffer.
</para>
</refsect1>
</refentry>

<refentry id="API-i2o-exec-probe">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>July 2015</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>i2o_exec_probe</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.4.104</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>i2o_exec_probe</refname>
 <refpurpose>
     Called if a new I2O device (executive class) appears
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>int <function>i2o_exec_probe </function></funcdef>
   <paramdef>struct device * <parameter>dev</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>dev</parameter></term>
   <listitem>
    <para>
     I2O device which should be probed
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
<title>Description</title>
<para>
   Registers event notification for every event from Executive device. The
   return is always 0, because we want all devices of class Executive.
   </para><para>

   Returns 0 on success.
</para>
</refsect1>
</refentry>

<refentry id="API-i2o-exec-remove">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>July 2015</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>i2o_exec_remove</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.4.104</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>i2o_exec_remove</refname>
 <refpurpose>
     Called on I2O device removal
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>int <function>i2o_exec_remove </function></funcdef>
   <paramdef>struct device * <parameter>dev</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>dev</parameter></term>
   <listitem>
    <para>
     I2O device which was removed
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
<title>Description</title>
<para>
   Unregisters event notification from Executive I2O device.
   </para><para>

   Returns 0 on success.
</para>
</refsect1>
</refentry>

<refentry id="API-i2o-exec-lct-notify">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>July 2015</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>i2o_exec_lct_notify</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.4.104</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>i2o_exec_lct_notify</refname>
 <refpurpose>
     Send a asynchronus LCT NOTIFY request
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>int <function>i2o_exec_lct_notify </function></funcdef>
   <paramdef>struct i2o_controller * <parameter>c</parameter></paramdef>
   <paramdef>u32 <parameter>change_ind</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>c</parameter></term>
   <listitem>
    <para>
     I2O controller to which the request should be send
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>change_ind</parameter></term>
   <listitem>
    <para>
     change indicator
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
<title>Description</title>
<para>
   This function sends a LCT NOTIFY request to the I2O controller with
   the change indicator change_ind. If the change_ind == 0 the controller
   replies immediately after the request. If change_ind &gt; 0 the reply is
   send after change indicator of the LCT is &gt; change_ind.
</para>
</refsect1>
</refentry>

<refentry id="API-i2o-exec-lct-modified">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>July 2015</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>i2o_exec_lct_modified</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.4.104</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>i2o_exec_lct_modified</refname>
 <refpurpose>
     Called on LCT NOTIFY reply
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>void <function>i2o_exec_lct_modified </function></funcdef>
   <paramdef>struct work_struct * <parameter>_work</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>_work</parameter></term>
   <listitem>
    <para>
     work struct for a specific controller
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
<title>Description</title>
<para>
   This function handles asynchronus LCT NOTIFY replies. It parses the
   new LCT and if the buffer for the LCT was to small sends a LCT NOTIFY
   again, otherwise send LCT NOTIFY to get informed on next LCT change.
</para>
</refsect1>
</refentry>

<refentry id="API-i2o-exec-reply">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>July 2015</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>i2o_exec_reply</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.4.104</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>i2o_exec_reply</refname>
 <refpurpose>
     I2O Executive reply handler
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>int <function>i2o_exec_reply </function></funcdef>
   <paramdef>struct i2o_controller * <parameter>c</parameter></paramdef>
   <paramdef>u32 <parameter>m</parameter></paramdef>
   <paramdef>struct i2o_message * <parameter>msg</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>c</parameter></term>
   <listitem>
    <para>
     I2O controller from which the reply comes
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>m</parameter></term>
   <listitem>
    <para>
     message id
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>msg</parameter></term>
   <listitem>
    <para>
     pointer to the I2O reply message
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
<title>Description</title>
<para>
   This function is always called from interrupt context. If a POST WAIT
   reply was received, pass it to the complete function. If a LCT NOTIFY
   reply was received, a new event is created to handle the update.
   </para><para>

   Returns 0 on success and if the reply should not be flushed or &gt; 0
   on success and if the reply should be flushed. Returns negative error
   code on failure and if the reply should be flushed.
</para>
</refsect1>
</refentry>

<refentry id="API-i2o-exec-event">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>July 2015</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>i2o_exec_event</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.4.104</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>i2o_exec_event</refname>
 <refpurpose>
     Event handling function
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>void <function>i2o_exec_event </function></funcdef>
   <paramdef>struct work_struct * <parameter>work</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>work</parameter></term>
   <listitem>
    <para>
     Work item in occurring event
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
<title>Description</title>
<para>
   Handles events send by the Executive device. At the moment does not do
   anything useful.
</para>
</refsect1>
</refentry>

<refentry id="API-i2o-exec-init">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>July 2015</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>i2o_exec_init</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.4.104</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>i2o_exec_init</refname>
 <refpurpose>
     Registers the Exec OSM
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>int <function>i2o_exec_init </function></funcdef>
   <paramdef> <parameter>void</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>void</parameter></term>
   <listitem>
    <para>
     no arguments
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
<title>Description</title>
<para>
   </para><para>

   Registers the Exec OSM in the I2O core.
   </para><para>

   Returns 0 on success or negative error code on failure.
</para>
</refsect1>
</refentry>

<refentry id="API-i2o-exec-exit">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>July 2015</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>i2o_exec_exit</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.4.104</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>i2o_exec_exit</refname>
 <refpurpose>
     Removes the Exec OSM
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>void <function>i2o_exec_exit </function></funcdef>
   <paramdef> <parameter>void</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>void</parameter></term>
   <listitem>
    <para>
     no arguments
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
<title>Description</title>
<para>
   </para><para>

   Unregisters the Exec OSM from the I2O core.
</para>
</refsect1>
</refentry>

<!-- drivers/message/i2o/bus-osm.c -->
<refentry id="API-i2o-bus-scan">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>July 2015</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>i2o_bus_scan</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.4.104</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>i2o_bus_scan</refname>
 <refpurpose>
  Scan the bus for new devices
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>int <function>i2o_bus_scan </function></funcdef>
   <paramdef>struct i2o_device * <parameter>dev</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>dev</parameter></term>
   <listitem>
    <para>
     I2O device of the bus, which should be scanned
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
<title>Description</title>
<para>
   Scans the bus dev for new / removed devices. After the scan a new LCT
   will be fetched automatically.
   </para><para>

   Returns 0 on success or negative error code on failure.
</para>
</refsect1>
</refentry>

<refentry id="API-i2o-bus-store-scan">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>July 2015</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>i2o_bus_store_scan</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.4.104</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>i2o_bus_store_scan</refname>
 <refpurpose>
     Scan the I2O Bus Adapter
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>ssize_t <function>i2o_bus_store_scan </function></funcdef>
   <paramdef>struct device * <parameter>d</parameter></paramdef>
   <paramdef>struct device_attribute * <parameter>attr</parameter></paramdef>
   <paramdef>const char * <parameter>buf</parameter></paramdef>
   <paramdef>size_t <parameter>count</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>d</parameter></term>
   <listitem>
    <para>
     device which should be scanned
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>attr</parameter></term>
   <listitem>
    <para>
     device_attribute
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>buf</parameter></term>
   <listitem>
    <para>
     output buffer
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>count</parameter></term>
   <listitem>
    <para>
     buffer size
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
<title>Description</title>
<para>
   Returns count.
</para>
</refsect1>
</refentry>

<refentry id="API-i2o-bus-probe">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>July 2015</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>i2o_bus_probe</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.4.104</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>i2o_bus_probe</refname>
 <refpurpose>
     verify if dev is a I2O Bus Adapter device and install it
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>int <function>i2o_bus_probe </function></funcdef>
   <paramdef>struct device * <parameter>dev</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>dev</parameter></term>
   <listitem>
    <para>
     device to verify if it is a I2O Bus Adapter device
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
<title>Description</title>
<para>
   Because we want all Bus Adapters always return 0.
   Except when we fail.  Then we are sad.
   </para><para>

   Returns 0, except when we fail to excel.
</para>
</refsect1>
</refentry>

<refentry id="API-i2o-bus-remove">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>July 2015</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>i2o_bus_remove</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.4.104</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>i2o_bus_remove</refname>
 <refpurpose>
     remove the I2O Bus Adapter device from the system again
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>int <function>i2o_bus_remove </function></funcdef>
   <paramdef>struct device * <parameter>dev</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>dev</parameter></term>
   <listitem>
    <para>
     I2O Bus Adapter device which should be removed
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
<title>Description</title>
<para>
   Always returns 0.
</para>
</refsect1>
</refentry>

<refentry id="API-i2o-bus-init">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>July 2015</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>i2o_bus_init</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.4.104</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>i2o_bus_init</refname>
 <refpurpose>
     Bus Adapter OSM initialization function
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>int <function>i2o_bus_init </function></funcdef>
   <paramdef> <parameter>void</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>void</parameter></term>
   <listitem>
    <para>
     no arguments
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
<title>Description</title>
<para>
   </para><para>

   Only register the Bus Adapter OSM in the I2O core.
   </para><para>

   Returns 0 on success or negative error code on failure.
</para>
</refsect1>
</refentry>

<refentry id="API-i2o-bus-exit">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>July 2015</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>i2o_bus_exit</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.4.104</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>i2o_bus_exit</refname>
 <refpurpose>
     Bus Adapter OSM exit function
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>void __exit <function>i2o_bus_exit </function></funcdef>
   <paramdef> <parameter>void</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>void</parameter></term>
   <listitem>
    <para>
     no arguments
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
<title>Description</title>
<para>
   </para><para>

   Unregisters Bus Adapter OSM from I2O core.
</para>
</refsect1>
</refentry>

<!-- drivers/message/i2o/device.c -->
<refentry id="API-i2o-device-claim">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>July 2015</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>i2o_device_claim</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.4.104</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>i2o_device_claim</refname>
 <refpurpose>
  claim a device for use by an OSM
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>int <function>i2o_device_claim </function></funcdef>
   <paramdef>struct i2o_device * <parameter>dev</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>dev</parameter></term>
   <listitem>
    <para>
     I2O device to claim
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
<title>Description</title>
<para>
   Do the leg work to assign a device to a given OSM. If the claim succeeds,
   the owner is the primary. If the attempt fails a negative errno code
   is returned. On success zero is returned.
</para>
</refsect1>
</refentry>

<refentry id="API-i2o-device-claim-release">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>July 2015</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>i2o_device_claim_release</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.4.104</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>i2o_device_claim_release</refname>
 <refpurpose>
     release a device that the OSM is using
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>int <function>i2o_device_claim_release </function></funcdef>
   <paramdef>struct i2o_device * <parameter>dev</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>dev</parameter></term>
   <listitem>
    <para>
     device to release
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
<title>Description</title>
<para>
   Drop a claim by an OSM on a given I2O device.
   </para><para>

   AC - some devices seem to want to refuse an unclaim until they have
   finished internal processing. It makes sense since you don't want a
   new device to go reconfiguring the entire system until you are done.
   Thus we are prepared to wait briefly.
   </para><para>

   Returns 0 on success or negative error code on failure.
</para>
</refsect1>
</refentry>

<!-- drivers/message/i2o/device.c -->
<refentry id="API-i2o-device-issue-claim">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>July 2015</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>i2o_device_issue_claim</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.4.104</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>i2o_device_issue_claim</refname>
 <refpurpose>
  claim or release a device
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>int <function>i2o_device_issue_claim </function></funcdef>
   <paramdef>struct i2o_device * <parameter>dev</parameter></paramdef>
   <paramdef>u32 <parameter>cmd</parameter></paramdef>
   <paramdef>u32 <parameter>type</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>dev</parameter></term>
   <listitem>
    <para>
     I2O device to claim or release
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>cmd</parameter></term>
   <listitem>
    <para>
     claim or release command
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>type</parameter></term>
   <listitem>
    <para>
     type of claim
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
<title>Description</title>
<para>
   Issue I2O UTIL_CLAIM or UTIL_RELEASE messages. The message to be sent
   is set by cmd. dev is the I2O device which should be claim or
   released and the type is the claim type (see the I2O spec).
   </para><para>

   Returs 0 on success or negative error code on failure.
</para>
</refsect1>
</refentry>

<refentry id="API-i2o-device-release">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>July 2015</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>i2o_device_release</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.4.104</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>i2o_device_release</refname>
 <refpurpose>
     release the memory for a I2O device
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>void <function>i2o_device_release </function></funcdef>
   <paramdef>struct device * <parameter>dev</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>dev</parameter></term>
   <listitem>
    <para>
     I2O device which should be released
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
<title>Description</title>
<para>
   Release the allocated memory. This function is called if refcount of
   device reaches 0 automatically.
</para>
</refsect1>
</refentry>

<refentry id="API-i2o-device-show-class-id">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>July 2015</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>i2o_device_show_class_id</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.4.104</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>i2o_device_show_class_id</refname>
 <refpurpose>
     Displays class id of I2O device
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>ssize_t <function>i2o_device_show_class_id </function></funcdef>
   <paramdef>struct device * <parameter>dev</parameter></paramdef>
   <paramdef>struct device_attribute * <parameter>attr</parameter></paramdef>
   <paramdef>char * <parameter>buf</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>dev</parameter></term>
   <listitem>
    <para>
     device of which the class id should be displayed
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>attr</parameter></term>
   <listitem>
    <para>
     pointer to device attribute
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>buf</parameter></term>
   <listitem>
    <para>
     buffer into which the class id should be printed
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
<title>Description</title>
<para>
   Returns the number of bytes which are printed into the buffer.
</para>
</refsect1>
</refentry>

<refentry id="API-i2o-device-show-tid">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>July 2015</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>i2o_device_show_tid</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.4.104</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>i2o_device_show_tid</refname>
 <refpurpose>
     Displays TID of I2O device
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>ssize_t <function>i2o_device_show_tid </function></funcdef>
   <paramdef>struct device * <parameter>dev</parameter></paramdef>
   <paramdef>struct device_attribute * <parameter>attr</parameter></paramdef>
   <paramdef>char * <parameter>buf</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>dev</parameter></term>
   <listitem>
    <para>
     device of which the TID should be displayed
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>attr</parameter></term>
   <listitem>
    <para>
     pointer to device attribute
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>buf</parameter></term>
   <listitem>
    <para>
     buffer into which the TID should be printed
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
<title>Description</title>
<para>
   Returns the number of bytes which are printed into the buffer.
</para>
</refsect1>
</refentry>

<refentry id="API-i2o-device-alloc">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>July 2015</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>i2o_device_alloc</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.4.104</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>i2o_device_alloc</refname>
 <refpurpose>
     Allocate a I2O device and initialize it
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>struct i2o_device * <function>i2o_device_alloc </function></funcdef>
   <paramdef> <parameter>void</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>void</parameter></term>
   <listitem>
    <para>
     no arguments
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
<title>Description</title>
<para>
   </para><para>

   Allocate the memory for a I2O device and initialize locks and lists
   </para><para>

   Returns the allocated I2O device or a negative error code if the device
   could not be allocated.
</para>
</refsect1>
</refentry>

<refentry id="API-i2o-device-add">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>July 2015</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>i2o_device_add</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.4.104</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>i2o_device_add</refname>
 <refpurpose>
     allocate a new I2O device and add it to the IOP
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>int <function>i2o_device_add </function></funcdef>
   <paramdef>struct i2o_controller * <parameter>c</parameter></paramdef>
   <paramdef>i2o_lct_entry * <parameter>entry</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>c</parameter></term>
   <listitem>
    <para>
     I2O controller that the device is on
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>entry</parameter></term>
   <listitem>
    <para>
     LCT entry of the I2O device
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
<title>Description</title>
<para>
   Allocate a new I2O device and initialize it with the LCT entry. The
   device is appended to the device list of the controller.
   </para><para>

   Returns zero on success, or a -ve errno.
</para>
</refsect1>
</refentry>

<refentry id="API-i2o-device-remove">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>July 2015</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>i2o_device_remove</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.4.104</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>i2o_device_remove</refname>
 <refpurpose>
     remove an I2O device from the I2O core
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>void <function>i2o_device_remove </function></funcdef>
   <paramdef>struct i2o_device * <parameter>i2o_dev</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>i2o_dev</parameter></term>
   <listitem>
    <para>
     I2O device which should be released
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
<title>Description</title>
<para>
   Is used on I2O controller removal or LCT modification, when the device
   is removed from the system. Note that the device could still hang
   around until the refcount reaches 0.
</para>
</refsect1>
</refentry>

<refentry id="API-i2o-device-parse-lct">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>July 2015</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>i2o_device_parse_lct</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.4.104</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>i2o_device_parse_lct</refname>
 <refpurpose>
     Parse a previously fetched LCT and create devices
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>int <function>i2o_device_parse_lct </function></funcdef>
   <paramdef>struct i2o_controller * <parameter>c</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>c</parameter></term>
   <listitem>
    <para>
     I2O controller from which the LCT should be parsed.
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
<title>Description</title>
<para>
   The Logical Configuration Table tells us what we can talk to on the
   board. For every entry we create an I2O device, which is registered in
   the I2O core.
   </para><para>

   Returns 0 on success or negative error code on failure.
</para>
</refsect1>
</refentry>

<!-- drivers/message/i2o/driver.c -->
<refentry id="API-i2o-bus-match">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>July 2015</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>i2o_bus_match</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.4.104</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>i2o_bus_match</refname>
 <refpurpose>
  Tell if I2O device class id matches the class ids of the I2O driver (OSM)
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>int <function>i2o_bus_match </function></funcdef>
   <paramdef>struct device * <parameter>dev</parameter></paramdef>
   <paramdef>struct device_driver * <parameter>drv</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>dev</parameter></term>
   <listitem>
    <para>
     device which should be verified
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>drv</parameter></term>
   <listitem>
    <para>
     the driver to match against
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
<title>Description</title>
<para>
   Used by the bus to check if the driver wants to handle the device.
   </para><para>

   Returns 1 if the class ids of the driver match the class id of the
   device, otherwise 0.
</para>
</refsect1>
</refentry>

<refentry id="API-i2o-driver-dispatch">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>July 2015</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>i2o_driver_dispatch</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.4.104</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>i2o_driver_dispatch</refname>
 <refpurpose>
     dispatch an I2O reply message
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>int <function>i2o_driver_dispatch </function></funcdef>
   <paramdef>struct i2o_controller * <parameter>c</parameter></paramdef>
   <paramdef>u32 <parameter>m</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>c</parameter></term>
   <listitem>
    <para>
     I2O controller of the message
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>m</parameter></term>
   <listitem>
    <para>
     I2O message number
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
<title>Description</title>
<para>
   The reply is delivered to the driver from which the original message
   was. This function is only called from interrupt context.
   </para><para>

   Returns 0 on success and the message should not be flushed. Returns &gt; 0
   on success and if the message should be flushed afterwords. Returns
   negative error code on failure (the message will be flushed too).
</para>
</refsect1>
</refentry>

<refentry id="API-i2o-driver-init">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>July 2015</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>i2o_driver_init</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.4.104</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>i2o_driver_init</refname>
 <refpurpose>
     initialize I2O drivers (OSMs)
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>int <function>i2o_driver_init </function></funcdef>
   <paramdef> <parameter>void</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>void</parameter></term>
   <listitem>
    <para>
     no arguments
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
<title>Description</title>
<para>
   </para><para>

   Registers the I2O bus and allocate memory for the array of OSMs.
   </para><para>

   Returns 0 on success or negative error code on failure.
</para>
</refsect1>
</refentry>

<refentry id="API-i2o-driver-exit">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>July 2015</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>i2o_driver_exit</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.4.104</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>i2o_driver_exit</refname>
 <refpurpose>
     clean up I2O drivers (OSMs)
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>void <function>i2o_driver_exit </function></funcdef>
   <paramdef> <parameter>void</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>void</parameter></term>
   <listitem>
    <para>
     no arguments
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
<title>Description</title>
<para>
   </para><para>

   Unregisters the I2O bus and frees driver array.
</para>
</refsect1>
</refentry>

<!-- drivers/message/i2o/pci.c -->
<refentry id="API-i2o-pci-free">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>July 2015</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>i2o_pci_free</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.4.104</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>i2o_pci_free</refname>
 <refpurpose>
  Frees the DMA memory for the I2O controller
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>void <function>i2o_pci_free </function></funcdef>
   <paramdef>struct i2o_controller * <parameter>c</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>c</parameter></term>
   <listitem>
    <para>
     I2O controller to free
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
<title>Description</title>
<para>
   Remove all allocated DMA memory and unmap memory IO regions. If MTRR
   is enabled, also remove it again.
</para>
</refsect1>
</refentry>

<refentry id="API-i2o-pci-alloc">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>July 2015</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>i2o_pci_alloc</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.4.104</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>i2o_pci_alloc</refname>
 <refpurpose>
     Allocate DMA memory, map IO memory for I2O controller
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>int <function>i2o_pci_alloc </function></funcdef>
   <paramdef>struct i2o_controller * <parameter>c</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>c</parameter></term>
   <listitem>
    <para>
     I2O controller
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
<title>Description</title>
<para>
   Allocate DMA memory for a PCI (or in theory AGP) I2O controller. All
   IO mappings are also done here. If MTRR is enabled, also do add memory
   regions here.
   </para><para>

   Returns 0 on success or negative error code on failure.
</para>
</refsect1>
</refentry>

<refentry id="API-i2o-pci-interrupt">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>July 2015</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>i2o_pci_interrupt</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.4.104</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>i2o_pci_interrupt</refname>
 <refpurpose>
     Interrupt handler for I2O controller
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>irqreturn_t <function>i2o_pci_interrupt </function></funcdef>
   <paramdef>int <parameter>irq</parameter></paramdef>
   <paramdef>void * <parameter>dev_id</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>irq</parameter></term>
   <listitem>
    <para>
     interrupt line
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>dev_id</parameter></term>
   <listitem>
    <para>
     pointer to the I2O controller
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
<title>Description</title>
<para>
   Handle an interrupt from a PCI based I2O controller. This turns out
   to be rather simple. We keep the controller pointer in the cookie.
</para>
</refsect1>
</refentry>

<refentry id="API-i2o-pci-irq-enable">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>July 2015</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>i2o_pci_irq_enable</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.4.104</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>i2o_pci_irq_enable</refname>
 <refpurpose>
     Allocate interrupt for I2O controller
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>int <function>i2o_pci_irq_enable </function></funcdef>
   <paramdef>struct i2o_controller * <parameter>c</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>c</parameter></term>
   <listitem>
    <para>
     i2o_controller that the request is for
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
<title>Description</title>
<para>
   Allocate an interrupt for the I2O controller, and activate interrupts
   on the I2O controller.
   </para><para>

   Returns 0 on success or negative error code on failure.
</para>
</refsect1>
</refentry>

<refentry id="API-i2o-pci-irq-disable">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>July 2015</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>i2o_pci_irq_disable</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.4.104</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>i2o_pci_irq_disable</refname>
 <refpurpose>
     Free interrupt for I2O controller
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>void <function>i2o_pci_irq_disable </function></funcdef>
   <paramdef>struct i2o_controller * <parameter>c</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>c</parameter></term>
   <listitem>
    <para>
     I2O controller
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
<title>Description</title>
<para>
   Disable interrupts in I2O controller and then free interrupt.
</para>
</refsect1>
</refentry>

<refentry id="API-i2o-pci-probe">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>July 2015</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>i2o_pci_probe</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.4.104</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>i2o_pci_probe</refname>
 <refpurpose>
     Probe the PCI device for an I2O controller
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>int <function>i2o_pci_probe </function></funcdef>
   <paramdef>struct pci_dev * <parameter>pdev</parameter></paramdef>
   <paramdef>const struct pci_device_id * <parameter>id</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>pdev</parameter></term>
   <listitem>
    <para>
     PCI device to test
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>id</parameter></term>
   <listitem>
    <para>
     id which matched with the PCI device id table
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
<title>Description</title>
<para>
   Probe the PCI device for any device which is a memory of the
   Intelligent, I2O class or an Adaptec Zero Channel Controller. We
   attempt to set up each such device and register it with the core.
   </para><para>

   Returns 0 on success or negative error code on failure.
</para>
</refsect1>
</refentry>

<refentry id="API-i2o-pci-remove">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>July 2015</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>i2o_pci_remove</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.4.104</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>i2o_pci_remove</refname>
 <refpurpose>
     Removes a I2O controller from the system
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>void __devexit <function>i2o_pci_remove </function></funcdef>
   <paramdef>struct pci_dev * <parameter>pdev</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>pdev</parameter></term>
   <listitem>
    <para>
     I2O controller which should be removed
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
<title>Description</title>
<para>
   Reset the I2O controller, disable interrupts and remove all allocated
   resources.
</para>
</refsect1>
</refentry>

<refentry id="API-i2o-pci-init">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>July 2015</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>i2o_pci_init</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.4.104</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>i2o_pci_init</refname>
 <refpurpose>
     registers I2O PCI driver in PCI subsystem
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>int <function>i2o_pci_init </function></funcdef>
   <paramdef> <parameter>void</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>void</parameter></term>
   <listitem>
    <para>
     no arguments
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
<title>Description</title>
<para>
   </para><para>

   Returns &gt; 0 on success or negative error code on failure.
</para>
</refsect1>
</refentry>

<refentry id="API-i2o-pci-exit">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>July 2015</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>i2o_pci_exit</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.4.104</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>i2o_pci_exit</refname>
 <refpurpose>
     unregisters I2O PCI driver from PCI subsystem
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>void __exit <function>i2o_pci_exit </function></funcdef>
   <paramdef> <parameter>void</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>void</parameter></term>
   <listitem>
    <para>
     no arguments
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
</refentry>

<!-- drivers/message/i2o/i2o_block.c -->
<refentry id="API-i2o-block-device-free">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>July 2015</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>i2o_block_device_free</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.4.104</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>i2o_block_device_free</refname>
 <refpurpose>
  free the memory of the I2O Block device
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>void <function>i2o_block_device_free </function></funcdef>
   <paramdef>struct i2o_block_device * <parameter>dev</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>dev</parameter></term>
   <listitem>
    <para>
     I2O Block device, which should be cleaned up
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
<title>Description</title>
<para>
   Frees the request queue, gendisk and the i2o_block_device structure.
</para>
</refsect1>
</refentry>

<refentry id="API-i2o-block-remove">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>July 2015</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>i2o_block_remove</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.4.104</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>i2o_block_remove</refname>
 <refpurpose>
     remove the I2O Block device from the system again
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>int <function>i2o_block_remove </function></funcdef>
   <paramdef>struct device * <parameter>dev</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>dev</parameter></term>
   <listitem>
    <para>
     I2O Block device which should be removed
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
<title>Description</title>
<para>
   Remove gendisk from system and free all allocated memory.
   </para><para>

   Always returns 0.
</para>
</refsect1>
</refentry>

<refentry id="API-i2o-block-device-flush">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>July 2015</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>i2o_block_device_flush</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.4.104</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>i2o_block_device_flush</refname>
 <refpurpose>
     Flush all dirty data of I2O device dev
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>int <function>i2o_block_device_flush </function></funcdef>
   <paramdef>struct i2o_device * <parameter>dev</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>dev</parameter></term>
   <listitem>
    <para>
     I2O device which should be flushed
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
<title>Description</title>
<para>
   Flushes all dirty data on device dev.
   </para><para>

   Returns 0 on success or negative error code on failure.
</para>
</refsect1>
</refentry>

<refentry id="API-i2o-block-device-mount">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>July 2015</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>i2o_block_device_mount</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.4.104</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>i2o_block_device_mount</refname>
 <refpurpose>
     Mount (load) the media of device dev
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>int <function>i2o_block_device_mount </function></funcdef>
   <paramdef>struct i2o_device * <parameter>dev</parameter></paramdef>
   <paramdef>u32 <parameter>media_id</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>dev</parameter></term>
   <listitem>
    <para>
     I2O device which should receive the mount request
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>media_id</parameter></term>
   <listitem>
    <para>
     Media Identifier
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
<title>Description</title>
<para>
   Load a media into drive. Identifier should be set to -1, because the
   spec does not support any other value.
   </para><para>

   Returns 0 on success or negative error code on failure.
</para>
</refsect1>
</refentry>

<refentry id="API-i2o-block-device-lock">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>July 2015</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>i2o_block_device_lock</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.4.104</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>i2o_block_device_lock</refname>
 <refpurpose>
     Locks the media of device dev
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>int <function>i2o_block_device_lock </function></funcdef>
   <paramdef>struct i2o_device * <parameter>dev</parameter></paramdef>
   <paramdef>u32 <parameter>media_id</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>dev</parameter></term>
   <listitem>
    <para>
     I2O device which should receive the lock request
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>media_id</parameter></term>
   <listitem>
    <para>
     Media Identifier
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
<title>Description</title>
<para>
   Lock media of device dev to prevent removal. The media identifier
   should be set to -1, because the spec does not support any other value.
   </para><para>

   Returns 0 on success or negative error code on failure.
</para>
</refsect1>
</refentry>

<refentry id="API-i2o-block-device-unlock">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>July 2015</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>i2o_block_device_unlock</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.4.104</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>i2o_block_device_unlock</refname>
 <refpurpose>
     Unlocks the media of device dev
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>int <function>i2o_block_device_unlock </function></funcdef>
   <paramdef>struct i2o_device * <parameter>dev</parameter></paramdef>
   <paramdef>u32 <parameter>media_id</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>dev</parameter></term>
   <listitem>
    <para>
     I2O device which should receive the unlocked request
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>media_id</parameter></term>
   <listitem>
    <para>
     Media Identifier
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
<title>Description</title>
<para>
   Unlocks the media in device dev. The media identifier should be set to
   -1, because the spec does not support any other value.
   </para><para>

   Returns 0 on success or negative error code on failure.
</para>
</refsect1>
</refentry>

<refentry id="API-i2o-block-device-power">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>July 2015</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>i2o_block_device_power</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.4.104</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>i2o_block_device_power</refname>
 <refpurpose>
     Power management for device dev
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>int <function>i2o_block_device_power </function></funcdef>
   <paramdef>struct i2o_block_device * <parameter>dev</parameter></paramdef>
   <paramdef>u8 <parameter>op</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>dev</parameter></term>
   <listitem>
    <para>
     I2O device which should receive the power management request
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>op</parameter></term>
   <listitem>
    <para>
     Operation to send
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
<title>Description</title>
<para>
   Send a power management request to the device dev.
   </para><para>

   Returns 0 on success or negative error code on failure.
</para>
</refsect1>
</refentry>

<refentry id="API-i2o-block-request-alloc">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>July 2015</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>i2o_block_request_alloc</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.4.104</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>i2o_block_request_alloc</refname>
 <refpurpose>
     Allocate an I2O block request struct
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>struct i2o_block_request * <function>i2o_block_request_alloc </function></funcdef>
   <paramdef> <parameter>void</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>void</parameter></term>
   <listitem>
    <para>
     no arguments
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
<title>Description</title>
<para>
   </para><para>

   Allocates an I2O block request struct and initialize the list.
   </para><para>

   Returns a i2o_block_request pointer on success or negative error code
   on failure.
</para>
</refsect1>
</refentry>

<refentry id="API-i2o-block-request-free">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>July 2015</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>i2o_block_request_free</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.4.104</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>i2o_block_request_free</refname>
 <refpurpose>
     Frees a I2O block request
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>void <function>i2o_block_request_free </function></funcdef>
   <paramdef>struct i2o_block_request * <parameter>ireq</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>ireq</parameter></term>
   <listitem>
    <para>
     I2O block request which should be freed
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
<title>Description</title>
<para>
   Frees the allocated memory (give it back to the request mempool).
</para>
</refsect1>
</refentry>

<refentry id="API-i2o-block-sglist-alloc">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>July 2015</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>i2o_block_sglist_alloc</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.4.104</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>i2o_block_sglist_alloc</refname>
 <refpurpose>
     Allocate the SG list and map it
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>int <function>i2o_block_sglist_alloc </function></funcdef>
   <paramdef>struct i2o_controller * <parameter>c</parameter></paramdef>
   <paramdef>struct i2o_block_request * <parameter>ireq</parameter></paramdef>
   <paramdef>u32 ** <parameter>mptr</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>c</parameter></term>
   <listitem>
    <para>
     I2O controller to which the request belongs
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>ireq</parameter></term>
   <listitem>
    <para>
     I2O block request
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>mptr</parameter></term>
   <listitem>
    <para>
     message body pointer
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
<title>Description</title>
<para>
   Builds the SG list and map it to be accessible by the controller.
   </para><para>

   Returns 0 on failure or 1 on success.
</para>
</refsect1>
</refentry>

<refentry id="API-i2o-block-sglist-free">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>July 2015</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>i2o_block_sglist_free</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.4.104</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>i2o_block_sglist_free</refname>
 <refpurpose>
     Frees the SG list
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>void <function>i2o_block_sglist_free </function></funcdef>
   <paramdef>struct i2o_block_request * <parameter>ireq</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>ireq</parameter></term>
   <listitem>
    <para>
     I2O block request from which the SG should be freed
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
<title>Description</title>
<para>
   Frees the SG list from the I2O block request.
</para>
</refsect1>
</refentry>

<refentry id="API-i2o-block-prep-req-fn">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>July 2015</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>i2o_block_prep_req_fn</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.4.104</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>i2o_block_prep_req_fn</refname>
 <refpurpose>
     Allocates I2O block device specific struct
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>int <function>i2o_block_prep_req_fn </function></funcdef>
   <paramdef>struct request_queue * <parameter>q</parameter></paramdef>
   <paramdef>struct request * <parameter>req</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>q</parameter></term>
   <listitem>
    <para>
     request queue for the request
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>req</parameter></term>
   <listitem>
    <para>
     the request to prepare
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
<title>Description</title>
<para>
   Allocate the necessary i2o_block_request struct and connect it to
   the request. This is needed that we not lose the SG list later on.
   </para><para>

   Returns BLKPREP_OK on success or BLKPREP_DEFER on failure.
</para>
</refsect1>
</refentry>

<refentry id="API-i2o-block-delayed-request-fn">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>July 2015</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>i2o_block_delayed_request_fn</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.4.104</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>i2o_block_delayed_request_fn</refname>
 <refpurpose>
     delayed request queue function
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>void <function>i2o_block_delayed_request_fn </function></funcdef>
   <paramdef>struct work_struct * <parameter>work</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>work</parameter></term>
   <listitem>
    <para>
     the delayed request with the queue to start
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
<title>Description</title>
<para>
   If the request queue is stopped for a disk, and there is no open
   request, a new event is created, which calls this function to start
   the queue after I2O_BLOCK_REQUEST_TIME. Otherwise the queue will never
   be started again.
</para>
</refsect1>
</refentry>

<refentry id="API-i2o-block-end-request">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>July 2015</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>i2o_block_end_request</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.4.104</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>i2o_block_end_request</refname>
 <refpurpose>
     Post-processing of completed commands
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>void <function>i2o_block_end_request </function></funcdef>
   <paramdef>struct request * <parameter>req</parameter></paramdef>
   <paramdef>int <parameter>error</parameter></paramdef>
   <paramdef>int <parameter>nr_bytes</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>req</parameter></term>
   <listitem>
    <para>
     request which should be completed
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>error</parameter></term>
   <listitem>
    <para>
     0 for success, &lt; 0 for error
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>nr_bytes</parameter></term>
   <listitem>
    <para>
     number of bytes to complete
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
<title>Description</title>
<para>
   Mark the request as complete. The lock must not be held when entering.
</para>
</refsect1>
</refentry>

<refentry id="API-i2o-block-reply">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>July 2015</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>i2o_block_reply</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.4.104</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>i2o_block_reply</refname>
 <refpurpose>
     Block OSM reply handler.
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>int <function>i2o_block_reply </function></funcdef>
   <paramdef>struct i2o_controller * <parameter>c</parameter></paramdef>
   <paramdef>u32 <parameter>m</parameter></paramdef>
   <paramdef>struct i2o_message * <parameter>msg</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>c</parameter></term>
   <listitem>
    <para>
     I2O controller from which the message arrives
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>m</parameter></term>
   <listitem>
    <para>
     message id of reply
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>msg</parameter></term>
   <listitem>
    <para>
     the actual I2O message reply
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
<title>Description</title>
<para>
   This function gets all the message replies.
</para>
</refsect1>
</refentry>

<refentry id="API-i2o-block-open">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>July 2015</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>i2o_block_open</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.4.104</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>i2o_block_open</refname>
 <refpurpose>
     Open the block device
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>int <function>i2o_block_open </function></funcdef>
   <paramdef>struct block_device * <parameter>bdev</parameter></paramdef>
   <paramdef>fmode_t <parameter>mode</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>bdev</parameter></term>
   <listitem>
    <para>
     block device being opened
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>mode</parameter></term>
   <listitem>
    <para>
     file open mode
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
<title>Description</title>
<para>
   Power up the device, mount and lock the media. This function is called,
   if the block device is opened for access.
   </para><para>

   Returns 0 on success or negative error code on failure.
</para>
</refsect1>
</refentry>

<refentry id="API-i2o-block-release">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>July 2015</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>i2o_block_release</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.4.104</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>i2o_block_release</refname>
 <refpurpose>
     Release the I2O block device
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>int <function>i2o_block_release </function></funcdef>
   <paramdef>struct gendisk * <parameter>disk</parameter></paramdef>
   <paramdef>fmode_t <parameter>mode</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>disk</parameter></term>
   <listitem>
    <para>
     gendisk device being released
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>mode</parameter></term>
   <listitem>
    <para>
     file open mode
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
<title>Description</title>
<para>
   Unlock and unmount the media, and power down the device. Gets called if
   the block device is closed.
   </para><para>

   Returns 0 on success or negative error code on failure.
</para>
</refsect1>
</refentry>

<refentry id="API-i2o-block-ioctl">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>July 2015</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>i2o_block_ioctl</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.4.104</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>i2o_block_ioctl</refname>
 <refpurpose>
     Issue device specific ioctl calls.
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>int <function>i2o_block_ioctl </function></funcdef>
   <paramdef>struct block_device * <parameter>bdev</parameter></paramdef>
   <paramdef>fmode_t <parameter>mode</parameter></paramdef>
   <paramdef>unsigned int <parameter>cmd</parameter></paramdef>
   <paramdef>unsigned long <parameter>arg</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>bdev</parameter></term>
   <listitem>
    <para>
     block device being opened
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>mode</parameter></term>
   <listitem>
    <para>
     file open mode
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>cmd</parameter></term>
   <listitem>
    <para>
     ioctl command
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>arg</parameter></term>
   <listitem>
    <para>
     arg
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
<title>Description</title>
<para>
   Handles ioctl request for the block device.
   </para><para>

   Return 0 on success or negative error on failure.
</para>
</refsect1>
</refentry>

<refentry id="API-i2o-block-check-events">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>July 2015</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>i2o_block_check_events</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.4.104</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>i2o_block_check_events</refname>
 <refpurpose>
     Have we seen a media change?
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>unsigned int <function>i2o_block_check_events </function></funcdef>
   <paramdef>struct gendisk * <parameter>disk</parameter></paramdef>
   <paramdef>unsigned int <parameter>clearing</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>disk</parameter></term>
   <listitem>
    <para>
     gendisk which should be verified
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>clearing</parameter></term>
   <listitem>
    <para>
     events being cleared
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
<title>Description</title>
<para>
   Verifies if the media has changed.
   </para><para>

   Returns 1 if the media was changed or 0 otherwise.
</para>
</refsect1>
</refentry>

<refentry id="API-i2o-block-transfer">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>July 2015</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>i2o_block_transfer</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.4.104</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>i2o_block_transfer</refname>
 <refpurpose>
     Transfer a request to/from the I2O controller
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>int <function>i2o_block_transfer </function></funcdef>
   <paramdef>struct request * <parameter>req</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>req</parameter></term>
   <listitem>
    <para>
     the request which should be transferred
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
<title>Description</title>
<para>
   This function converts the request into a I2O message. The necessary
   DMA buffers are allocated and after everything is setup post the message
   to the I2O controller. No cleanup is done by this function. It is done
   on the interrupt side when the reply arrives.
   </para><para>

   Return 0 on success or negative error code on failure.
</para>
</refsect1>
</refentry>

<refentry id="API-i2o-block-request-fn">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>July 2015</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>i2o_block_request_fn</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.4.104</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>i2o_block_request_fn</refname>
 <refpurpose>
     request queue handling function
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>void <function>i2o_block_request_fn </function></funcdef>
   <paramdef>struct request_queue * <parameter>q</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>q</parameter></term>
   <listitem>
    <para>
     request queue from which the request could be fetched
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
<title>Description</title>
<para>
   Takes the next request from the queue, transfers it and if no error
   occurs dequeue it from the queue. On arrival of the reply the message
   will be processed further. If an error occurs requeue the request.
</para>
</refsect1>
</refentry>

<refentry id="API-i2o-block-device-alloc">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>July 2015</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>i2o_block_device_alloc</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.4.104</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>i2o_block_device_alloc</refname>
 <refpurpose>
     Allocate memory for a I2O Block device
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>struct i2o_block_device * <function>i2o_block_device_alloc </function></funcdef>
   <paramdef> <parameter>void</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>void</parameter></term>
   <listitem>
    <para>
     no arguments
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
<title>Description</title>
<para>
   </para><para>

   Allocate memory for the i2o_block_device struct, gendisk and request
   queue and initialize them as far as no additional information is needed.
   </para><para>

   Returns a pointer to the allocated I2O Block device on success or a
   negative error code on failure.
</para>
</refsect1>
</refentry>

<refentry id="API-i2o-block-probe">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>July 2015</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>i2o_block_probe</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.4.104</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>i2o_block_probe</refname>
 <refpurpose>
     verify if dev is a I2O Block device and install it
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>int <function>i2o_block_probe </function></funcdef>
   <paramdef>struct device * <parameter>dev</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>dev</parameter></term>
   <listitem>
    <para>
     device to verify if it is a I2O Block device
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
<title>Description</title>
<para>
   We only verify if the user_tid of the device is 0xfff and then install
   the device. Otherwise it is used by some other device (e. g. RAID).
   </para><para>

   Returns 0 on success or negative error code on failure.
</para>
</refsect1>
</refentry>

<refentry id="API-i2o-block-init">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>July 2015</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>i2o_block_init</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.4.104</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>i2o_block_init</refname>
 <refpurpose>
     Block OSM initialization function
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>int <function>i2o_block_init </function></funcdef>
   <paramdef> <parameter>void</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>void</parameter></term>
   <listitem>
    <para>
     no arguments
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
<title>Description</title>
<para>
   </para><para>

   Allocate the slab and mempool for request structs, registers i2o_block
   block device and finally register the Block OSM in the I2O core.
   </para><para>

   Returns 0 on success or negative error code on failure.
</para>
</refsect1>
</refentry>

<refentry id="API-i2o-block-exit">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>July 2015</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>i2o_block_exit</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.4.104</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>i2o_block_exit</refname>
 <refpurpose>
     Block OSM exit function
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>void __exit <function>i2o_block_exit </function></funcdef>
   <paramdef> <parameter>void</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>void</parameter></term>
   <listitem>
    <para>
     no arguments
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
<title>Description</title>
<para>
   </para><para>

   Unregisters Block OSM from I2O core, unregisters i2o_block block device
   and frees the mempool and slab.
</para>
</refsect1>
</refentry>

<!-- drivers/message/i2o/i2o_scsi.c -->
<refentry id="API-i2o-scsi-get-host">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>July 2015</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>i2o_scsi_get_host</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.4.104</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>i2o_scsi_get_host</refname>
 <refpurpose>
  Get an I2O SCSI host
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>struct i2o_scsi_host * <function>i2o_scsi_get_host </function></funcdef>
   <paramdef>struct i2o_controller * <parameter>c</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>c</parameter></term>
   <listitem>
    <para>
     I2O controller to for which to get the SCSI host
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
<title>Description</title>
<para>
   If the I2O controller already exists as SCSI host, the SCSI host
   is returned, otherwise the I2O controller is added to the SCSI
   core.
   </para><para>

   Returns pointer to the I2O SCSI host on success or NULL on failure.
</para>
</refsect1>
</refentry>

<refentry id="API-i2o-scsi-remove">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>July 2015</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>i2o_scsi_remove</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.4.104</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>i2o_scsi_remove</refname>
 <refpurpose>
     Remove I2O device from SCSI core
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>int <function>i2o_scsi_remove </function></funcdef>
   <paramdef>struct device * <parameter>dev</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>dev</parameter></term>
   <listitem>
    <para>
     device which should be removed
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
<title>Description</title>
<para>
   Removes the I2O device from the SCSI core again.
   </para><para>

   Returns 0 on success.
</para>
</refsect1>
</refentry>

<refentry id="API-i2o-scsi-probe">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>July 2015</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>i2o_scsi_probe</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.4.104</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>i2o_scsi_probe</refname>
 <refpurpose>
     verify if dev is a I2O SCSI device and install it
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>int <function>i2o_scsi_probe </function></funcdef>
   <paramdef>struct device * <parameter>dev</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>dev</parameter></term>
   <listitem>
    <para>
     device to verify if it is a I2O SCSI device
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
<title>Description</title>
<para>
   Retrieve channel, id and lun for I2O device. If everything goes well
   register the I2O device as SCSI device on the I2O SCSI controller.
   </para><para>

   Returns 0 on success or negative error code on failure.
</para>
</refsect1>
</refentry>

<refentry id="API-i2o-scsi-reply">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>July 2015</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>i2o_scsi_reply</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.4.104</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>i2o_scsi_reply</refname>
 <refpurpose>
     SCSI OSM message reply handler
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>int <function>i2o_scsi_reply </function></funcdef>
   <paramdef>struct i2o_controller * <parameter>c</parameter></paramdef>
   <paramdef>u32 <parameter>m</parameter></paramdef>
   <paramdef>struct i2o_message * <parameter>msg</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>c</parameter></term>
   <listitem>
    <para>
     controller issuing the reply
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>m</parameter></term>
   <listitem>
    <para>
     message id for flushing
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>msg</parameter></term>
   <listitem>
    <para>
     the message from the controller
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
<title>Description</title>
<para>
   Process reply messages (interrupts in normal scsi controller think).
   We can get a variety of messages to process. The normal path is
   scsi command completions. We must also deal with IOP failures,
   the reply to a bus reset and the reply to a LUN query.
   </para><para>

   Returns 0 on success and if the reply should not be flushed or &gt; 0
   on success and if the reply should be flushed. Returns negative error
   code on failure and if the reply should be flushed.
</para>
</refsect1>
</refentry>

<refentry id="API-i2o-scsi-notify-device-add">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>July 2015</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>i2o_scsi_notify_device_add</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.4.104</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>i2o_scsi_notify_device_add</refname>
 <refpurpose>
     Retrieve notifications of added devices
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>void <function>i2o_scsi_notify_device_add </function></funcdef>
   <paramdef>struct i2o_device * <parameter>i2o_dev</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>i2o_dev</parameter></term>
   <listitem>
    <para>
     the I2O device which was added
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
<title>Description</title>
<para>
   If a I2O device is added we catch the notification, because I2O classes
   other than SCSI peripheral will not be received through
   <function>i2o_scsi_probe</function>.
</para>
</refsect1>
</refentry>

<refentry id="API-i2o-scsi-notify-device-remove">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>July 2015</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>i2o_scsi_notify_device_remove</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.4.104</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>i2o_scsi_notify_device_remove</refname>
 <refpurpose>
     Retrieve notifications of removed devices
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>void <function>i2o_scsi_notify_device_remove </function></funcdef>
   <paramdef>struct i2o_device * <parameter>i2o_dev</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>i2o_dev</parameter></term>
   <listitem>
    <para>
     the I2O device which was removed
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
<title>Description</title>
<para>
   If a I2O device is removed, we catch the notification to remove the
   corresponding SCSI device.
</para>
</refsect1>
</refentry>

<refentry id="API-i2o-scsi-notify-controller-add">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>July 2015</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>i2o_scsi_notify_controller_add</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.4.104</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>i2o_scsi_notify_controller_add</refname>
 <refpurpose>
     Retrieve notifications of added controllers
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>void <function>i2o_scsi_notify_controller_add </function></funcdef>
   <paramdef>struct i2o_controller * <parameter>c</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>c</parameter></term>
   <listitem>
    <para>
     the controller which was added
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
<title>Description</title>
<para>
   If a I2O controller is added, we catch the notification to add a
   corresponding Scsi_Host.
</para>
</refsect1>
</refentry>

<refentry id="API-i2o-scsi-notify-controller-remove">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>July 2015</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>i2o_scsi_notify_controller_remove</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.4.104</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>i2o_scsi_notify_controller_remove</refname>
 <refpurpose>
     Retrieve notifications of removed controllers
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>void <function>i2o_scsi_notify_controller_remove </function></funcdef>
   <paramdef>struct i2o_controller * <parameter>c</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>c</parameter></term>
   <listitem>
    <para>
     the controller which was removed
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
<title>Description</title>
<para>
   If a I2O controller is removed, we catch the notification to remove the
   corresponding Scsi_Host.
</para>
</refsect1>
</refentry>

<refentry id="API-i2o-scsi-queuecommand-lck">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>July 2015</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>i2o_scsi_queuecommand_lck</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.4.104</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>i2o_scsi_queuecommand_lck</refname>
 <refpurpose>
     queue a SCSI command
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>int <function>i2o_scsi_queuecommand_lck </function></funcdef>
   <paramdef>struct scsi_cmnd * <parameter>SCpnt</parameter></paramdef>
   <paramdef>void (*<parameter>done</parameter>)
     <funcparams>struct scsi_cmnd *</funcparams></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>SCpnt</parameter></term>
   <listitem>
    <para>
     scsi command pointer
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>done</parameter></term>
   <listitem>
    <para>
     callback for completion
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
<title>Description</title>
<para>
   Issue a scsi command asynchronously. Return 0 on success or 1 if
   we hit an error (normally message queue congestion). The only
   minor complication here is that I2O deals with the device addressing
   so we have to map the bus/dev/lun back to an I2O handle as well
   as faking absent devices ourself.
</para>
</refsect1>
<refsect1>
<title>Locks</title>
<para>
   takes the controller lock on error path only
</para>
</refsect1>
</refentry>

<refentry id="API-i2o-scsi-abort">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>July 2015</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>i2o_scsi_abort</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.4.104</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>i2o_scsi_abort</refname>
 <refpurpose>
     abort a running command
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>int <function>i2o_scsi_abort </function></funcdef>
   <paramdef>struct scsi_cmnd * <parameter>SCpnt</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>SCpnt</parameter></term>
   <listitem>
    <para>
     command to abort
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
<title>Description</title>
<para>
   Ask the I2O controller to abort a command. This is an asynchrnous
   process and our callback handler will see the command complete with an
   aborted message if it succeeds.
   </para><para>

   Returns 0 if the command is successfully aborted or negative error code
   on failure.
</para>
</refsect1>
</refentry>

<refentry id="API-i2o-scsi-bios-param">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>July 2015</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>i2o_scsi_bios_param</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.4.104</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>i2o_scsi_bios_param</refname>
 <refpurpose>
     Invent disk geometry
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>int <function>i2o_scsi_bios_param </function></funcdef>
   <paramdef>struct scsi_device * <parameter>sdev</parameter></paramdef>
   <paramdef>struct block_device * <parameter>dev</parameter></paramdef>
   <paramdef>sector_t <parameter>capacity</parameter></paramdef>
   <paramdef>int * <parameter>ip</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>sdev</parameter></term>
   <listitem>
    <para>
     scsi device
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>dev</parameter></term>
   <listitem>
    <para>
     block layer device
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>capacity</parameter></term>
   <listitem>
    <para>
     size in sectors
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>ip</parameter></term>
   <listitem>
    <para>
     geometry array
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
<title>Description</title>
<para>
   This is anyone's guess quite frankly. We use the same rules everyone
   else appears to and hope. It seems to work.
</para>
</refsect1>
</refentry>

<refentry id="API-i2o-scsi-init">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>July 2015</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>i2o_scsi_init</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.4.104</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>i2o_scsi_init</refname>
 <refpurpose>
     SCSI OSM initialization function
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>int <function>i2o_scsi_init </function></funcdef>
   <paramdef> <parameter>void</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>void</parameter></term>
   <listitem>
    <para>
     no arguments
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
<title>Description</title>
<para>
   </para><para>

   Register SCSI OSM into I2O core.
   </para><para>

   Returns 0 on success or negative error code on failure.
</para>
</refsect1>
</refentry>

<refentry id="API-i2o-scsi-exit">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>July 2015</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>i2o_scsi_exit</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.4.104</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>i2o_scsi_exit</refname>
 <refpurpose>
     SCSI OSM exit function
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>void __exit <function>i2o_scsi_exit </function></funcdef>
   <paramdef> <parameter>void</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>void</parameter></term>
   <listitem>
    <para>
     no arguments
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
<title>Description</title>
<para>
   </para><para>

   Unregisters SCSI OSM from I2O core.
</para>
</refsect1>
</refentry>

<!-- drivers/message/i2o/i2o_proc.c -->
<refentry id="API-i2o-get-class-name">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>July 2015</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>i2o_get_class_name</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.4.104</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>i2o_get_class_name</refname>
 <refpurpose>
  do i2o class name lookup
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>const char * <function>i2o_get_class_name </function></funcdef>
   <paramdef>int <parameter>class</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>class</parameter></term>
   <listitem>
    <para>
     class number
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
<title>Description</title>
<para>
   Return a descriptive string for an i2o class.
</para>
</refsect1>
</refentry>

<refentry id="API-i2o-proc-create-entries">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>July 2015</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>i2o_proc_create_entries</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.4.104</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>i2o_proc_create_entries</refname>
 <refpurpose>
     Creates proc dir entries
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>int <function>i2o_proc_create_entries </function></funcdef>
   <paramdef>struct proc_dir_entry * <parameter>dir</parameter></paramdef>
   <paramdef>i2o_proc_entry * <parameter>i2o_pe</parameter></paramdef>
   <paramdef>void * <parameter>data</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>dir</parameter></term>
   <listitem>
    <para>
     proc dir entry under which the entries should be placed
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>i2o_pe</parameter></term>
   <listitem>
    <para>
     pointer to the entries which should be added
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>data</parameter></term>
   <listitem>
    <para>
     pointer to I2O controller or device
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
<title>Description</title>
<para>
   Create proc dir entries for a I2O controller or I2O device.
   </para><para>

   Returns 0 on success or negative error code on failure.
</para>
</refsect1>
</refentry>

<refentry id="API-i2o-proc-subdir-remove">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>July 2015</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>i2o_proc_subdir_remove</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.4.104</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>i2o_proc_subdir_remove</refname>
 <refpurpose>
     Remove child entries from a proc entry
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>void <function>i2o_proc_subdir_remove </function></funcdef>
   <paramdef>struct proc_dir_entry * <parameter>dir</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>dir</parameter></term>
   <listitem>
    <para>
     proc dir entry from which the childs should be removed
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
<title>Description</title>
<para>
   Iterate over each i2o proc entry under dir and remove it. If the child
   also has entries, remove them too.
</para>
</refsect1>
</refentry>

<refentry id="API-i2o-proc-device-add">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>July 2015</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>i2o_proc_device_add</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.4.104</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>i2o_proc_device_add</refname>
 <refpurpose>
     Add an I2O device to the proc dir
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>void <function>i2o_proc_device_add </function></funcdef>
   <paramdef>struct proc_dir_entry * <parameter>dir</parameter></paramdef>
   <paramdef>struct i2o_device * <parameter>dev</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>dir</parameter></term>
   <listitem>
    <para>
     proc dir entry to which the device should be added
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>dev</parameter></term>
   <listitem>
    <para>
     I2O device which should be added
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
<title>Description</title>
<para>
   Add an I2O device to the proc dir entry dir and create the entries for
   the device depending on the class of the I2O device.
</para>
</refsect1>
</refentry>

<refentry id="API-i2o-proc-iop-add">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>July 2015</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>i2o_proc_iop_add</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.4.104</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>i2o_proc_iop_add</refname>
 <refpurpose>
     Add an I2O controller to the i2o proc tree
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>int <function>i2o_proc_iop_add </function></funcdef>
   <paramdef>struct proc_dir_entry * <parameter>dir</parameter></paramdef>
   <paramdef>struct i2o_controller * <parameter>c</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>dir</parameter></term>
   <listitem>
    <para>
     parent proc dir entry
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>c</parameter></term>
   <listitem>
    <para>
     I2O controller which should be added
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
<title>Description</title>
<para>
   Add the entries to the parent proc dir entry. Also each device is added
   to the controllers proc dir entry.
   </para><para>

   Returns 0 on success or negative error code on failure.
</para>
</refsect1>
</refentry>

<refentry id="API-i2o-proc-iop-remove">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>July 2015</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>i2o_proc_iop_remove</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.4.104</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>i2o_proc_iop_remove</refname>
 <refpurpose>
     Removes an I2O controller from the i2o proc tree
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>void <function>i2o_proc_iop_remove </function></funcdef>
   <paramdef>struct proc_dir_entry * <parameter>dir</parameter></paramdef>
   <paramdef>struct i2o_controller * <parameter>c</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>dir</parameter></term>
   <listitem>
    <para>
     parent proc dir entry
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>c</parameter></term>
   <listitem>
    <para>
     I2O controller which should be removed
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
<title>Description</title>
<para>
   Iterate over each i2o proc entry and search controller c. If it is found
   remove it from the tree.
</para>
</refsect1>
</refentry>

<refentry id="API-i2o-proc-fs-create">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>July 2015</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>i2o_proc_fs_create</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.4.104</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>i2o_proc_fs_create</refname>
 <refpurpose>
     Create the i2o proc fs.
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>int <function>i2o_proc_fs_create </function></funcdef>
   <paramdef> <parameter>void</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>void</parameter></term>
   <listitem>
    <para>
     no arguments
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
<title>Description</title>
<para>
   </para><para>

   Iterate over each I2O controller and create the entries for it.
   </para><para>

   Returns 0 on success or negative error code on failure.
</para>
</refsect1>
</refentry>

<refentry id="API-i2o-proc-fs-destroy">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>July 2015</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>i2o_proc_fs_destroy</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.4.104</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>i2o_proc_fs_destroy</refname>
 <refpurpose>
     Cleanup the all i2o proc entries
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>int __exit <function>i2o_proc_fs_destroy </function></funcdef>
   <paramdef> <parameter>void</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>void</parameter></term>
   <listitem>
    <para>
     no arguments
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
<title>Description</title>
<para>
   </para><para>

   Iterate over each I2O controller and remove the entries for it.
   </para><para>

   Returns 0 on success or negative error code on failure.
</para>
</refsect1>
</refentry>

<refentry id="API-i2o-proc-init">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>July 2015</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>i2o_proc_init</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.4.104</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>i2o_proc_init</refname>
 <refpurpose>
     Init function for procfs
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>int <function>i2o_proc_init </function></funcdef>
   <paramdef> <parameter>void</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>void</parameter></term>
   <listitem>
    <para>
     no arguments
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
<title>Description</title>
<para>
   </para><para>

   Registers Proc OSM and creates procfs entries.
   </para><para>

   Returns 0 on success or negative error code on failure.
</para>
</refsect1>
</refentry>

<refentry id="API-i2o-proc-exit">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>July 2015</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>i2o_proc_exit</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.4.104</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>i2o_proc_exit</refname>
 <refpurpose>
     Exit function for procfs
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>void __exit <function>i2o_proc_exit </function></funcdef>
   <paramdef> <parameter>void</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>void</parameter></term>
   <listitem>
    <para>
     no arguments
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
<title>Description</title>
<para>
   </para><para>

   Unregisters Proc OSM and removes procfs entries.
</para>
</refsect1>
</refentry>

     </sect1>
  </chapter>

  <chapter id="snddev">
     <title>Sound Devices</title>
<!-- include/sound/core.h -->
<refentry id="API-snd-register-device">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>July 2015</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>snd_register_device</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.4.104</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>snd_register_device</refname>
 <refpurpose>
  Register the ALSA device file for the card
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>int <function>snd_register_device </function></funcdef>
   <paramdef>int <parameter>type</parameter></paramdef>
   <paramdef>struct snd_card * <parameter>card</parameter></paramdef>
   <paramdef>int <parameter>dev</parameter></paramdef>
   <paramdef>const struct file_operations * <parameter>f_ops</parameter></paramdef>
   <paramdef>void * <parameter>private_data</parameter></paramdef>
   <paramdef>const char * <parameter>name</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>type</parameter></term>
   <listitem>
    <para>
     the device type, SNDRV_DEVICE_TYPE_XXX
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>card</parameter></term>
   <listitem>
    <para>
     the card instance
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>dev</parameter></term>
   <listitem>
    <para>
     the device index
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>f_ops</parameter></term>
   <listitem>
    <para>
     the file operations
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>private_data</parameter></term>
   <listitem>
    <para>
     user pointer for f_ops-&gt;<function>open</function>
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>name</parameter></term>
   <listitem>
    <para>
     the device file name
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
<title>Description</title>
<para>
   Registers an ALSA device file for the given card.
   The operators have to be set in reg parameter.
   </para><para>

   This function uses the card's device pointer to link to the
   correct <structname>struct device</structname>.
   </para><para>

   Returns zero if successful, or a negative error code on failure.
</para>
</refsect1>
</refentry>

<refentry id="API-snd-printk">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>July 2015</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>snd_printk</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.4.104</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>snd_printk</refname>
 <refpurpose>
     printk wrapper
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef> <function>snd_printk </function></funcdef>
   <paramdef> <parameter>fmt</parameter></paramdef>
   <paramdef> <parameter>args...</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>fmt</parameter></term>
   <listitem>
    <para>
     format string
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>args...</parameter></term>
   <listitem>
    <para>
     variable arguments
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
<title>Description</title>
<para>
   Works like <function>printk</function> but prints the file and the line of the caller
   when configured with CONFIG_SND_VERBOSE_PRINTK.
</para>
</refsect1>
</refentry>

<refentry id="API-snd-printd">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>July 2015</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>snd_printd</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.4.104</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>snd_printd</refname>
 <refpurpose>
     debug printk
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef> <function>snd_printd </function></funcdef>
   <paramdef> <parameter>fmt</parameter></paramdef>
   <paramdef> <parameter>args...</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>fmt</parameter></term>
   <listitem>
    <para>
     format string
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>args...</parameter></term>
   <listitem>
    <para>
     variable arguments
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
<title>Description</title>
<para>
   Works like <function>snd_printk</function> for debugging purposes.
   Ignored when CONFIG_SND_DEBUG is not set.
</para>
</refsect1>
</refentry>

<refentry id="API-snd-BUG">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>July 2015</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>snd_BUG</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.4.104</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>snd_BUG</refname>
 <refpurpose>
     give a BUG warning message and stack trace
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef> <function>snd_BUG </function></funcdef>
  <void/>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <para>
  None
 </para>
</refsect1>
<refsect1>
<title>Description</title>
<para>
   </para><para>

   Calls <function>WARN</function> if CONFIG_SND_DEBUG is set.
   Ignored when CONFIG_SND_DEBUG is not set.
</para>
</refsect1>
</refentry>

<refentry id="API-snd-BUG-ON">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>July 2015</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>snd_BUG_ON</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.4.104</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>snd_BUG_ON</refname>
 <refpurpose>
     debugging check macro
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef> <function>snd_BUG_ON </function></funcdef>
   <paramdef> <parameter>cond</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>cond</parameter></term>
   <listitem>
    <para>
     condition to evaluate
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
<title>Description</title>
<para>
   When CONFIG_SND_DEBUG is set, this macro evaluates the given condition,
   and call <function>WARN</function> and returns the value if it's non-zero.
   </para><para>

   When CONFIG_SND_DEBUG is not set, this just returns zero, and the given
   condition is ignored.
</para>
</refsect1>
<refsect1>
<title>NOTE</title>
<para>
   the argument won't be evaluated at all when CONFIG_SND_DEBUG=n.
   Thus, don't put any statement that influences on the code behavior,
   such as pre/post increment, to the argument of this macro.
   If you want to evaluate and give a warning, use standard <function>WARN_ON</function>.
</para>
</refsect1>
</refentry>

<refentry id="API-snd-printdd">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>July 2015</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>snd_printdd</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.4.104</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>snd_printdd</refname>
 <refpurpose>
     debug printk
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef> <function>snd_printdd </function></funcdef>
   <paramdef> <parameter>format</parameter></paramdef>
   <paramdef> <parameter>args...</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>format</parameter></term>
   <listitem>
    <para>
     format string
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>args...</parameter></term>
   <listitem>
    <para>
     variable arguments
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
<title>Description</title>
<para>
   Works like <function>snd_printk</function> for debugging purposes.
   Ignored when CONFIG_SND_DEBUG_VERBOSE is not set.
</para>
</refsect1>
</refentry>

<!-- sound/sound_core.c -->
<refentry id="API-register-sound-special-device">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>July 2015</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>register_sound_special_device</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.4.104</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>register_sound_special_device</refname>
 <refpurpose>
  register a special sound node
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>int <function>register_sound_special_device </function></funcdef>
   <paramdef>const struct file_operations * <parameter>fops</parameter></paramdef>
   <paramdef>int <parameter>unit</parameter></paramdef>
   <paramdef>struct device * <parameter>dev</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>fops</parameter></term>
   <listitem>
    <para>
     File operations for the driver
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>unit</parameter></term>
   <listitem>
    <para>
     Unit number to allocate
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>dev</parameter></term>
   <listitem>
    <para>
     device pointer
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
<title>Description</title>
<para>
   Allocate a special sound device by minor number from the sound
   subsystem. The allocated number is returned on success. On failure
   a negative error code is returned.
</para>
</refsect1>
</refentry>

<refentry id="API-register-sound-mixer">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>July 2015</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>register_sound_mixer</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.4.104</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>register_sound_mixer</refname>
 <refpurpose>
     register a mixer device
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>int <function>register_sound_mixer </function></funcdef>
   <paramdef>const struct file_operations * <parameter>fops</parameter></paramdef>
   <paramdef>int <parameter>dev</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>fops</parameter></term>
   <listitem>
    <para>
     File operations for the driver
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>dev</parameter></term>
   <listitem>
    <para>
     Unit number to allocate
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
<title>Description</title>
<para>
   Allocate a mixer device. Unit is the number of the mixer requested.
   Pass -1 to request the next free mixer unit. On success the allocated
   number is returned, on failure a negative error code is returned.
</para>
</refsect1>
</refentry>

<refentry id="API-register-sound-midi">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>July 2015</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>register_sound_midi</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.4.104</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>register_sound_midi</refname>
 <refpurpose>
     register a midi device
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>int <function>register_sound_midi </function></funcdef>
   <paramdef>const struct file_operations * <parameter>fops</parameter></paramdef>
   <paramdef>int <parameter>dev</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>fops</parameter></term>
   <listitem>
    <para>
     File operations for the driver
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>dev</parameter></term>
   <listitem>
    <para>
     Unit number to allocate
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
<title>Description</title>
<para>
   Allocate a midi device. Unit is the number of the midi device requested.
   Pass -1 to request the next free midi unit. On success the allocated
   number is returned, on failure a negative error code is returned.
</para>
</refsect1>
</refentry>

<refentry id="API-register-sound-dsp">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>July 2015</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>register_sound_dsp</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.4.104</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>register_sound_dsp</refname>
 <refpurpose>
     register a DSP device
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>int <function>register_sound_dsp </function></funcdef>
   <paramdef>const struct file_operations * <parameter>fops</parameter></paramdef>
   <paramdef>int <parameter>dev</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>fops</parameter></term>
   <listitem>
    <para>
     File operations for the driver
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>dev</parameter></term>
   <listitem>
    <para>
     Unit number to allocate
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
<title>Description</title>
<para>
   Allocate a DSP device. Unit is the number of the DSP requested.
   Pass -1 to request the next free DSP unit. On success the allocated
   number is returned, on failure a negative error code is returned.
   </para><para>

   This function allocates both the audio and dsp device entries together
   and will always allocate them as a matching pair - eg dsp3/audio3
</para>
</refsect1>
</refentry>

<refentry id="API-unregister-sound-special">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>July 2015</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>unregister_sound_special</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.4.104</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>unregister_sound_special</refname>
 <refpurpose>
     unregister a special sound device
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>void <function>unregister_sound_special </function></funcdef>
   <paramdef>int <parameter>unit</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>unit</parameter></term>
   <listitem>
    <para>
     unit number to allocate
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
<title>Description</title>
<para>
   Release a sound device that was allocated with
   <function>register_sound_special</function>. The unit passed is the return value from
   the register function.
</para>
</refsect1>
</refentry>

<refentry id="API-unregister-sound-mixer">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>July 2015</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>unregister_sound_mixer</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.4.104</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>unregister_sound_mixer</refname>
 <refpurpose>
     unregister a mixer
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>void <function>unregister_sound_mixer </function></funcdef>
   <paramdef>int <parameter>unit</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>unit</parameter></term>
   <listitem>
    <para>
     unit number to allocate
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
<title>Description</title>
<para>
   Release a sound device that was allocated with <function>register_sound_mixer</function>.
   The unit passed is the return value from the register function.
</para>
</refsect1>
</refentry>

<refentry id="API-unregister-sound-midi">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>July 2015</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>unregister_sound_midi</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.4.104</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>unregister_sound_midi</refname>
 <refpurpose>
     unregister a midi device
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>void <function>unregister_sound_midi </function></funcdef>
   <paramdef>int <parameter>unit</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>unit</parameter></term>
   <listitem>
    <para>
     unit number to allocate
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
<title>Description</title>
<para>
   Release a sound device that was allocated with <function>register_sound_midi</function>.
   The unit passed is the return value from the register function.
</para>
</refsect1>
</refentry>

<refentry id="API-unregister-sound-dsp">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>July 2015</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>unregister_sound_dsp</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.4.104</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>unregister_sound_dsp</refname>
 <refpurpose>
     unregister a DSP device
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>void <function>unregister_sound_dsp </function></funcdef>
   <paramdef>int <parameter>unit</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>unit</parameter></term>
   <listitem>
    <para>
     unit number to allocate
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
<title>Description</title>
<para>
   Release a sound device that was allocated with <function>register_sound_dsp</function>.
   The unit passed is the return value from the register function.
   </para><para>

   Both of the allocated units are released together automatically.
</para>
</refsect1>
</refentry>

<!-- include/sound/pcm.h -->
<refentry id="API-snd-pcm-playback-ready">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>July 2015</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>snd_pcm_playback_ready</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.4.104</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>snd_pcm_playback_ready</refname>
 <refpurpose>
  check whether the playback buffer is available
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>int <function>snd_pcm_playback_ready </function></funcdef>
   <paramdef>struct snd_pcm_substream * <parameter>substream</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>substream</parameter></term>
   <listitem>
    <para>
     the pcm substream instance
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
<title>Description</title>
<para>
   Checks whether enough free space is available on the playback buffer.
   </para><para>

   Returns non-zero if available, or zero if not.
</para>
</refsect1>
</refentry>

<refentry id="API-snd-pcm-capture-ready">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>July 2015</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>snd_pcm_capture_ready</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.4.104</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>snd_pcm_capture_ready</refname>
 <refpurpose>
     check whether the capture buffer is available
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>int <function>snd_pcm_capture_ready </function></funcdef>
   <paramdef>struct snd_pcm_substream * <parameter>substream</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>substream</parameter></term>
   <listitem>
    <para>
     the pcm substream instance
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
<title>Description</title>
<para>
   Checks whether enough capture data is available on the capture buffer.
   </para><para>

   Returns non-zero if available, or zero if not.
</para>
</refsect1>
</refentry>

<refentry id="API-snd-pcm-playback-data">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>July 2015</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>snd_pcm_playback_data</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.4.104</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>snd_pcm_playback_data</refname>
 <refpurpose>
     check whether any data exists on the playback buffer
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>int <function>snd_pcm_playback_data </function></funcdef>
   <paramdef>struct snd_pcm_substream * <parameter>substream</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>substream</parameter></term>
   <listitem>
    <para>
     the pcm substream instance
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
<title>Description</title>
<para>
   Checks whether any data exists on the playback buffer. If stop_threshold
   is bigger or equal to boundary, then this function returns always non-zero.
   </para><para>

   Returns non-zero if exists, or zero if not.
</para>
</refsect1>
</refentry>

<refentry id="API-snd-pcm-playback-empty">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>July 2015</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>snd_pcm_playback_empty</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.4.104</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>snd_pcm_playback_empty</refname>
 <refpurpose>
     check whether the playback buffer is empty
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>int <function>snd_pcm_playback_empty </function></funcdef>
   <paramdef>struct snd_pcm_substream * <parameter>substream</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>substream</parameter></term>
   <listitem>
    <para>
     the pcm substream instance
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
<title>Description</title>
<para>
   Checks whether the playback buffer is empty.
   </para><para>

   Returns non-zero if empty, or zero if not.
</para>
</refsect1>
</refentry>

<refentry id="API-snd-pcm-capture-empty">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>July 2015</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>snd_pcm_capture_empty</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.4.104</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>snd_pcm_capture_empty</refname>
 <refpurpose>
     check whether the capture buffer is empty
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>int <function>snd_pcm_capture_empty </function></funcdef>
   <paramdef>struct snd_pcm_substream * <parameter>substream</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>substream</parameter></term>
   <listitem>
    <para>
     the pcm substream instance
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
<title>Description</title>
<para>
   Checks whether the capture buffer is empty.
   </para><para>

   Returns non-zero if empty, or zero if not.
</para>
</refsect1>
</refentry>

<refentry id="API-snd-pcm-format-cpu-endian">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>July 2015</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>snd_pcm_format_cpu_endian</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.4.104</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>snd_pcm_format_cpu_endian</refname>
 <refpurpose>
     Check the PCM format is CPU-endian
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>int <function>snd_pcm_format_cpu_endian </function></funcdef>
   <paramdef>snd_pcm_format_t <parameter>format</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>format</parameter></term>
   <listitem>
    <para>
     the format to check
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
<title>Description</title>
<para>
   Returns 1 if the given PCM format is CPU-endian, 0 if
   opposite, or a negative error code if endian not specified.
</para>
</refsect1>
</refentry>

<refentry id="API-snd-pcm-lib-alloc-vmalloc-buffer">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>July 2015</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>snd_pcm_lib_alloc_vmalloc_buffer</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.4.104</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>snd_pcm_lib_alloc_vmalloc_buffer</refname>
 <refpurpose>
     allocate virtual DMA buffer
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>int <function>snd_pcm_lib_alloc_vmalloc_buffer </function></funcdef>
   <paramdef>struct snd_pcm_substream * <parameter>substream</parameter></paramdef>
   <paramdef>size_t <parameter>size</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>substream</parameter></term>
   <listitem>
    <para>
     the substream to allocate the buffer to
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>size</parameter></term>
   <listitem>
    <para>
     the requested buffer size, in bytes
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
<title>Description</title>
<para>
   Allocates the PCM substream buffer using <function>vmalloc</function>, i.e., the memory is
   contiguous in kernel virtual space, but not in physical memory.  Use this
   if the buffer is accessed by kernel code but not by device DMA.
   </para><para>

   Returns 1 if the buffer was changed, 0 if not changed, or a negative error
   code.
</para>
</refsect1>
</refentry>

<refentry id="API-snd-pcm-lib-alloc-vmalloc-32-buffer">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>July 2015</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>snd_pcm_lib_alloc_vmalloc_32_buffer</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.4.104</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>snd_pcm_lib_alloc_vmalloc_32_buffer</refname>
 <refpurpose>
     allocate 32-bit-addressable buffer
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>int <function>snd_pcm_lib_alloc_vmalloc_32_buffer </function></funcdef>
   <paramdef>struct snd_pcm_substream * <parameter>substream</parameter></paramdef>
   <paramdef>size_t <parameter>size</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>substream</parameter></term>
   <listitem>
    <para>
     the substream to allocate the buffer to
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>size</parameter></term>
   <listitem>
    <para>
     the requested buffer size, in bytes
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
<title>Description</title>
<para>
   This function works like <function>snd_pcm_lib_alloc_vmalloc_buffer</function>, but uses
   <function>vmalloc_32</function>, i.e., the pages are allocated from 32-bit-addressable memory.
</para>
</refsect1>
</refentry>

<!-- sound/core/pcm.c -->
<refentry id="API-snd-pcm-new-stream">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>July 2015</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>snd_pcm_new_stream</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.4.104</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>snd_pcm_new_stream</refname>
 <refpurpose>
  create a new PCM stream
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>int <function>snd_pcm_new_stream </function></funcdef>
   <paramdef>struct snd_pcm * <parameter>pcm</parameter></paramdef>
   <paramdef>int <parameter>stream</parameter></paramdef>
   <paramdef>int <parameter>substream_count</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>pcm</parameter></term>
   <listitem>
    <para>
     the pcm instance
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>stream</parameter></term>
   <listitem>
    <para>
     the stream direction, SNDRV_PCM_STREAM_XXX
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>substream_count</parameter></term>
   <listitem>
    <para>
     the number of substreams
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
<title>Description</title>
<para>
   Creates a new stream for the pcm.
   The corresponding stream on the pcm must have been empty before
   calling this, i.e. zero must be given to the argument of
   <function>snd_pcm_new</function>.
   </para><para>

   Returns zero if successful, or a negative error code on failure.
</para>
</refsect1>
</refentry>

<refentry id="API-snd-pcm-new">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>July 2015</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>snd_pcm_new</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.4.104</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>snd_pcm_new</refname>
 <refpurpose>
     create a new PCM instance
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>int <function>snd_pcm_new </function></funcdef>
   <paramdef>struct snd_card * <parameter>card</parameter></paramdef>
   <paramdef>const char * <parameter>id</parameter></paramdef>
   <paramdef>int <parameter>device</parameter></paramdef>
   <paramdef>int <parameter>playback_count</parameter></paramdef>
   <paramdef>int <parameter>capture_count</parameter></paramdef>
   <paramdef>struct snd_pcm ** <parameter>rpcm</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>card</parameter></term>
   <listitem>
    <para>
     the card instance
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>id</parameter></term>
   <listitem>
    <para>
     the id string
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>device</parameter></term>
   <listitem>
    <para>
     the device index (zero based)
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>playback_count</parameter></term>
   <listitem>
    <para>
     the number of substreams for playback
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>capture_count</parameter></term>
   <listitem>
    <para>
     the number of substreams for capture
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>rpcm</parameter></term>
   <listitem>
    <para>
     the pointer to store the new pcm instance
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
<title>Description</title>
<para>
   Creates a new PCM instance.
   </para><para>

   The pcm operators have to be set afterwards to the new instance
   via <function>snd_pcm_set_ops</function>.
   </para><para>

   Returns zero if successful, or a negative error code on failure.
</para>
</refsect1>
</refentry>

<refentry id="API-snd-pcm-new-internal">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>July 2015</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>snd_pcm_new_internal</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.4.104</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>snd_pcm_new_internal</refname>
 <refpurpose>
     create a new internal PCM instance
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>int <function>snd_pcm_new_internal </function></funcdef>
   <paramdef>struct snd_card * <parameter>card</parameter></paramdef>
   <paramdef>const char * <parameter>id</parameter></paramdef>
   <paramdef>int <parameter>device</parameter></paramdef>
   <paramdef>int <parameter>playback_count</parameter></paramdef>
   <paramdef>int <parameter>capture_count</parameter></paramdef>
   <paramdef>struct snd_pcm ** <parameter>rpcm</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>card</parameter></term>
   <listitem>
    <para>
     the card instance
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>id</parameter></term>
   <listitem>
    <para>
     the id string
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>device</parameter></term>
   <listitem>
    <para>
     the device index (zero based - shared with normal PCMs)
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>playback_count</parameter></term>
   <listitem>
    <para>
     the number of substreams for playback
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>capture_count</parameter></term>
   <listitem>
    <para>
     the number of substreams for capture
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>rpcm</parameter></term>
   <listitem>
    <para>
     the pointer to store the new pcm instance
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
<title>Description</title>
<para>
   Creates a new internal PCM instance with no userspace device or procfs
   entries. This is used by ASoC Back End PCMs in order to create a PCM that
   will only be used internally by kernel drivers. i.e. it cannot be opened
   by userspace. It provides existing ASoC components drivers with a substream
   and access to any private data.
   </para><para>

   The pcm operators have to be set afterwards to the new instance
   via <function>snd_pcm_set_ops</function>.
   </para><para>

   Returns zero if successful, or a negative error code on failure.
</para>
</refsect1>
</refentry>

<!-- sound/core/device.c -->
<refentry id="API-snd-device-new">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>July 2015</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>snd_device_new</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.4.104</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>snd_device_new</refname>
 <refpurpose>
  create an ALSA device component
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>int <function>snd_device_new </function></funcdef>
   <paramdef>struct snd_card * <parameter>card</parameter></paramdef>
   <paramdef>snd_device_type_t <parameter>type</parameter></paramdef>
   <paramdef>void * <parameter>device_data</parameter></paramdef>
   <paramdef>struct snd_device_ops * <parameter>ops</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>card</parameter></term>
   <listitem>
    <para>
     the card instance
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>type</parameter></term>
   <listitem>
    <para>
     the device type, SNDRV_DEV_XXX
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>device_data</parameter></term>
   <listitem>
    <para>
     the data pointer of this device
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>ops</parameter></term>
   <listitem>
    <para>
     the operator table
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
<title>Description</title>
<para>
   Creates a new device component for the given data pointer.
   The device will be assigned to the card and managed together
   by the card.
   </para><para>

   The data pointer plays a role as the identifier, too, so the
   pointer address must be unique and unchanged.
   </para><para>

   Returns zero if successful, or a negative error code on failure.
</para>
</refsect1>
</refentry>

<refentry id="API-snd-device-free">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>July 2015</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>snd_device_free</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.4.104</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>snd_device_free</refname>
 <refpurpose>
     release the device from the card
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>int <function>snd_device_free </function></funcdef>
   <paramdef>struct snd_card * <parameter>card</parameter></paramdef>
   <paramdef>void * <parameter>device_data</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>card</parameter></term>
   <listitem>
    <para>
     the card instance
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>device_data</parameter></term>
   <listitem>
    <para>
     the data pointer to release
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
<title>Description</title>
<para>
   Removes the device from the list on the card and invokes the
   callbacks, dev_disconnect and dev_free, corresponding to the state.
   Then release the device.
   </para><para>

   Returns zero if successful, or a negative error code on failure or if the
   device not found.
</para>
</refsect1>
</refentry>

<refentry id="API-snd-device-register">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>July 2015</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>snd_device_register</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.4.104</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>snd_device_register</refname>
 <refpurpose>
     register the device
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>int <function>snd_device_register </function></funcdef>
   <paramdef>struct snd_card * <parameter>card</parameter></paramdef>
   <paramdef>void * <parameter>device_data</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>card</parameter></term>
   <listitem>
    <para>
     the card instance
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>device_data</parameter></term>
   <listitem>
    <para>
     the data pointer to register
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
<title>Description</title>
<para>
   Registers the device which was already created via
   <function>snd_device_new</function>.  Usually this is called from <function>snd_card_register</function>,
   but it can be called later if any new devices are created after
   invocation of <function>snd_card_register</function>.
   </para><para>

   Returns zero if successful, or a negative error code on failure or if the
   device not found.
</para>
</refsect1>
</refentry>

<!-- sound/core/info.c -->
<refentry id="API-snd-iprintf">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>July 2015</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>snd_iprintf</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.4.104</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>snd_iprintf</refname>
 <refpurpose>
  printf on the procfs buffer
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>int <function>snd_iprintf </function></funcdef>
   <paramdef>struct snd_info_buffer * <parameter>buffer</parameter></paramdef>
   <paramdef>const char * <parameter>fmt</parameter></paramdef>
   <paramdef> <parameter>...</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>buffer</parameter></term>
   <listitem>
    <para>
     the procfs buffer
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>fmt</parameter></term>
   <listitem>
    <para>
     the printf format
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>...</parameter></term>
   <listitem>
    <para>
     variable arguments
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
<title>Description</title>
<para>
   Outputs the string on the procfs buffer just like <function>printf</function>.
   </para><para>

   Returns the size of output string.
</para>
</refsect1>
</refentry>

<refentry id="API-snd-info-get-line">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>July 2015</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>snd_info_get_line</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.4.104</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>snd_info_get_line</refname>
 <refpurpose>
     read one line from the procfs buffer
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>int <function>snd_info_get_line </function></funcdef>
   <paramdef>struct snd_info_buffer * <parameter>buffer</parameter></paramdef>
   <paramdef>char * <parameter>line</parameter></paramdef>
   <paramdef>int <parameter>len</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>buffer</parameter></term>
   <listitem>
    <para>
     the procfs buffer
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>line</parameter></term>
   <listitem>
    <para>
     the buffer to store
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>len</parameter></term>
   <listitem>
    <para>
     the max. buffer size - 1
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
<title>Description</title>
<para>
   Reads one line from the buffer and stores the string.
   </para><para>

   Returns zero if successful, or 1 if error or EOF.
</para>
</refsect1>
</refentry>

<refentry id="API-snd-info-get-str">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>July 2015</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>snd_info_get_str</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.4.104</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>snd_info_get_str</refname>
 <refpurpose>
     parse a string token
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>const char * <function>snd_info_get_str </function></funcdef>
   <paramdef>char * <parameter>dest</parameter></paramdef>
   <paramdef>const char * <parameter>src</parameter></paramdef>
   <paramdef>int <parameter>len</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>dest</parameter></term>
   <listitem>
    <para>
     the buffer to store the string token
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>src</parameter></term>
   <listitem>
    <para>
     the original string
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>len</parameter></term>
   <listitem>
    <para>
     the max. length of token - 1
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
<title>Description</title>
<para>
   Parses the original string and copy a token to the given
   string buffer.
   </para><para>

   Returns the updated pointer of the original string so that
   it can be used for the next call.
</para>
</refsect1>
</refentry>

<refentry id="API-snd-info-create-module-entry">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>July 2015</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>snd_info_create_module_entry</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.4.104</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>snd_info_create_module_entry</refname>
 <refpurpose>
     create an info entry for the given module
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>struct snd_info_entry * <function>snd_info_create_module_entry </function></funcdef>
   <paramdef>struct module * <parameter>module</parameter></paramdef>
   <paramdef>const char * <parameter>name</parameter></paramdef>
   <paramdef>struct snd_info_entry * <parameter>parent</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>module</parameter></term>
   <listitem>
    <para>
     the module pointer
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>name</parameter></term>
   <listitem>
    <para>
     the file name
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>parent</parameter></term>
   <listitem>
    <para>
     the parent directory
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
<title>Description</title>
<para>
   Creates a new info entry and assigns it to the given module.
   </para><para>

   Returns the pointer of the new instance, or NULL on failure.
</para>
</refsect1>
</refentry>

<refentry id="API-snd-info-create-card-entry">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>July 2015</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>snd_info_create_card_entry</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.4.104</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>snd_info_create_card_entry</refname>
 <refpurpose>
     create an info entry for the given card
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>struct snd_info_entry * <function>snd_info_create_card_entry </function></funcdef>
   <paramdef>struct snd_card * <parameter>card</parameter></paramdef>
   <paramdef>const char * <parameter>name</parameter></paramdef>
   <paramdef>struct snd_info_entry * <parameter>parent</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>card</parameter></term>
   <listitem>
    <para>
     the card instance
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>name</parameter></term>
   <listitem>
    <para>
     the file name
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>parent</parameter></term>
   <listitem>
    <para>
     the parent directory
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
<title>Description</title>
<para>
   Creates a new info entry and assigns it to the given card.
   </para><para>

   Returns the pointer of the new instance, or NULL on failure.
</para>
</refsect1>
</refentry>

<refentry id="API-snd-card-proc-new">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>July 2015</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>snd_card_proc_new</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.4.104</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>snd_card_proc_new</refname>
 <refpurpose>
     create an info entry for the given card
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>int <function>snd_card_proc_new </function></funcdef>
   <paramdef>struct snd_card * <parameter>card</parameter></paramdef>
   <paramdef>const char * <parameter>name</parameter></paramdef>
   <paramdef>struct snd_info_entry ** <parameter>entryp</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>card</parameter></term>
   <listitem>
    <para>
     the card instance
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>name</parameter></term>
   <listitem>
    <para>
     the file name
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>entryp</parameter></term>
   <listitem>
    <para>
     the pointer to store the new info entry
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
<title>Description</title>
<para>
   Creates a new info entry and assigns it to the given card.
   Unlike <function>snd_info_create_card_entry</function>, this function registers the
   info entry as an ALSA device component, so that it can be
   unregistered/released without explicit call.
   Also, you don't have to register this entry via <function>snd_info_register</function>,
   since this will be registered by <function>snd_card_register</function> automatically.
   </para><para>

   The parent is assumed as card-&gt;proc_root.
   </para><para>

   For releasing this entry, use <function>snd_device_free</function> instead of
   <function>snd_info_free_entry</function>. 
   </para><para>

   Returns zero if successful, or a negative error code on failure.
</para>
</refsect1>
</refentry>

<refentry id="API-snd-info-free-entry">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>July 2015</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>snd_info_free_entry</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.4.104</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>snd_info_free_entry</refname>
 <refpurpose>
     release the info entry
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>void <function>snd_info_free_entry </function></funcdef>
   <paramdef>struct snd_info_entry * <parameter>entry</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>entry</parameter></term>
   <listitem>
    <para>
     the info entry
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
<title>Description</title>
<para>
   Releases the info entry.  Don't call this after registered.
</para>
</refsect1>
</refentry>

<refentry id="API-snd-info-register">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>July 2015</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>snd_info_register</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.4.104</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>snd_info_register</refname>
 <refpurpose>
     register the info entry
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>int <function>snd_info_register </function></funcdef>
   <paramdef>struct snd_info_entry * <parameter>entry</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>entry</parameter></term>
   <listitem>
    <para>
     the info entry
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
<title>Description</title>
<para>
   Registers the proc info entry.
   </para><para>

   Returns zero if successful, or a negative error code on failure.
</para>
</refsect1>
</refentry>

<!-- sound/core/rawmidi.c -->
<refentry id="API-snd-rawmidi-receive">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>July 2015</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>snd_rawmidi_receive</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.4.104</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>snd_rawmidi_receive</refname>
 <refpurpose>
  receive the input data from the device
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>int <function>snd_rawmidi_receive </function></funcdef>
   <paramdef>struct snd_rawmidi_substream * <parameter>substream</parameter></paramdef>
   <paramdef>const unsigned char * <parameter>buffer</parameter></paramdef>
   <paramdef>int <parameter>count</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>substream</parameter></term>
   <listitem>
    <para>
     the rawmidi substream
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>buffer</parameter></term>
   <listitem>
    <para>
     the buffer pointer
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>count</parameter></term>
   <listitem>
    <para>
     the data size to read
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
<title>Description</title>
<para>
   Reads the data from the internal buffer.
   </para><para>

   Returns the size of read data, or a negative error code on failure.
</para>
</refsect1>
</refentry>

<refentry id="API-snd-rawmidi-transmit-empty">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>July 2015</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>snd_rawmidi_transmit_empty</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.4.104</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>snd_rawmidi_transmit_empty</refname>
 <refpurpose>
     check whether the output buffer is empty
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>int <function>snd_rawmidi_transmit_empty </function></funcdef>
   <paramdef>struct snd_rawmidi_substream * <parameter>substream</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>substream</parameter></term>
   <listitem>
    <para>
     the rawmidi substream
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
<title>Description</title>
<para>
   Returns 1 if the internal output buffer is empty, 0 if not.
</para>
</refsect1>
</refentry>

<refentry id="API-snd-rawmidi-transmit-peek">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>July 2015</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>snd_rawmidi_transmit_peek</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.4.104</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>snd_rawmidi_transmit_peek</refname>
 <refpurpose>
     copy data from the internal buffer
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>int <function>snd_rawmidi_transmit_peek </function></funcdef>
   <paramdef>struct snd_rawmidi_substream * <parameter>substream</parameter></paramdef>
   <paramdef>unsigned char * <parameter>buffer</parameter></paramdef>
   <paramdef>int <parameter>count</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>substream</parameter></term>
   <listitem>
    <para>
     the rawmidi substream
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>buffer</parameter></term>
   <listitem>
    <para>
     the buffer pointer
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>count</parameter></term>
   <listitem>
    <para>
     data size to transfer
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
<title>Description</title>
<para>
   Copies data from the internal output buffer to the given buffer.
   </para><para>

   Call this in the interrupt handler when the midi output is ready,
   and call <function>snd_rawmidi_transmit_ack</function> after the transmission is
   finished.
   </para><para>

   Returns the size of copied data, or a negative error code on failure.
</para>
</refsect1>
</refentry>

<refentry id="API-snd-rawmidi-transmit-ack">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>July 2015</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>snd_rawmidi_transmit_ack</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.4.104</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>snd_rawmidi_transmit_ack</refname>
 <refpurpose>
     acknowledge the transmission
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>int <function>snd_rawmidi_transmit_ack </function></funcdef>
   <paramdef>struct snd_rawmidi_substream * <parameter>substream</parameter></paramdef>
   <paramdef>int <parameter>count</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>substream</parameter></term>
   <listitem>
    <para>
     the rawmidi substream
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>count</parameter></term>
   <listitem>
    <para>
     the tranferred count
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
<title>Description</title>
<para>
   Advances the hardware pointer for the internal output buffer with
   the given size and updates the condition.
   Call after the transmission is finished.
   </para><para>

   Returns the advanced size if successful, or a negative error code on failure.
</para>
</refsect1>
</refentry>

<refentry id="API-snd-rawmidi-transmit">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>July 2015</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>snd_rawmidi_transmit</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.4.104</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>snd_rawmidi_transmit</refname>
 <refpurpose>
     copy from the buffer to the device
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>int <function>snd_rawmidi_transmit </function></funcdef>
   <paramdef>struct snd_rawmidi_substream * <parameter>substream</parameter></paramdef>
   <paramdef>unsigned char * <parameter>buffer</parameter></paramdef>
   <paramdef>int <parameter>count</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>substream</parameter></term>
   <listitem>
    <para>
     the rawmidi substream
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>buffer</parameter></term>
   <listitem>
    <para>
     the buffer pointer
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>count</parameter></term>
   <listitem>
    <para>
     the data size to transfer
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
<title>Description</title>
<para>
   Copies data from the buffer to the device and advances the pointer.
   </para><para>

   Returns the copied size if successful, or a negative error code on failure.
</para>
</refsect1>
</refentry>

<refentry id="API-snd-rawmidi-new">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>July 2015</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>snd_rawmidi_new</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.4.104</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>snd_rawmidi_new</refname>
 <refpurpose>
     create a rawmidi instance
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>int <function>snd_rawmidi_new </function></funcdef>
   <paramdef>struct snd_card * <parameter>card</parameter></paramdef>
   <paramdef>char * <parameter>id</parameter></paramdef>
   <paramdef>int <parameter>device</parameter></paramdef>
   <paramdef>int <parameter>output_count</parameter></paramdef>
   <paramdef>int <parameter>input_count</parameter></paramdef>
   <paramdef>struct snd_rawmidi ** <parameter>rrawmidi</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>card</parameter></term>
   <listitem>
    <para>
     the card instance
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>id</parameter></term>
   <listitem>
    <para>
     the id string
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>device</parameter></term>
   <listitem>
    <para>
     the device index
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>output_count</parameter></term>
   <listitem>
    <para>
     the number of output streams
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>input_count</parameter></term>
   <listitem>
    <para>
     the number of input streams
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>rrawmidi</parameter></term>
   <listitem>
    <para>
     the pointer to store the new rawmidi instance
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
<title>Description</title>
<para>
   Creates a new rawmidi instance.
   Use <function>snd_rawmidi_set_ops</function> to set the operators to the new instance.
   </para><para>

   Returns zero if successful, or a negative error code on failure.
</para>
</refsect1>
</refentry>

<refentry id="API-snd-rawmidi-set-ops">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>July 2015</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>snd_rawmidi_set_ops</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.4.104</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>snd_rawmidi_set_ops</refname>
 <refpurpose>
     set the rawmidi operators
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>void <function>snd_rawmidi_set_ops </function></funcdef>
   <paramdef>struct snd_rawmidi * <parameter>rmidi</parameter></paramdef>
   <paramdef>int <parameter>stream</parameter></paramdef>
   <paramdef>struct snd_rawmidi_ops * <parameter>ops</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>rmidi</parameter></term>
   <listitem>
    <para>
     the rawmidi instance
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>stream</parameter></term>
   <listitem>
    <para>
     the stream direction, SNDRV_RAWMIDI_STREAM_XXX
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>ops</parameter></term>
   <listitem>
    <para>
     the operator table
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
<title>Description</title>
<para>
   Sets the rawmidi operators for the given stream direction.
</para>
</refsect1>
</refentry>

<!-- sound/core/sound.c -->
<refentry id="API-snd-request-card">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>July 2015</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>snd_request_card</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.4.104</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>snd_request_card</refname>
 <refpurpose>
  try to load the card module
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>void <function>snd_request_card </function></funcdef>
   <paramdef>int <parameter>card</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>card</parameter></term>
   <listitem>
    <para>
     the card number
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
<title>Description</title>
<para>
   Tries to load the module <quote>snd-card-X</quote> for the given card number
   via request_module.  Returns immediately if already loaded.
</para>
</refsect1>
</refentry>

<refentry id="API-snd-lookup-minor-data">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>July 2015</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>snd_lookup_minor_data</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.4.104</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>snd_lookup_minor_data</refname>
 <refpurpose>
     get user data of a registered device
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>void * <function>snd_lookup_minor_data </function></funcdef>
   <paramdef>unsigned int <parameter>minor</parameter></paramdef>
   <paramdef>int <parameter>type</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>minor</parameter></term>
   <listitem>
    <para>
     the minor number
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>type</parameter></term>
   <listitem>
    <para>
     device type (SNDRV_DEVICE_TYPE_XXX)
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
<title>Description</title>
<para>
   Checks that a minor device with the specified type is registered, and returns
   its user data pointer.
   </para><para>

   This function increments the reference counter of the card instance
   if an associated instance with the given minor number and type is found.
   The caller must call <function>snd_card_unref</function> appropriately later.
</para>
</refsect1>
</refentry>

<refentry id="API-snd-register-device-for-dev">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>July 2015</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>snd_register_device_for_dev</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.4.104</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>snd_register_device_for_dev</refname>
 <refpurpose>
     Register the ALSA device file for the card
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>int <function>snd_register_device_for_dev </function></funcdef>
   <paramdef>int <parameter>type</parameter></paramdef>
   <paramdef>struct snd_card * <parameter>card</parameter></paramdef>
   <paramdef>int <parameter>dev</parameter></paramdef>
   <paramdef>const struct file_operations * <parameter>f_ops</parameter></paramdef>
   <paramdef>void * <parameter>private_data</parameter></paramdef>
   <paramdef>const char * <parameter>name</parameter></paramdef>
   <paramdef>struct device * <parameter>device</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>type</parameter></term>
   <listitem>
    <para>
     the device type, SNDRV_DEVICE_TYPE_XXX
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>card</parameter></term>
   <listitem>
    <para>
     the card instance
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>dev</parameter></term>
   <listitem>
    <para>
     the device index
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>f_ops</parameter></term>
   <listitem>
    <para>
     the file operations
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>private_data</parameter></term>
   <listitem>
    <para>
     user pointer for f_ops-&gt;<function>open</function>
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>name</parameter></term>
   <listitem>
    <para>
     the device file name
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>device</parameter></term>
   <listitem>
    <para>
     the <structname>struct device</structname> to link this new device to
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
<title>Description</title>
<para>
   Registers an ALSA device file for the given card.
   The operators have to be set in reg parameter.
   </para><para>

   Returns zero if successful, or a negative error code on failure.
</para>
</refsect1>
</refentry>

<refentry id="API-snd-unregister-device">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>July 2015</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>snd_unregister_device</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.4.104</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>snd_unregister_device</refname>
 <refpurpose>
     unregister the device on the given card
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>int <function>snd_unregister_device </function></funcdef>
   <paramdef>int <parameter>type</parameter></paramdef>
   <paramdef>struct snd_card * <parameter>card</parameter></paramdef>
   <paramdef>int <parameter>dev</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>type</parameter></term>
   <listitem>
    <para>
     the device type, SNDRV_DEVICE_TYPE_XXX
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>card</parameter></term>
   <listitem>
    <para>
     the card instance
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>dev</parameter></term>
   <listitem>
    <para>
     the device index
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
<title>Description</title>
<para>
   Unregisters the device file already registered via
   <function>snd_register_device</function>.
   </para><para>

   Returns zero if sucecessful, or a negative error code on failure
</para>
</refsect1>
</refentry>

<!-- sound/core/memory.c -->
<refentry id="API-copy-to-user-fromio">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>July 2015</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>copy_to_user_fromio</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.4.104</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>copy_to_user_fromio</refname>
 <refpurpose>
  copy data from mmio-space to user-space
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>int <function>copy_to_user_fromio </function></funcdef>
   <paramdef>void __user * <parameter>dst</parameter></paramdef>
   <paramdef>const volatile void __iomem * <parameter>src</parameter></paramdef>
   <paramdef>size_t <parameter>count</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>dst</parameter></term>
   <listitem>
    <para>
     the destination pointer on user-space
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>src</parameter></term>
   <listitem>
    <para>
     the source pointer on mmio
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>count</parameter></term>
   <listitem>
    <para>
     the data size to copy in bytes
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
<title>Description</title>
<para>
   Copies the data from mmio-space to user-space.
   </para><para>

   Returns zero if successful, or non-zero on failure.
</para>
</refsect1>
</refentry>

<refentry id="API-copy-from-user-toio">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>July 2015</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>copy_from_user_toio</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.4.104</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>copy_from_user_toio</refname>
 <refpurpose>
     copy data from user-space to mmio-space
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>int <function>copy_from_user_toio </function></funcdef>
   <paramdef>volatile void __iomem * <parameter>dst</parameter></paramdef>
   <paramdef>const void __user * <parameter>src</parameter></paramdef>
   <paramdef>size_t <parameter>count</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>dst</parameter></term>
   <listitem>
    <para>
     the destination pointer on mmio-space
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>src</parameter></term>
   <listitem>
    <para>
     the source pointer on user-space
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>count</parameter></term>
   <listitem>
    <para>
     the data size to copy in bytes
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
<title>Description</title>
<para>
   Copies the data from user-space to mmio-space.
   </para><para>

   Returns zero if successful, or non-zero on failure.
</para>
</refsect1>
</refentry>

<!-- sound/core/pcm_memory.c -->
<refentry id="API-snd-pcm-lib-preallocate-free-for-all">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>July 2015</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>snd_pcm_lib_preallocate_free_for_all</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.4.104</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>snd_pcm_lib_preallocate_free_for_all</refname>
 <refpurpose>
  release all pre-allocated buffers on the pcm
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>int <function>snd_pcm_lib_preallocate_free_for_all </function></funcdef>
   <paramdef>struct snd_pcm * <parameter>pcm</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>pcm</parameter></term>
   <listitem>
    <para>
     the pcm instance
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
<title>Description</title>
<para>
   Releases all the pre-allocated buffers on the given pcm.
   </para><para>

   Returns zero if successful, or a negative error code on failure.
</para>
</refsect1>
</refentry>

<refentry id="API-snd-pcm-lib-preallocate-pages">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>July 2015</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>snd_pcm_lib_preallocate_pages</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.4.104</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>snd_pcm_lib_preallocate_pages</refname>
 <refpurpose>
     pre-allocation for the given DMA type
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>int <function>snd_pcm_lib_preallocate_pages </function></funcdef>
   <paramdef>struct snd_pcm_substream * <parameter>substream</parameter></paramdef>
   <paramdef>int <parameter>type</parameter></paramdef>
   <paramdef>struct device * <parameter>data</parameter></paramdef>
   <paramdef>size_t <parameter>size</parameter></paramdef>
   <paramdef>size_t <parameter>max</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>substream</parameter></term>
   <listitem>
    <para>
     the pcm substream instance
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>type</parameter></term>
   <listitem>
    <para>
     DMA type (SNDRV_DMA_TYPE_*)
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>data</parameter></term>
   <listitem>
    <para>
     DMA type dependent data
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>size</parameter></term>
   <listitem>
    <para>
     the requested pre-allocation size in bytes
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>max</parameter></term>
   <listitem>
    <para>
     the max. allowed pre-allocation size
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
<title>Description</title>
<para>
   Do pre-allocation for the given DMA buffer type.
   </para><para>

   When substream-&gt;dma_buf_id is set, the function tries to look for
   the reserved buffer, and the buffer is not freed but reserved at
   destruction time.  The dma_buf_id must be unique for all systems
   (in the same DMA buffer type) e.g. using <function>snd_dma_pci_buf_id</function>.
   </para><para>

   Returns zero if successful, or a negative error code on failure.
</para>
</refsect1>
</refentry>

<refentry id="API-snd-pcm-lib-preallocate-pages-for-all">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>July 2015</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>snd_pcm_lib_preallocate_pages_for_all</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.4.104</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>snd_pcm_lib_preallocate_pages_for_all</refname>
 <refpurpose>
     pre-allocation for continuous memory type (all substreams)
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>int <function>snd_pcm_lib_preallocate_pages_for_all </function></funcdef>
   <paramdef>struct snd_pcm * <parameter>pcm</parameter></paramdef>
   <paramdef>int <parameter>type</parameter></paramdef>
   <paramdef>void * <parameter>data</parameter></paramdef>
   <paramdef>size_t <parameter>size</parameter></paramdef>
   <paramdef>size_t <parameter>max</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>pcm</parameter></term>
   <listitem>
    <para>
     the pcm instance
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>type</parameter></term>
   <listitem>
    <para>
     DMA type (SNDRV_DMA_TYPE_*)
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>data</parameter></term>
   <listitem>
    <para>
     DMA type dependent data
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>size</parameter></term>
   <listitem>
    <para>
     the requested pre-allocation size in bytes
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>max</parameter></term>
   <listitem>
    <para>
     the max. allowed pre-allocation size
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
<title>Description</title>
<para>
   Do pre-allocation to all substreams of the given pcm for the
   specified DMA type.
   </para><para>

   Returns zero if successful, or a negative error code on failure.
</para>
</refsect1>
</refentry>

<refentry id="API-snd-pcm-sgbuf-ops-page">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>July 2015</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>snd_pcm_sgbuf_ops_page</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.4.104</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>snd_pcm_sgbuf_ops_page</refname>
 <refpurpose>
     get the page struct at the given offset
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>struct page * <function>snd_pcm_sgbuf_ops_page </function></funcdef>
   <paramdef>struct snd_pcm_substream * <parameter>substream</parameter></paramdef>
   <paramdef>unsigned long <parameter>offset</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>substream</parameter></term>
   <listitem>
    <para>
     the pcm substream instance
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>offset</parameter></term>
   <listitem>
    <para>
     the buffer offset
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
<title>Description</title>
<para>
   Returns the page struct at the given buffer offset.
   Used as the page callback of PCM ops.
</para>
</refsect1>
</refentry>

<refentry id="API-snd-pcm-lib-malloc-pages">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>July 2015</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>snd_pcm_lib_malloc_pages</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.4.104</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>snd_pcm_lib_malloc_pages</refname>
 <refpurpose>
     allocate the DMA buffer
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>int <function>snd_pcm_lib_malloc_pages </function></funcdef>
   <paramdef>struct snd_pcm_substream * <parameter>substream</parameter></paramdef>
   <paramdef>size_t <parameter>size</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>substream</parameter></term>
   <listitem>
    <para>
     the substream to allocate the DMA buffer to
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>size</parameter></term>
   <listitem>
    <para>
     the requested buffer size in bytes
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
<title>Description</title>
<para>
   Allocates the DMA buffer on the BUS type given earlier to
   <function>snd_pcm_lib_preallocate_xxx_pages</function>.
   </para><para>

   Returns 1 if the buffer is changed, 0 if not changed, or a negative
   code on failure.
</para>
</refsect1>
</refentry>

<refentry id="API-snd-pcm-lib-free-pages">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>July 2015</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>snd_pcm_lib_free_pages</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.4.104</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>snd_pcm_lib_free_pages</refname>
 <refpurpose>
     release the allocated DMA buffer.
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>int <function>snd_pcm_lib_free_pages </function></funcdef>
   <paramdef>struct snd_pcm_substream * <parameter>substream</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>substream</parameter></term>
   <listitem>
    <para>
     the substream to release the DMA buffer
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
<title>Description</title>
<para>
   Releases the DMA buffer allocated via <function>snd_pcm_lib_malloc_pages</function>.
   </para><para>

   Returns zero if successful, or a negative error code on failure.
</para>
</refsect1>
</refentry>

<refentry id="API-snd-pcm-lib-free-vmalloc-buffer">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>July 2015</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>snd_pcm_lib_free_vmalloc_buffer</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.4.104</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>snd_pcm_lib_free_vmalloc_buffer</refname>
 <refpurpose>
     free vmalloc buffer
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>int <function>snd_pcm_lib_free_vmalloc_buffer </function></funcdef>
   <paramdef>struct snd_pcm_substream * <parameter>substream</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>substream</parameter></term>
   <listitem>
    <para>
     the substream with a buffer allocated by
     <function>snd_pcm_lib_alloc_vmalloc_buffer</function>
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
</refentry>

<refentry id="API-snd-pcm-lib-get-vmalloc-page">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>July 2015</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>snd_pcm_lib_get_vmalloc_page</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.4.104</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>snd_pcm_lib_get_vmalloc_page</refname>
 <refpurpose>
     map vmalloc buffer offset to page struct
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>struct page * <function>snd_pcm_lib_get_vmalloc_page </function></funcdef>
   <paramdef>struct snd_pcm_substream * <parameter>substream</parameter></paramdef>
   <paramdef>unsigned long <parameter>offset</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>substream</parameter></term>
   <listitem>
    <para>
     the substream with a buffer allocated by
     <function>snd_pcm_lib_alloc_vmalloc_buffer</function>
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>offset</parameter></term>
   <listitem>
    <para>
     offset in the buffer
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
<title>Description</title>
<para>
   This function is to be used as the page callback in the PCM ops.
</para>
</refsect1>
</refentry>

<!-- sound/core/init.c -->
<refentry id="API-snd-card-create">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>July 2015</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>snd_card_create</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.4.104</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>snd_card_create</refname>
 <refpurpose>
  create and initialize a soundcard structure
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>int <function>snd_card_create </function></funcdef>
   <paramdef>int <parameter>idx</parameter></paramdef>
   <paramdef>const char * <parameter>xid</parameter></paramdef>
   <paramdef>struct module * <parameter>module</parameter></paramdef>
   <paramdef>int <parameter>extra_size</parameter></paramdef>
   <paramdef>struct snd_card ** <parameter>card_ret</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>idx</parameter></term>
   <listitem>
    <para>
     card index (address) [0 ... (SNDRV_CARDS-1)]
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>xid</parameter></term>
   <listitem>
    <para>
     card identification (ASCII string)
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>module</parameter></term>
   <listitem>
    <para>
     top level module for locking
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>extra_size</parameter></term>
   <listitem>
    <para>
     allocate this extra size after the main soundcard structure
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>card_ret</parameter></term>
   <listitem>
    <para>
     the pointer to store the created card instance
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
<title>Description</title>
<para>
   Creates and initializes a soundcard structure.
   </para><para>

   The function allocates snd_card instance via kzalloc with the given
   space for the driver to use freely.  The allocated struct is stored
   in the given card_ret pointer.
   </para><para>

   Returns zero if successful or a negative error code.
</para>
</refsect1>
</refentry>

<refentry id="API-snd-card-disconnect">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>July 2015</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>snd_card_disconnect</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.4.104</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>snd_card_disconnect</refname>
 <refpurpose>
     disconnect all APIs from the file-operations (user space)
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>int <function>snd_card_disconnect </function></funcdef>
   <paramdef>struct snd_card * <parameter>card</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>card</parameter></term>
   <listitem>
    <para>
     soundcard structure
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
<title>Description</title>
<para>
   Disconnects all APIs from the file-operations (user space).
   </para><para>

   Returns zero, otherwise a negative error code.
</para>
</refsect1>
<refsect1>
<title>Note</title>
<para>
   The current implementation replaces all active file-&gt;f_op with special
   dummy file operations (they do nothing except release).
</para>
</refsect1>
</refentry>

<refentry id="API-snd-card-unref">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>July 2015</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>snd_card_unref</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.4.104</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>snd_card_unref</refname>
 <refpurpose>
     release the reference counter
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>void <function>snd_card_unref </function></funcdef>
   <paramdef>struct snd_card * <parameter>card</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>card</parameter></term>
   <listitem>
    <para>
     the card instance
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
<title>Description</title>
<para>
   Decrements the reference counter.  When it reaches to zero, wake up
   the sleeper and call the destructor if needed.
</para>
</refsect1>
</refentry>

<refentry id="API-snd-card-set-id">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>July 2015</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>snd_card_set_id</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.4.104</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>snd_card_set_id</refname>
 <refpurpose>
     set card identification name
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>void <function>snd_card_set_id </function></funcdef>
   <paramdef>struct snd_card * <parameter>card</parameter></paramdef>
   <paramdef>const char * <parameter>nid</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>card</parameter></term>
   <listitem>
    <para>
     soundcard structure
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>nid</parameter></term>
   <listitem>
    <para>
     new identification string
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
<title>Description</title>
<para>
   This function sets the card identification and checks for name
   collisions.
</para>
</refsect1>
</refentry>

<refentry id="API-snd-card-register">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>July 2015</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>snd_card_register</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.4.104</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>snd_card_register</refname>
 <refpurpose>
     register the soundcard
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>int <function>snd_card_register </function></funcdef>
   <paramdef>struct snd_card * <parameter>card</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>card</parameter></term>
   <listitem>
    <para>
     soundcard structure
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
<title>Description</title>
<para>
   This function registers all the devices assigned to the soundcard.
   Until calling this, the ALSA control interface is blocked from the
   external accesses.  Thus, you should call this function at the end
   of the initialization of the card.
   </para><para>

   Returns zero otherwise a negative error code if the registration failed.
</para>
</refsect1>
</refentry>

<refentry id="API-snd-component-add">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>July 2015</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>snd_component_add</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.4.104</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>snd_component_add</refname>
 <refpurpose>
     add a component string
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>int <function>snd_component_add </function></funcdef>
   <paramdef>struct snd_card * <parameter>card</parameter></paramdef>
   <paramdef>const char * <parameter>component</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>card</parameter></term>
   <listitem>
    <para>
     soundcard structure
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>component</parameter></term>
   <listitem>
    <para>
     the component id string
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
<title>Description</title>
<para>
   This function adds the component id string to the supported list.
   The component can be referred from the alsa-lib.
   </para><para>

   Returns zero otherwise a negative error code.
</para>
</refsect1>
</refentry>

<refentry id="API-snd-card-file-add">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>July 2015</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>snd_card_file_add</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.4.104</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>snd_card_file_add</refname>
 <refpurpose>
     add the file to the file list of the card
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>int <function>snd_card_file_add </function></funcdef>
   <paramdef>struct snd_card * <parameter>card</parameter></paramdef>
   <paramdef>struct file * <parameter>file</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>card</parameter></term>
   <listitem>
    <para>
     soundcard structure
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>file</parameter></term>
   <listitem>
    <para>
     file pointer
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
<title>Description</title>
<para>
   This function adds the file to the file linked-list of the card.
   This linked-list is used to keep tracking the connection state,
   and to avoid the release of busy resources by hotplug.
   </para><para>

   Returns zero or a negative error code.
</para>
</refsect1>
</refentry>

<refentry id="API-snd-card-file-remove">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>July 2015</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>snd_card_file_remove</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.4.104</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>snd_card_file_remove</refname>
 <refpurpose>
     remove the file from the file list
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>int <function>snd_card_file_remove </function></funcdef>
   <paramdef>struct snd_card * <parameter>card</parameter></paramdef>
   <paramdef>struct file * <parameter>file</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>card</parameter></term>
   <listitem>
    <para>
     soundcard structure
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>file</parameter></term>
   <listitem>
    <para>
     file pointer
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
<title>Description</title>
<para>
   This function removes the file formerly added to the card via
   <function>snd_card_file_add</function> function.
   If all files are removed and <function>snd_card_free_when_closed</function> was
   called beforehand, it processes the pending release of
   resources.
   </para><para>

   Returns zero or a negative error code.
</para>
</refsect1>
</refentry>

<refentry id="API-snd-power-wait">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>July 2015</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>snd_power_wait</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.4.104</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>snd_power_wait</refname>
 <refpurpose>
     wait until the power-state is changed.
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>int <function>snd_power_wait </function></funcdef>
   <paramdef>struct snd_card * <parameter>card</parameter></paramdef>
   <paramdef>unsigned int <parameter>power_state</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>card</parameter></term>
   <listitem>
    <para>
     soundcard structure
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>power_state</parameter></term>
   <listitem>
    <para>
     expected power state
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
<title>Description</title>
<para>
   Waits until the power-state is changed.
</para>
</refsect1>
<refsect1>
<title>Note</title>
<para>
   the power lock must be active before call.
</para>
</refsect1>
</refentry>

<!-- sound/core/isadma.c -->
<refentry id="API-snd-dma-program">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>July 2015</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>snd_dma_program</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.4.104</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>snd_dma_program</refname>
 <refpurpose>
  program an ISA DMA transfer
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>void <function>snd_dma_program </function></funcdef>
   <paramdef>unsigned long <parameter>dma</parameter></paramdef>
   <paramdef>unsigned long <parameter>addr</parameter></paramdef>
   <paramdef>unsigned int <parameter>size</parameter></paramdef>
   <paramdef>unsigned short <parameter>mode</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>dma</parameter></term>
   <listitem>
    <para>
     the dma number
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>addr</parameter></term>
   <listitem>
    <para>
     the physical address of the buffer
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>size</parameter></term>
   <listitem>
    <para>
     the DMA transfer size
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>mode</parameter></term>
   <listitem>
    <para>
     the DMA transfer mode, DMA_MODE_XXX
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
<title>Description</title>
<para>
   Programs an ISA DMA transfer for the given buffer.
</para>
</refsect1>
</refentry>

<refentry id="API-snd-dma-disable">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>July 2015</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>snd_dma_disable</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.4.104</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>snd_dma_disable</refname>
 <refpurpose>
     stop the ISA DMA transfer
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>void <function>snd_dma_disable </function></funcdef>
   <paramdef>unsigned long <parameter>dma</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>dma</parameter></term>
   <listitem>
    <para>
     the dma number
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
<title>Description</title>
<para>
   Stops the ISA DMA transfer.
</para>
</refsect1>
</refentry>

<refentry id="API-snd-dma-pointer">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>July 2015</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>snd_dma_pointer</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.4.104</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>snd_dma_pointer</refname>
 <refpurpose>
     return the current pointer to DMA transfer buffer in bytes
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>unsigned int <function>snd_dma_pointer </function></funcdef>
   <paramdef>unsigned long <parameter>dma</parameter></paramdef>
   <paramdef>unsigned int <parameter>size</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>dma</parameter></term>
   <listitem>
    <para>
     the dma number
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>size</parameter></term>
   <listitem>
    <para>
     the dma transfer size
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
<title>Description</title>
<para>
   Returns the current pointer in DMA tranfer buffer in bytes
</para>
</refsect1>
</refentry>

<!-- sound/core/control.c -->
<refentry id="API-snd-ctl-new1">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>July 2015</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>snd_ctl_new1</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.4.104</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>snd_ctl_new1</refname>
 <refpurpose>
  create a control instance from the template
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>struct snd_kcontrol * <function>snd_ctl_new1 </function></funcdef>
   <paramdef>const struct snd_kcontrol_new * <parameter>ncontrol</parameter></paramdef>
   <paramdef>void * <parameter>private_data</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>ncontrol</parameter></term>
   <listitem>
    <para>
     the initialization record
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>private_data</parameter></term>
   <listitem>
    <para>
     the private data to set
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
<title>Description</title>
<para>
   Allocates a new struct snd_kcontrol instance and initialize from the given 
   template.  When the access field of ncontrol is 0, it's assumed as
   READWRITE access. When the count field is 0, it's assumes as one.
   </para><para>

   Returns the pointer of the newly generated instance, or NULL on failure.
</para>
</refsect1>
</refentry>

<refentry id="API-snd-ctl-free-one">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>July 2015</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>snd_ctl_free_one</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.4.104</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>snd_ctl_free_one</refname>
 <refpurpose>
     release the control instance
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>void <function>snd_ctl_free_one </function></funcdef>
   <paramdef>struct snd_kcontrol * <parameter>kcontrol</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>kcontrol</parameter></term>
   <listitem>
    <para>
     the control instance
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
<title>Description</title>
<para>
   Releases the control instance created via <function>snd_ctl_new</function>
   or <function>snd_ctl_new1</function>.
   Don't call this after the control was added to the card.
</para>
</refsect1>
</refentry>

<refentry id="API-snd-ctl-add">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>July 2015</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>snd_ctl_add</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.4.104</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>snd_ctl_add</refname>
 <refpurpose>
     add the control instance to the card
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>int <function>snd_ctl_add </function></funcdef>
   <paramdef>struct snd_card * <parameter>card</parameter></paramdef>
   <paramdef>struct snd_kcontrol * <parameter>kcontrol</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>card</parameter></term>
   <listitem>
    <para>
     the card instance
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>kcontrol</parameter></term>
   <listitem>
    <para>
     the control instance to add
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
<title>Description</title>
<para>
   Adds the control instance created via <function>snd_ctl_new</function> or
   <function>snd_ctl_new1</function> to the given card. Assigns also an unique
   numid used for fast search.
   </para><para>

   Returns zero if successful, or a negative error code on failure.
   </para><para>

   It frees automatically the control which cannot be added.
</para>
</refsect1>
</refentry>

<refentry id="API-snd-ctl-replace">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>July 2015</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>snd_ctl_replace</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.4.104</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>snd_ctl_replace</refname>
 <refpurpose>
     replace the control instance of the card
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>int <function>snd_ctl_replace </function></funcdef>
   <paramdef>struct snd_card * <parameter>card</parameter></paramdef>
   <paramdef>struct snd_kcontrol * <parameter>kcontrol</parameter></paramdef>
   <paramdef>bool <parameter>add_on_replace</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>card</parameter></term>
   <listitem>
    <para>
     the card instance
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>kcontrol</parameter></term>
   <listitem>
    <para>
     the control instance to replace
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>add_on_replace</parameter></term>
   <listitem>
    <para>
     add the control if not already added
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
<title>Description</title>
<para>
   Replaces the given control.  If the given control does not exist
   and the add_on_replace flag is set, the control is added.  If the
   control exists, it is destroyed first.
   </para><para>

   Returns zero if successful, or a negative error code on failure.
   </para><para>

   It frees automatically the control which cannot be added or replaced.
</para>
</refsect1>
</refentry>

<refentry id="API-snd-ctl-remove">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>July 2015</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>snd_ctl_remove</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.4.104</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>snd_ctl_remove</refname>
 <refpurpose>
     remove the control from the card and release it
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>int <function>snd_ctl_remove </function></funcdef>
   <paramdef>struct snd_card * <parameter>card</parameter></paramdef>
   <paramdef>struct snd_kcontrol * <parameter>kcontrol</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>card</parameter></term>
   <listitem>
    <para>
     the card instance
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>kcontrol</parameter></term>
   <listitem>
    <para>
     the control instance to remove
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
<title>Description</title>
<para>
   Removes the control from the card and then releases the instance.
   You don't need to call <function>snd_ctl_free_one</function>. You must be in
   the write lock - down_write(<structname>card</structname>-&gt;controls_rwsem).
   </para><para>

   Returns 0 if successful, or a negative error code on failure.
</para>
</refsect1>
</refentry>

<refentry id="API-snd-ctl-remove-id">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>July 2015</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>snd_ctl_remove_id</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.4.104</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>snd_ctl_remove_id</refname>
 <refpurpose>
     remove the control of the given id and release it
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>int <function>snd_ctl_remove_id </function></funcdef>
   <paramdef>struct snd_card * <parameter>card</parameter></paramdef>
   <paramdef>struct snd_ctl_elem_id * <parameter>id</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>card</parameter></term>
   <listitem>
    <para>
     the card instance
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>id</parameter></term>
   <listitem>
    <para>
     the control id to remove
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
<title>Description</title>
<para>
   Finds the control instance with the given id, removes it from the
   card list and releases it.
   </para><para>

   Returns 0 if successful, or a negative error code on failure.
</para>
</refsect1>
</refentry>

<refentry id="API-snd-ctl-activate-id">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>July 2015</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>snd_ctl_activate_id</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.4.104</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>snd_ctl_activate_id</refname>
 <refpurpose>
     activate/inactivate the control of the given id
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>int <function>snd_ctl_activate_id </function></funcdef>
   <paramdef>struct snd_card * <parameter>card</parameter></paramdef>
   <paramdef>struct snd_ctl_elem_id * <parameter>id</parameter></paramdef>
   <paramdef>int <parameter>active</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>card</parameter></term>
   <listitem>
    <para>
     the card instance
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>id</parameter></term>
   <listitem>
    <para>
     the control id to activate/inactivate
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>active</parameter></term>
   <listitem>
    <para>
     non-zero to activate
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
<title>Description</title>
<para>
   Finds the control instance with the given id, and activate or
   inactivate the control together with notification, if changed.
   </para><para>

   Returns 0 if unchanged, 1 if changed, or a negative error code on failure.
</para>
</refsect1>
</refentry>

<refentry id="API-snd-ctl-rename-id">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>July 2015</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>snd_ctl_rename_id</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.4.104</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>snd_ctl_rename_id</refname>
 <refpurpose>
     replace the id of a control on the card
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>int <function>snd_ctl_rename_id </function></funcdef>
   <paramdef>struct snd_card * <parameter>card</parameter></paramdef>
   <paramdef>struct snd_ctl_elem_id * <parameter>src_id</parameter></paramdef>
   <paramdef>struct snd_ctl_elem_id * <parameter>dst_id</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>card</parameter></term>
   <listitem>
    <para>
     the card instance
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>src_id</parameter></term>
   <listitem>
    <para>
     the old id
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>dst_id</parameter></term>
   <listitem>
    <para>
     the new id
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
<title>Description</title>
<para>
   Finds the control with the old id from the card, and replaces the
   id with the new one.
   </para><para>

   Returns zero if successful, or a negative error code on failure.
</para>
</refsect1>
</refentry>

<refentry id="API-snd-ctl-find-numid">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>July 2015</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>snd_ctl_find_numid</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.4.104</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>snd_ctl_find_numid</refname>
 <refpurpose>
     find the control instance with the given number-id
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>struct snd_kcontrol * <function>snd_ctl_find_numid </function></funcdef>
   <paramdef>struct snd_card * <parameter>card</parameter></paramdef>
   <paramdef>unsigned int <parameter>numid</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>card</parameter></term>
   <listitem>
    <para>
     the card instance
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>numid</parameter></term>
   <listitem>
    <para>
     the number-id to search
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
<title>Description</title>
<para>
   Finds the control instance with the given number-id from the card.
   </para><para>

   Returns the pointer of the instance if found, or NULL if not.
   </para><para>

   The caller must down card-&gt;controls_rwsem before calling this function
   (if the race condition can happen).
</para>
</refsect1>
</refentry>

<refentry id="API-snd-ctl-find-id">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>July 2015</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>snd_ctl_find_id</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.4.104</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>snd_ctl_find_id</refname>
 <refpurpose>
     find the control instance with the given id
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>struct snd_kcontrol * <function>snd_ctl_find_id </function></funcdef>
   <paramdef>struct snd_card * <parameter>card</parameter></paramdef>
   <paramdef>struct snd_ctl_elem_id * <parameter>id</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>card</parameter></term>
   <listitem>
    <para>
     the card instance
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>id</parameter></term>
   <listitem>
    <para>
     the id to search
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
<title>Description</title>
<para>
   Finds the control instance with the given id from the card.
   </para><para>

   Returns the pointer of the instance if found, or NULL if not.
   </para><para>

   The caller must down card-&gt;controls_rwsem before calling this function
   (if the race condition can happen).
</para>
</refsect1>
</refentry>

<refentry id="API-snd-ctl-enum-info">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>July 2015</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>snd_ctl_enum_info</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.4.104</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>snd_ctl_enum_info</refname>
 <refpurpose>
     fills the info structure for an enumerated control
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>int <function>snd_ctl_enum_info </function></funcdef>
   <paramdef>struct snd_ctl_elem_info * <parameter>info</parameter></paramdef>
   <paramdef>unsigned int <parameter>channels</parameter></paramdef>
   <paramdef>unsigned int <parameter>items</parameter></paramdef>
   <paramdef>const char *const <parameter>names[]</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>info</parameter></term>
   <listitem>
    <para>
     the structure to be filled
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>channels</parameter></term>
   <listitem>
    <para>
     the number of the control's channels; often one
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>items</parameter></term>
   <listitem>
    <para>
     the number of control values; also the size of <parameter>names</parameter>
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>names[]</parameter></term>
   <listitem>
    <para>
     an array containing the names of all control values
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
<title>Description</title>
<para>
   Sets all required fields in <parameter>info</parameter> to their appropriate values.
   If the control's accessibility is not the default (readable and writable),
   the caller has to fill <parameter>info</parameter>-&gt;access.
</para>
</refsect1>
</refentry>

<!-- sound/core/pcm_lib.c -->
<refentry id="API-snd-pcm-set-ops">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>July 2015</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>snd_pcm_set_ops</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.4.104</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>snd_pcm_set_ops</refname>
 <refpurpose>
  set the PCM operators
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>void <function>snd_pcm_set_ops </function></funcdef>
   <paramdef>struct snd_pcm * <parameter>pcm</parameter></paramdef>
   <paramdef>int <parameter>direction</parameter></paramdef>
   <paramdef>struct snd_pcm_ops * <parameter>ops</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>pcm</parameter></term>
   <listitem>
    <para>
     the pcm instance
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>direction</parameter></term>
   <listitem>
    <para>
     stream direction, SNDRV_PCM_STREAM_XXX
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>ops</parameter></term>
   <listitem>
    <para>
     the operator table
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
<title>Description</title>
<para>
   Sets the given PCM operators to the pcm instance.
</para>
</refsect1>
</refentry>

<refentry id="API-snd-pcm-set-sync">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>July 2015</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>snd_pcm_set_sync</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.4.104</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>snd_pcm_set_sync</refname>
 <refpurpose>
     set the PCM sync id
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>void <function>snd_pcm_set_sync </function></funcdef>
   <paramdef>struct snd_pcm_substream * <parameter>substream</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>substream</parameter></term>
   <listitem>
    <para>
     the pcm substream
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
<title>Description</title>
<para>
   Sets the PCM sync identifier for the card.
</para>
</refsect1>
</refentry>

<refentry id="API-snd-interval-refine">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>July 2015</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>snd_interval_refine</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.4.104</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>snd_interval_refine</refname>
 <refpurpose>
     refine the interval value of configurator
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>int <function>snd_interval_refine </function></funcdef>
   <paramdef>struct snd_interval * <parameter>i</parameter></paramdef>
   <paramdef>const struct snd_interval * <parameter>v</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>i</parameter></term>
   <listitem>
    <para>
     the interval value to refine
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>v</parameter></term>
   <listitem>
    <para>
     the interval value to refer to
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
<title>Description</title>
<para>
   Refines the interval value with the reference value.
   The interval is changed to the range satisfying both intervals.
   The interval status (min, max, integer, etc.) are evaluated.
   </para><para>

   Returns non-zero if the value is changed, zero if not changed.
</para>
</refsect1>
</refentry>

<refentry id="API-snd-interval-ratnum">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>July 2015</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>snd_interval_ratnum</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.4.104</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>snd_interval_ratnum</refname>
 <refpurpose>
     refine the interval value
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>int <function>snd_interval_ratnum </function></funcdef>
   <paramdef>struct snd_interval * <parameter>i</parameter></paramdef>
   <paramdef>unsigned int <parameter>rats_count</parameter></paramdef>
   <paramdef>struct snd_ratnum * <parameter>rats</parameter></paramdef>
   <paramdef>unsigned int * <parameter>nump</parameter></paramdef>
   <paramdef>unsigned int * <parameter>denp</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>i</parameter></term>
   <listitem>
    <para>
     interval to refine
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>rats_count</parameter></term>
   <listitem>
    <para>
     number of ratnum_t
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>rats</parameter></term>
   <listitem>
    <para>
     ratnum_t array
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>nump</parameter></term>
   <listitem>
    <para>
     pointer to store the resultant numerator
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>denp</parameter></term>
   <listitem>
    <para>
     pointer to store the resultant denominator
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
<title>Description</title>
<para>
   Returns non-zero if the value is changed, zero if not changed.
</para>
</refsect1>
</refentry>

<refentry id="API-snd-interval-list">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>July 2015</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>snd_interval_list</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.4.104</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>snd_interval_list</refname>
 <refpurpose>
     refine the interval value from the list
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>int <function>snd_interval_list </function></funcdef>
   <paramdef>struct snd_interval * <parameter>i</parameter></paramdef>
   <paramdef>unsigned int <parameter>count</parameter></paramdef>
   <paramdef>const unsigned int * <parameter>list</parameter></paramdef>
   <paramdef>unsigned int <parameter>mask</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>i</parameter></term>
   <listitem>
    <para>
     the interval value to refine
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>count</parameter></term>
   <listitem>
    <para>
     the number of elements in the list
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>list</parameter></term>
   <listitem>
    <para>
     the value list
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>mask</parameter></term>
   <listitem>
    <para>
     the bit-mask to evaluate
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
<title>Description</title>
<para>
   Refines the interval value from the list.
   When mask is non-zero, only the elements corresponding to bit 1 are
   evaluated.
   </para><para>

   Returns non-zero if the value is changed, zero if not changed.
</para>
</refsect1>
</refentry>

<refentry id="API-snd-pcm-hw-rule-add">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>July 2015</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>snd_pcm_hw_rule_add</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.4.104</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>snd_pcm_hw_rule_add</refname>
 <refpurpose>
     add the hw-constraint rule
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>int <function>snd_pcm_hw_rule_add </function></funcdef>
   <paramdef>struct snd_pcm_runtime * <parameter>runtime</parameter></paramdef>
   <paramdef>unsigned int <parameter>cond</parameter></paramdef>
   <paramdef>int <parameter>var</parameter></paramdef>
   <paramdef>snd_pcm_hw_rule_func_t <parameter>func</parameter></paramdef>
   <paramdef>void * <parameter>private</parameter></paramdef>
   <paramdef>int <parameter>dep</parameter></paramdef>
   <paramdef> <parameter>...</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>runtime</parameter></term>
   <listitem>
    <para>
     the pcm runtime instance
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>cond</parameter></term>
   <listitem>
    <para>
     condition bits
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>var</parameter></term>
   <listitem>
    <para>
     the variable to evaluate
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>func</parameter></term>
   <listitem>
    <para>
     the evaluation function
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>private</parameter></term>
   <listitem>
    <para>
     the private data pointer passed to function
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>dep</parameter></term>
   <listitem>
    <para>
     the dependent variables
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>...</parameter></term>
   <listitem>
    <para>
     variable arguments
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
<title>Description</title>
<para>
   Returns zero if successful, or a negative error code on failure.
</para>
</refsect1>
</refentry>

<refentry id="API-snd-pcm-hw-constraint-integer">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>July 2015</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>snd_pcm_hw_constraint_integer</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.4.104</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>snd_pcm_hw_constraint_integer</refname>
 <refpurpose>
     apply an integer constraint to an interval
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>int <function>snd_pcm_hw_constraint_integer </function></funcdef>
   <paramdef>struct snd_pcm_runtime * <parameter>runtime</parameter></paramdef>
   <paramdef>snd_pcm_hw_param_t <parameter>var</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>runtime</parameter></term>
   <listitem>
    <para>
     PCM runtime instance
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>var</parameter></term>
   <listitem>
    <para>
     hw_params variable to apply the integer constraint
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
<title>Description</title>
<para>
   Apply the constraint of integer to an interval parameter.
</para>
</refsect1>
</refentry>

<refentry id="API-snd-pcm-hw-constraint-minmax">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>July 2015</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>snd_pcm_hw_constraint_minmax</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.4.104</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>snd_pcm_hw_constraint_minmax</refname>
 <refpurpose>
     apply a min/max range constraint to an interval
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>int <function>snd_pcm_hw_constraint_minmax </function></funcdef>
   <paramdef>struct snd_pcm_runtime * <parameter>runtime</parameter></paramdef>
   <paramdef>snd_pcm_hw_param_t <parameter>var</parameter></paramdef>
   <paramdef>unsigned int <parameter>min</parameter></paramdef>
   <paramdef>unsigned int <parameter>max</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>runtime</parameter></term>
   <listitem>
    <para>
     PCM runtime instance
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>var</parameter></term>
   <listitem>
    <para>
     hw_params variable to apply the range
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>min</parameter></term>
   <listitem>
    <para>
     the minimal value
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>max</parameter></term>
   <listitem>
    <para>
     the maximal value
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
<title>Description</title>
<para>
   Apply the min/max range constraint to an interval parameter.
</para>
</refsect1>
</refentry>

<refentry id="API-snd-pcm-hw-constraint-list">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>July 2015</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>snd_pcm_hw_constraint_list</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.4.104</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>snd_pcm_hw_constraint_list</refname>
 <refpurpose>
     apply a list of constraints to a parameter
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>int <function>snd_pcm_hw_constraint_list </function></funcdef>
   <paramdef>struct snd_pcm_runtime * <parameter>runtime</parameter></paramdef>
   <paramdef>unsigned int <parameter>cond</parameter></paramdef>
   <paramdef>snd_pcm_hw_param_t <parameter>var</parameter></paramdef>
   <paramdef>struct snd_pcm_hw_constraint_list * <parameter>l</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>runtime</parameter></term>
   <listitem>
    <para>
     PCM runtime instance
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>cond</parameter></term>
   <listitem>
    <para>
     condition bits
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>var</parameter></term>
   <listitem>
    <para>
     hw_params variable to apply the list constraint
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>l</parameter></term>
   <listitem>
    <para>
     list
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
<title>Description</title>
<para>
   Apply the list of constraints to an interval parameter.
</para>
</refsect1>
</refentry>

<refentry id="API-snd-pcm-hw-constraint-ratnums">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>July 2015</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>snd_pcm_hw_constraint_ratnums</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.4.104</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>snd_pcm_hw_constraint_ratnums</refname>
 <refpurpose>
     apply ratnums constraint to a parameter
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>int <function>snd_pcm_hw_constraint_ratnums </function></funcdef>
   <paramdef>struct snd_pcm_runtime * <parameter>runtime</parameter></paramdef>
   <paramdef>unsigned int <parameter>cond</parameter></paramdef>
   <paramdef>snd_pcm_hw_param_t <parameter>var</parameter></paramdef>
   <paramdef>struct snd_pcm_hw_constraint_ratnums * <parameter>r</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>runtime</parameter></term>
   <listitem>
    <para>
     PCM runtime instance
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>cond</parameter></term>
   <listitem>
    <para>
     condition bits
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>var</parameter></term>
   <listitem>
    <para>
     hw_params variable to apply the ratnums constraint
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>r</parameter></term>
   <listitem>
    <para>
     struct snd_ratnums constriants
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
</refentry>

<refentry id="API-snd-pcm-hw-constraint-ratdens">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>July 2015</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>snd_pcm_hw_constraint_ratdens</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.4.104</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>snd_pcm_hw_constraint_ratdens</refname>
 <refpurpose>
     apply ratdens constraint to a parameter
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>int <function>snd_pcm_hw_constraint_ratdens </function></funcdef>
   <paramdef>struct snd_pcm_runtime * <parameter>runtime</parameter></paramdef>
   <paramdef>unsigned int <parameter>cond</parameter></paramdef>
   <paramdef>snd_pcm_hw_param_t <parameter>var</parameter></paramdef>
   <paramdef>struct snd_pcm_hw_constraint_ratdens * <parameter>r</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>runtime</parameter></term>
   <listitem>
    <para>
     PCM runtime instance
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>cond</parameter></term>
   <listitem>
    <para>
     condition bits
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>var</parameter></term>
   <listitem>
    <para>
     hw_params variable to apply the ratdens constraint
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>r</parameter></term>
   <listitem>
    <para>
     struct snd_ratdens constriants
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
</refentry>

<refentry id="API-snd-pcm-hw-constraint-msbits">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>July 2015</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>snd_pcm_hw_constraint_msbits</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.4.104</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>snd_pcm_hw_constraint_msbits</refname>
 <refpurpose>
     add a hw constraint msbits rule
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>int <function>snd_pcm_hw_constraint_msbits </function></funcdef>
   <paramdef>struct snd_pcm_runtime * <parameter>runtime</parameter></paramdef>
   <paramdef>unsigned int <parameter>cond</parameter></paramdef>
   <paramdef>unsigned int <parameter>width</parameter></paramdef>
   <paramdef>unsigned int <parameter>msbits</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>runtime</parameter></term>
   <listitem>
    <para>
     PCM runtime instance
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>cond</parameter></term>
   <listitem>
    <para>
     condition bits
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>width</parameter></term>
   <listitem>
    <para>
     sample bits width
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>msbits</parameter></term>
   <listitem>
    <para>
     msbits width
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
</refentry>

<refentry id="API-snd-pcm-hw-constraint-step">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>July 2015</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>snd_pcm_hw_constraint_step</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.4.104</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>snd_pcm_hw_constraint_step</refname>
 <refpurpose>
     add a hw constraint step rule
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>int <function>snd_pcm_hw_constraint_step </function></funcdef>
   <paramdef>struct snd_pcm_runtime * <parameter>runtime</parameter></paramdef>
   <paramdef>unsigned int <parameter>cond</parameter></paramdef>
   <paramdef>snd_pcm_hw_param_t <parameter>var</parameter></paramdef>
   <paramdef>unsigned long <parameter>step</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>runtime</parameter></term>
   <listitem>
    <para>
     PCM runtime instance
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>cond</parameter></term>
   <listitem>
    <para>
     condition bits
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>var</parameter></term>
   <listitem>
    <para>
     hw_params variable to apply the step constraint
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>step</parameter></term>
   <listitem>
    <para>
     step size
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
</refentry>

<refentry id="API-snd-pcm-hw-constraint-pow2">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>July 2015</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>snd_pcm_hw_constraint_pow2</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.4.104</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>snd_pcm_hw_constraint_pow2</refname>
 <refpurpose>
     add a hw constraint power-of-2 rule
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>int <function>snd_pcm_hw_constraint_pow2 </function></funcdef>
   <paramdef>struct snd_pcm_runtime * <parameter>runtime</parameter></paramdef>
   <paramdef>unsigned int <parameter>cond</parameter></paramdef>
   <paramdef>snd_pcm_hw_param_t <parameter>var</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>runtime</parameter></term>
   <listitem>
    <para>
     PCM runtime instance
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>cond</parameter></term>
   <listitem>
    <para>
     condition bits
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>var</parameter></term>
   <listitem>
    <para>
     hw_params variable to apply the power-of-2 constraint
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
</refentry>

<refentry id="API-snd-pcm-hw-rule-noresample">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>July 2015</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>snd_pcm_hw_rule_noresample</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.4.104</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>snd_pcm_hw_rule_noresample</refname>
 <refpurpose>
     add a rule to allow disabling hw resampling
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>int <function>snd_pcm_hw_rule_noresample </function></funcdef>
   <paramdef>struct snd_pcm_runtime * <parameter>runtime</parameter></paramdef>
   <paramdef>unsigned int <parameter>base_rate</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>runtime</parameter></term>
   <listitem>
    <para>
     PCM runtime instance
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>base_rate</parameter></term>
   <listitem>
    <para>
     the rate at which the hardware does not resample
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
</refentry>

<refentry id="API-snd-pcm-hw-param-value">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>July 2015</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>snd_pcm_hw_param_value</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.4.104</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>snd_pcm_hw_param_value</refname>
 <refpurpose>
     return <parameter>params</parameter> field <parameter>var</parameter> value
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>int <function>snd_pcm_hw_param_value </function></funcdef>
   <paramdef>const struct snd_pcm_hw_params * <parameter>params</parameter></paramdef>
   <paramdef>snd_pcm_hw_param_t <parameter>var</parameter></paramdef>
   <paramdef>int * <parameter>dir</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>params</parameter></term>
   <listitem>
    <para>
     the hw_params instance
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>var</parameter></term>
   <listitem>
    <para>
     parameter to retrieve
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>dir</parameter></term>
   <listitem>
    <para>
     pointer to the direction (-1,0,1) or <constant>NULL</constant>
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
<title>Description</title>
<para>
   Return the value for field <parameter>var</parameter> if it's fixed in configuration space
   defined by <parameter>params</parameter>. Return -<constant>EINVAL</constant> otherwise.
</para>
</refsect1>
</refentry>

<refentry id="API-snd-pcm-hw-param-first">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>July 2015</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>snd_pcm_hw_param_first</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.4.104</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>snd_pcm_hw_param_first</refname>
 <refpurpose>
     refine config space and return minimum value
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>int <function>snd_pcm_hw_param_first </function></funcdef>
   <paramdef>struct snd_pcm_substream * <parameter>pcm</parameter></paramdef>
   <paramdef>struct snd_pcm_hw_params * <parameter>params</parameter></paramdef>
   <paramdef>snd_pcm_hw_param_t <parameter>var</parameter></paramdef>
   <paramdef>int * <parameter>dir</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>pcm</parameter></term>
   <listitem>
    <para>
     PCM instance
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>params</parameter></term>
   <listitem>
    <para>
     the hw_params instance
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>var</parameter></term>
   <listitem>
    <para>
     parameter to retrieve
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>dir</parameter></term>
   <listitem>
    <para>
     pointer to the direction (-1,0,1) or <constant>NULL</constant>
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
<title>Description</title>
<para>
   Inside configuration space defined by <parameter>params</parameter> remove from <parameter>var</parameter> all
   values &gt; minimum. Reduce configuration space accordingly.
   Return the minimum.
</para>
</refsect1>
</refentry>

<refentry id="API-snd-pcm-hw-param-last">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>July 2015</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>snd_pcm_hw_param_last</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.4.104</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>snd_pcm_hw_param_last</refname>
 <refpurpose>
     refine config space and return maximum value
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>int <function>snd_pcm_hw_param_last </function></funcdef>
   <paramdef>struct snd_pcm_substream * <parameter>pcm</parameter></paramdef>
   <paramdef>struct snd_pcm_hw_params * <parameter>params</parameter></paramdef>
   <paramdef>snd_pcm_hw_param_t <parameter>var</parameter></paramdef>
   <paramdef>int * <parameter>dir</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>pcm</parameter></term>
   <listitem>
    <para>
     PCM instance
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>params</parameter></term>
   <listitem>
    <para>
     the hw_params instance
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>var</parameter></term>
   <listitem>
    <para>
     parameter to retrieve
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>dir</parameter></term>
   <listitem>
    <para>
     pointer to the direction (-1,0,1) or <constant>NULL</constant>
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
<title>Description</title>
<para>
   Inside configuration space defined by <parameter>params</parameter> remove from <parameter>var</parameter> all
   values &lt; maximum. Reduce configuration space accordingly.
   Return the maximum.
</para>
</refsect1>
</refentry>

<refentry id="API-snd-pcm-lib-ioctl">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>July 2015</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>snd_pcm_lib_ioctl</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.4.104</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>snd_pcm_lib_ioctl</refname>
 <refpurpose>
     a generic PCM ioctl callback
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>int <function>snd_pcm_lib_ioctl </function></funcdef>
   <paramdef>struct snd_pcm_substream * <parameter>substream</parameter></paramdef>
   <paramdef>unsigned int <parameter>cmd</parameter></paramdef>
   <paramdef>void * <parameter>arg</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>substream</parameter></term>
   <listitem>
    <para>
     the pcm substream instance
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>cmd</parameter></term>
   <listitem>
    <para>
     ioctl command
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>arg</parameter></term>
   <listitem>
    <para>
     ioctl argument
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
<title>Description</title>
<para>
   Processes the generic ioctl commands for PCM.
   Can be passed as the ioctl callback for PCM ops.
   </para><para>

   Returns zero if successful, or a negative error code on failure.
</para>
</refsect1>
</refentry>

<refentry id="API-snd-pcm-period-elapsed">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>July 2015</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>snd_pcm_period_elapsed</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.4.104</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>snd_pcm_period_elapsed</refname>
 <refpurpose>
     update the pcm status for the next period
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>void <function>snd_pcm_period_elapsed </function></funcdef>
   <paramdef>struct snd_pcm_substream * <parameter>substream</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>substream</parameter></term>
   <listitem>
    <para>
     the pcm substream instance
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
<title>Description</title>
<para>
   This function is called from the interrupt handler when the
   PCM has processed the period size.  It will update the current
   pointer, wake up sleepers, etc.
   </para><para>

   Even if more than one periods have elapsed since the last call, you
   have to call this only once.
</para>
</refsect1>
</refentry>

<!-- sound/core/hwdep.c -->
<refentry id="API-snd-hwdep-new">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>July 2015</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>snd_hwdep_new</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.4.104</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>snd_hwdep_new</refname>
 <refpurpose>
  create a new hwdep instance
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>int <function>snd_hwdep_new </function></funcdef>
   <paramdef>struct snd_card * <parameter>card</parameter></paramdef>
   <paramdef>char * <parameter>id</parameter></paramdef>
   <paramdef>int <parameter>device</parameter></paramdef>
   <paramdef>struct snd_hwdep ** <parameter>rhwdep</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>card</parameter></term>
   <listitem>
    <para>
     the card instance
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>id</parameter></term>
   <listitem>
    <para>
     the id string
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>device</parameter></term>
   <listitem>
    <para>
     the device index (zero-based)
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>rhwdep</parameter></term>
   <listitem>
    <para>
     the pointer to store the new hwdep instance
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
<title>Description</title>
<para>
   Creates a new hwdep instance with the given index on the card.
   The callbacks (hwdep-&gt;ops) must be set on the returned instance
   after this call manually by the caller.
   </para><para>

   Returns zero if successful, or a negative error code on failure.
</para>
</refsect1>
</refentry>

<!-- sound/core/pcm_native.c -->
<refentry id="API-snd-pcm-stop">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>July 2015</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>snd_pcm_stop</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.4.104</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>snd_pcm_stop</refname>
 <refpurpose>
  try to stop all running streams in the substream group
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>int <function>snd_pcm_stop </function></funcdef>
   <paramdef>struct snd_pcm_substream * <parameter>substream</parameter></paramdef>
   <paramdef>snd_pcm_state_t <parameter>state</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>substream</parameter></term>
   <listitem>
    <para>
     the PCM substream instance
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>state</parameter></term>
   <listitem>
    <para>
     PCM state after stopping the stream
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
<title>Description</title>
<para>
   The state of each stream is then changed to the given state unconditionally.
</para>
</refsect1>
</refentry>

<refentry id="API-snd-pcm-suspend">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>July 2015</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>snd_pcm_suspend</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.4.104</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>snd_pcm_suspend</refname>
 <refpurpose>
     trigger SUSPEND to all linked streams
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>int <function>snd_pcm_suspend </function></funcdef>
   <paramdef>struct snd_pcm_substream * <parameter>substream</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>substream</parameter></term>
   <listitem>
    <para>
     the PCM substream
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
<title>Description</title>
<para>
   After this call, all streams are changed to SUSPENDED state.
</para>
</refsect1>
</refentry>

<refentry id="API-snd-pcm-suspend-all">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>July 2015</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>snd_pcm_suspend_all</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.4.104</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>snd_pcm_suspend_all</refname>
 <refpurpose>
     trigger SUSPEND to all substreams in the given pcm
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>int <function>snd_pcm_suspend_all </function></funcdef>
   <paramdef>struct snd_pcm * <parameter>pcm</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>pcm</parameter></term>
   <listitem>
    <para>
     the PCM instance
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
<title>Description</title>
<para>
   After this call, all streams are changed to SUSPENDED state.
</para>
</refsect1>
</refentry>

<!-- sound/core/memalloc.c -->
<refentry id="API-snd-malloc-pages">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>July 2015</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>snd_malloc_pages</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.4.104</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>snd_malloc_pages</refname>
 <refpurpose>
  allocate pages with the given size
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>void * <function>snd_malloc_pages </function></funcdef>
   <paramdef>size_t <parameter>size</parameter></paramdef>
   <paramdef>gfp_t <parameter>gfp_flags</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>size</parameter></term>
   <listitem>
    <para>
     the size to allocate in bytes
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>gfp_flags</parameter></term>
   <listitem>
    <para>
     the allocation conditions, GFP_XXX
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
<title>Description</title>
<para>
   Allocates the physically contiguous pages with the given size.
   </para><para>

   Returns the pointer of the buffer, or NULL if no enoguh memory.
</para>
</refsect1>
</refentry>

<refentry id="API-snd-free-pages">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>July 2015</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>snd_free_pages</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.4.104</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>snd_free_pages</refname>
 <refpurpose>
     release the pages
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>void <function>snd_free_pages </function></funcdef>
   <paramdef>void * <parameter>ptr</parameter></paramdef>
   <paramdef>size_t <parameter>size</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>ptr</parameter></term>
   <listitem>
    <para>
     the buffer pointer to release
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>size</parameter></term>
   <listitem>
    <para>
     the allocated buffer size
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
<title>Description</title>
<para>
   Releases the buffer allocated via <function>snd_malloc_pages</function>.
</para>
</refsect1>
</refentry>

<refentry id="API-snd-dma-alloc-pages">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>July 2015</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>snd_dma_alloc_pages</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.4.104</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>snd_dma_alloc_pages</refname>
 <refpurpose>
     allocate the buffer area according to the given type
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>int <function>snd_dma_alloc_pages </function></funcdef>
   <paramdef>int <parameter>type</parameter></paramdef>
   <paramdef>struct device * <parameter>device</parameter></paramdef>
   <paramdef>size_t <parameter>size</parameter></paramdef>
   <paramdef>struct snd_dma_buffer * <parameter>dmab</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>type</parameter></term>
   <listitem>
    <para>
     the DMA buffer type
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>device</parameter></term>
   <listitem>
    <para>
     the device pointer
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>size</parameter></term>
   <listitem>
    <para>
     the buffer size to allocate
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>dmab</parameter></term>
   <listitem>
    <para>
     buffer allocation record to store the allocated data
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
<title>Description</title>
<para>
   Calls the memory-allocator function for the corresponding
   buffer type.
   </para><para>

   Returns zero if the buffer with the given size is allocated successfully,
   other a negative value at error.
</para>
</refsect1>
</refentry>

<refentry id="API-snd-dma-alloc-pages-fallback">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>July 2015</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>snd_dma_alloc_pages_fallback</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.4.104</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>snd_dma_alloc_pages_fallback</refname>
 <refpurpose>
     allocate the buffer area according to the given type with fallback
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>int <function>snd_dma_alloc_pages_fallback </function></funcdef>
   <paramdef>int <parameter>type</parameter></paramdef>
   <paramdef>struct device * <parameter>device</parameter></paramdef>
   <paramdef>size_t <parameter>size</parameter></paramdef>
   <paramdef>struct snd_dma_buffer * <parameter>dmab</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>type</parameter></term>
   <listitem>
    <para>
     the DMA buffer type
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>device</parameter></term>
   <listitem>
    <para>
     the device pointer
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>size</parameter></term>
   <listitem>
    <para>
     the buffer size to allocate
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>dmab</parameter></term>
   <listitem>
    <para>
     buffer allocation record to store the allocated data
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
<title>Description</title>
<para>
   Calls the memory-allocator function for the corresponding
   buffer type.  When no space is left, this function reduces the size and
   tries to allocate again.  The size actually allocated is stored in
   res_size argument.
   </para><para>

   Returns zero if the buffer with the given size is allocated successfully,
   other a negative value at error.
</para>
</refsect1>
</refentry>

<refentry id="API-snd-dma-free-pages">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>July 2015</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>snd_dma_free_pages</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.4.104</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>snd_dma_free_pages</refname>
 <refpurpose>
     release the allocated buffer
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>void <function>snd_dma_free_pages </function></funcdef>
   <paramdef>struct snd_dma_buffer * <parameter>dmab</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>dmab</parameter></term>
   <listitem>
    <para>
     the buffer allocation record to release
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
<title>Description</title>
<para>
   Releases the allocated buffer via <function>snd_dma_alloc_pages</function>.
</para>
</refsect1>
</refentry>

<refentry id="API-snd-dma-get-reserved-buf">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>July 2015</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>snd_dma_get_reserved_buf</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.4.104</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>snd_dma_get_reserved_buf</refname>
 <refpurpose>
     get the reserved buffer for the given device
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>size_t <function>snd_dma_get_reserved_buf </function></funcdef>
   <paramdef>struct snd_dma_buffer * <parameter>dmab</parameter></paramdef>
   <paramdef>unsigned int <parameter>id</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>dmab</parameter></term>
   <listitem>
    <para>
     the buffer allocation record to store
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>id</parameter></term>
   <listitem>
    <para>
     the buffer id
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
<title>Description</title>
<para>
   Looks for the reserved-buffer list and re-uses if the same buffer
   is found in the list.  When the buffer is found, it's removed from the free list.
   </para><para>

   Returns the size of buffer if the buffer is found, or zero if not found.
</para>
</refsect1>
</refentry>

<refentry id="API-snd-dma-reserve-buf">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>July 2015</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>snd_dma_reserve_buf</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.4.104</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>snd_dma_reserve_buf</refname>
 <refpurpose>
     reserve the buffer
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>int <function>snd_dma_reserve_buf </function></funcdef>
   <paramdef>struct snd_dma_buffer * <parameter>dmab</parameter></paramdef>
   <paramdef>unsigned int <parameter>id</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>dmab</parameter></term>
   <listitem>
    <para>
     the buffer to reserve
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>id</parameter></term>
   <listitem>
    <para>
     the buffer id
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
<title>Description</title>
<para>
   Reserves the given buffer as a reserved buffer.
   </para><para>

   Returns zero if successful, or a negative code at error.
</para>
</refsect1>
</refentry>

<!-- FIXME: Removed for now since no structured comments in source
X!Isound/sound_firmware.c
-->
  </chapter>

  <chapter id="uart16x50">
     <title>16x50 UART Driver</title>
<!-- drivers/tty/serial/serial_core.c -->
<refentry id="API-uart-update-timeout">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>July 2015</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>uart_update_timeout</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.4.104</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>uart_update_timeout</refname>
 <refpurpose>
  update per-port FIFO timeout.
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>void <function>uart_update_timeout </function></funcdef>
   <paramdef>struct uart_port * <parameter>port</parameter></paramdef>
   <paramdef>unsigned int <parameter>cflag</parameter></paramdef>
   <paramdef>unsigned int <parameter>baud</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>port</parameter></term>
   <listitem>
    <para>
     uart_port structure describing the port
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>cflag</parameter></term>
   <listitem>
    <para>
     termios cflag value
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>baud</parameter></term>
   <listitem>
    <para>
     speed of the port
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
<title>Description</title>
<para>
   Set the port FIFO timeout value.  The <parameter>cflag</parameter> value should
   reflect the actual hardware settings.
</para>
</refsect1>
</refentry>

<refentry id="API-uart-get-baud-rate">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>July 2015</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>uart_get_baud_rate</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.4.104</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>uart_get_baud_rate</refname>
 <refpurpose>
     return baud rate for a particular port
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>unsigned int <function>uart_get_baud_rate </function></funcdef>
   <paramdef>struct uart_port * <parameter>port</parameter></paramdef>
   <paramdef>struct ktermios * <parameter>termios</parameter></paramdef>
   <paramdef>struct ktermios * <parameter>old</parameter></paramdef>
   <paramdef>unsigned int <parameter>min</parameter></paramdef>
   <paramdef>unsigned int <parameter>max</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>port</parameter></term>
   <listitem>
    <para>
     uart_port structure describing the port in question.
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>termios</parameter></term>
   <listitem>
    <para>
     desired termios settings.
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>old</parameter></term>
   <listitem>
    <para>
     old termios (or NULL)
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>min</parameter></term>
   <listitem>
    <para>
     minimum acceptable baud rate
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>max</parameter></term>
   <listitem>
    <para>
     maximum acceptable baud rate
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
<title>Description</title>
<para>
   Decode the termios structure into a numeric baud rate,
   taking account of the magic 38400 baud rate (with spd_*
   flags), and mapping the <constant>B0</constant> rate to 9600 baud.
   </para><para>

   If the new baud rate is invalid, try the old termios setting.
   If it's still invalid, we try 9600 baud.
   </para><para>

   Update the <parameter>termios</parameter> structure to reflect the baud rate
   we're actually going to be using. Don't do this for the case
   where B0 is requested (<quote>hang up</quote>).
</para>
</refsect1>
</refentry>

<refentry id="API-uart-get-divisor">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>July 2015</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>uart_get_divisor</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.4.104</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>uart_get_divisor</refname>
 <refpurpose>
     return uart clock divisor
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>unsigned int <function>uart_get_divisor </function></funcdef>
   <paramdef>struct uart_port * <parameter>port</parameter></paramdef>
   <paramdef>unsigned int <parameter>baud</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>port</parameter></term>
   <listitem>
    <para>
     uart_port structure describing the port.
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>baud</parameter></term>
   <listitem>
    <para>
     desired baud rate
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
<title>Description</title>
<para>
   Calculate the uart clock divisor for the port.
</para>
</refsect1>
</refentry>

<refentry id="API-uart-parse-options">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>July 2015</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>uart_parse_options</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.4.104</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>uart_parse_options</refname>
 <refpurpose>
     Parse serial port baud/parity/bits/flow contro.
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>void <function>uart_parse_options </function></funcdef>
   <paramdef>char * <parameter>options</parameter></paramdef>
   <paramdef>int * <parameter>baud</parameter></paramdef>
   <paramdef>int * <parameter>parity</parameter></paramdef>
   <paramdef>int * <parameter>bits</parameter></paramdef>
   <paramdef>int * <parameter>flow</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>options</parameter></term>
   <listitem>
    <para>
     pointer to option string
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>baud</parameter></term>
   <listitem>
    <para>
     pointer to an 'int' variable for the baud rate.
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>parity</parameter></term>
   <listitem>
    <para>
     pointer to an 'int' variable for the parity.
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>bits</parameter></term>
   <listitem>
    <para>
     pointer to an 'int' variable for the number of data bits.
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>flow</parameter></term>
   <listitem>
    <para>
     pointer to an 'int' variable for the flow control character.
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
<title>Description</title>
<para>
   uart_parse_options decodes a string containing the serial console
   options.  The format of the string is &lt;baud&gt;&lt;parity&gt;&lt;bits&gt;&lt;flow&gt;,
</para>
</refsect1>
<refsect1>
<title>eg</title>
<para>
   115200n8r
</para>
</refsect1>
</refentry>

<refentry id="API-uart-set-options">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>July 2015</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>uart_set_options</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.4.104</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>uart_set_options</refname>
 <refpurpose>
     setup the serial console parameters
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>int <function>uart_set_options </function></funcdef>
   <paramdef>struct uart_port * <parameter>port</parameter></paramdef>
   <paramdef>struct console * <parameter>co</parameter></paramdef>
   <paramdef>int <parameter>baud</parameter></paramdef>
   <paramdef>int <parameter>parity</parameter></paramdef>
   <paramdef>int <parameter>bits</parameter></paramdef>
   <paramdef>int <parameter>flow</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>port</parameter></term>
   <listitem>
    <para>
     pointer to the serial ports uart_port structure
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>co</parameter></term>
   <listitem>
    <para>
     console pointer
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>baud</parameter></term>
   <listitem>
    <para>
     baud rate
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>parity</parameter></term>
   <listitem>
    <para>
     parity character - 'n' (none), 'o' (odd), 'e' (even)
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>bits</parameter></term>
   <listitem>
    <para>
     number of data bits
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>flow</parameter></term>
   <listitem>
    <para>
     flow control character - 'r' (rts)
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
</refentry>

<refentry id="API-uart-register-driver">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>July 2015</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>uart_register_driver</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.4.104</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>uart_register_driver</refname>
 <refpurpose>
     register a driver with the uart core layer
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>int <function>uart_register_driver </function></funcdef>
   <paramdef>struct uart_driver * <parameter>drv</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>drv</parameter></term>
   <listitem>
    <para>
     low level driver structure
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
<title>Description</title>
<para>
   Register a uart driver with the core driver.  We in turn register
   with the tty layer, and initialise the core driver per-port state.
   </para><para>

   We have a proc file in /proc/tty/driver which is named after the
   normal driver.
   </para><para>

   drv-&gt;port should be NULL, and the per-port structures should be
   registered using uart_add_one_port after this call has succeeded.
</para>
</refsect1>
</refentry>

<refentry id="API-uart-unregister-driver">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>July 2015</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>uart_unregister_driver</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.4.104</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>uart_unregister_driver</refname>
 <refpurpose>
     remove a driver from the uart core layer
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>void <function>uart_unregister_driver </function></funcdef>
   <paramdef>struct uart_driver * <parameter>drv</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>drv</parameter></term>
   <listitem>
    <para>
     low level driver structure
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
<title>Description</title>
<para>
   Remove all references to a driver from the core driver.  The low
   level driver must have removed all its ports via the
   <function>uart_remove_one_port</function> if it registered them with <function>uart_add_one_port</function>.
   (ie, drv-&gt;port == NULL)
</para>
</refsect1>
</refentry>

<refentry id="API-uart-add-one-port">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>July 2015</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>uart_add_one_port</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.4.104</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>uart_add_one_port</refname>
 <refpurpose>
     attach a driver-defined port structure
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>int <function>uart_add_one_port </function></funcdef>
   <paramdef>struct uart_driver * <parameter>drv</parameter></paramdef>
   <paramdef>struct uart_port * <parameter>uport</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>drv</parameter></term>
   <listitem>
    <para>
     pointer to the uart low level driver structure for this port
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>uport</parameter></term>
   <listitem>
    <para>
     uart port structure to use for this port.
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
<title>Description</title>
<para>
   This allows the driver to register its own uart_port structure
   with the core driver.  The main purpose is to allow the low
   level uart drivers to expand uart_port, rather than having yet
   more levels of structures.
</para>
</refsect1>
</refentry>

<refentry id="API-uart-remove-one-port">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>July 2015</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>uart_remove_one_port</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.4.104</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>uart_remove_one_port</refname>
 <refpurpose>
     detach a driver defined port structure
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>int <function>uart_remove_one_port </function></funcdef>
   <paramdef>struct uart_driver * <parameter>drv</parameter></paramdef>
   <paramdef>struct uart_port * <parameter>uport</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>drv</parameter></term>
   <listitem>
    <para>
     pointer to the uart low level driver structure for this port
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>uport</parameter></term>
   <listitem>
    <para>
     uart port structure for this port
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
<title>Description</title>
<para>
   This unhooks (and hangs up) the specified port structure from the
   core driver.  No further calls will be made to the low-level code
   for this port.
</para>
</refsect1>
</refentry>

<refentry id="API-uart-handle-dcd-change">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>July 2015</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>uart_handle_dcd_change</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.4.104</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>uart_handle_dcd_change</refname>
 <refpurpose>
     handle a change of carrier detect state
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>void <function>uart_handle_dcd_change </function></funcdef>
   <paramdef>struct uart_port * <parameter>uport</parameter></paramdef>
   <paramdef>unsigned int <parameter>status</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>uport</parameter></term>
   <listitem>
    <para>
     uart_port structure for the open port
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>status</parameter></term>
   <listitem>
    <para>
     new carrier detect status, nonzero if active
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
</refentry>

<refentry id="API-uart-handle-cts-change">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>July 2015</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>uart_handle_cts_change</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.4.104</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>uart_handle_cts_change</refname>
 <refpurpose>
     handle a change of clear-to-send state
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>void <function>uart_handle_cts_change </function></funcdef>
   <paramdef>struct uart_port * <parameter>uport</parameter></paramdef>
   <paramdef>unsigned int <parameter>status</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>uport</parameter></term>
   <listitem>
    <para>
     uart_port structure for the open port
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>status</parameter></term>
   <listitem>
    <para>
     new clear to send status, nonzero if active
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
</refentry>

<refentry id="API-uart-insert-char">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>July 2015</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>uart_insert_char</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.4.104</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>uart_insert_char</refname>
 <refpurpose>
     push a char to the uart layer
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>void <function>uart_insert_char </function></funcdef>
   <paramdef>struct uart_port * <parameter>port</parameter></paramdef>
   <paramdef>unsigned int <parameter>status</parameter></paramdef>
   <paramdef>unsigned int <parameter>overrun</parameter></paramdef>
   <paramdef>unsigned int <parameter>ch</parameter></paramdef>
   <paramdef>unsigned int <parameter>flag</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>port</parameter></term>
   <listitem>
    <para>
     corresponding port
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>status</parameter></term>
   <listitem>
    <para>
     state of the serial port RX buffer (LSR for 8250)
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>overrun</parameter></term>
   <listitem>
    <para>
     mask of overrun bits in <parameter>status</parameter>
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>ch</parameter></term>
   <listitem>
    <para>
     character to push
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>flag</parameter></term>
   <listitem>
    <para>
     flag for the character (see TTY_NORMAL and friends)
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
<title>Description</title>
<para>
   </para><para>

   User is responsible to call tty_flip_buffer_push when they are done with
   insertion.
</para>
</refsect1>
</refentry>

<!-- drivers/tty/serial/8250/8250.c -->
<refentry id="API-serial8250-suspend-port">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>July 2015</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>serial8250_suspend_port</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.4.104</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>serial8250_suspend_port</refname>
 <refpurpose>
  suspend one serial port
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>void <function>serial8250_suspend_port </function></funcdef>
   <paramdef>int <parameter>line</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>line</parameter></term>
   <listitem>
    <para>
     serial line number
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
<title>Description</title>
<para>
   Suspend one serial port.
</para>
</refsect1>
</refentry>

<refentry id="API-serial8250-resume-port">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>July 2015</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>serial8250_resume_port</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.4.104</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>serial8250_resume_port</refname>
 <refpurpose>
     resume one serial port
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>void <function>serial8250_resume_port </function></funcdef>
   <paramdef>int <parameter>line</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>line</parameter></term>
   <listitem>
    <para>
     serial line number
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
<title>Description</title>
<para>
   Resume one serial port.
</para>
</refsect1>
</refentry>

<refentry id="API-serial8250-register-port">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>July 2015</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>serial8250_register_port</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.4.104</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>serial8250_register_port</refname>
 <refpurpose>
     register a serial port
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>int <function>serial8250_register_port </function></funcdef>
   <paramdef>struct uart_port * <parameter>port</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>port</parameter></term>
   <listitem>
    <para>
     serial port template
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
<title>Description</title>
<para>
   Configure the serial port specified by the request. If the
   port exists and is in use, it is hung up and unregistered
   first.
   </para><para>

   The port is then probed and if necessary the IRQ is autodetected
   If this fails an error is returned.
   </para><para>

   On success the port is ready to use and the line number is returned.
</para>
</refsect1>
</refentry>

<refentry id="API-serial8250-unregister-port">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>July 2015</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>serial8250_unregister_port</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.4.104</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>serial8250_unregister_port</refname>
 <refpurpose>
     remove a 16x50 serial port at runtime
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>void <function>serial8250_unregister_port </function></funcdef>
   <paramdef>int <parameter>line</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>line</parameter></term>
   <listitem>
    <para>
     serial line number
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
<title>Description</title>
<para>
   Remove one serial port.  This may not be called from interrupt
   context.  We hand the port back to the our control.
</para>
</refsect1>
</refentry>

  </chapter>

  <chapter id="fbdev">
     <title>Frame Buffer Library</title>

     <para>
       The frame buffer drivers depend heavily on four data structures.
       These structures are declared in include/linux/fb.h.  They are
       fb_info, fb_var_screeninfo, fb_fix_screeninfo and fb_monospecs.
       The last three can be made available to and from userland.
     </para>

     <para>
       fb_info defines the current state of a particular video card.
       Inside fb_info, there exists a fb_ops structure which is a
       collection of needed functions to make fbdev and fbcon work.
       fb_info is only visible to the kernel.
     </para>

     <para>
       fb_var_screeninfo is used to describe the features of a video card
       that are user defined.  With fb_var_screeninfo, things such as
       depth and the resolution may be defined.
     </para>

     <para>
       The next structure is fb_fix_screeninfo. This defines the
       properties of a card that are created when a mode is set and can't
       be changed otherwise.  A good example of this is the start of the
       frame buffer memory.  This "locks" the address of the frame buffer
       memory, so that it cannot be changed or moved.
     </para>

     <para>
       The last structure is fb_monospecs. In the old API, there was
       little importance for fb_monospecs. This allowed for forbidden things
       such as setting a mode of 800x600 on a fix frequency monitor. With
       the new API, fb_monospecs prevents such things, and if used
       correctly, can prevent a monitor from being cooked.  fb_monospecs
       will not be useful until kernels 2.5.x.
     </para>

     <sect1><title>Frame Buffer Memory</title>
<!-- drivers/video/fbmem.c -->
<refentry id="API-register-framebuffer">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>July 2015</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>register_framebuffer</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.4.104</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>register_framebuffer</refname>
 <refpurpose>
  registers a frame buffer device
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>int <function>register_framebuffer </function></funcdef>
   <paramdef>struct fb_info * <parameter>fb_info</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>fb_info</parameter></term>
   <listitem>
    <para>
     frame buffer info structure
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
<title>Description</title>
<para>
   Registers a frame buffer device <parameter>fb_info</parameter>.
   </para><para>

   Returns negative errno on error, or zero for success.
</para>
</refsect1>
</refentry>

<refentry id="API-unregister-framebuffer">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>July 2015</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>unregister_framebuffer</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.4.104</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>unregister_framebuffer</refname>
 <refpurpose>
     releases a frame buffer device
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>int <function>unregister_framebuffer </function></funcdef>
   <paramdef>struct fb_info * <parameter>fb_info</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>fb_info</parameter></term>
   <listitem>
    <para>
     frame buffer info structure
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
<title>Description</title>
<para>
   Unregisters a frame buffer device <parameter>fb_info</parameter>.
   </para><para>

   Returns negative errno on error, or zero for success.
   </para><para>

   This function will also notify the framebuffer console
   to release the driver.
   </para><para>

   This is meant to be called within a driver's <function>module_exit</function>
   function. If this is called outside <function>module_exit</function>, ensure
   that the driver implements <function>fb_open</function> and <function>fb_release</function> to
   check that no processes are using the device.
</para>
</refsect1>
</refentry>

<refentry id="API-fb-set-suspend">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>July 2015</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>fb_set_suspend</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.4.104</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>fb_set_suspend</refname>
 <refpurpose>
     low level driver signals suspend
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>void <function>fb_set_suspend </function></funcdef>
   <paramdef>struct fb_info * <parameter>info</parameter></paramdef>
   <paramdef>int <parameter>state</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>info</parameter></term>
   <listitem>
    <para>
     framebuffer affected
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>state</parameter></term>
   <listitem>
    <para>
     0 = resuming, !=0 = suspending
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
<title>Description</title>
<para>
   This is meant to be used by low level drivers to
   signal suspend/resume to the core &amp; clients.
   It must be called with the console semaphore held
</para>
</refsect1>
</refentry>

<refentry id="API-fb-get-options">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>July 2015</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>fb_get_options</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.4.104</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>fb_get_options</refname>
 <refpurpose>
     get kernel boot parameters
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>int <function>fb_get_options </function></funcdef>
   <paramdef>char * <parameter>name</parameter></paramdef>
   <paramdef>char ** <parameter>option</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>name</parameter></term>
   <listitem>
    <para>
     framebuffer name as it would appear in
     the boot parameter line
     (video=&lt;name&gt;:&lt;options&gt;)
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>option</parameter></term>
   <listitem>
    <para>
     the option will be stored here
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
<title>NOTE</title>
<para>
   Needed to maintain backwards compatibility
</para>
</refsect1>
</refentry>

     </sect1>
<!--
     <sect1><title>Frame Buffer Console</title>
X!Edrivers/video/console/fbcon.c
     </sect1>
-->
     <sect1><title>Frame Buffer Colormap</title>
<!-- drivers/video/fbcmap.c -->
<refentry id="API-fb-dealloc-cmap">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>July 2015</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>fb_dealloc_cmap</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.4.104</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>fb_dealloc_cmap</refname>
 <refpurpose>
  deallocate a colormap
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>void <function>fb_dealloc_cmap </function></funcdef>
   <paramdef>struct fb_cmap * <parameter>cmap</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>cmap</parameter></term>
   <listitem>
    <para>
     frame buffer colormap structure
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
<title>Description</title>
<para>
   Deallocates a colormap that was previously allocated with
   <function>fb_alloc_cmap</function>.
</para>
</refsect1>
</refentry>

<refentry id="API-fb-copy-cmap">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>July 2015</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>fb_copy_cmap</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.4.104</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>fb_copy_cmap</refname>
 <refpurpose>
     copy a colormap
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>int <function>fb_copy_cmap </function></funcdef>
   <paramdef>const struct fb_cmap * <parameter>from</parameter></paramdef>
   <paramdef>struct fb_cmap * <parameter>to</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>from</parameter></term>
   <listitem>
    <para>
     frame buffer colormap structure
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>to</parameter></term>
   <listitem>
    <para>
     frame buffer colormap structure
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
<title>Description</title>
<para>
   Copy contents of colormap from <parameter>from</parameter> to <parameter>to</parameter>.
</para>
</refsect1>
</refentry>

<refentry id="API-fb-set-cmap">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>July 2015</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>fb_set_cmap</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.4.104</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>fb_set_cmap</refname>
 <refpurpose>
     set the colormap
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>int <function>fb_set_cmap </function></funcdef>
   <paramdef>struct fb_cmap * <parameter>cmap</parameter></paramdef>
   <paramdef>struct fb_info * <parameter>info</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>cmap</parameter></term>
   <listitem>
    <para>
     frame buffer colormap structure
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>info</parameter></term>
   <listitem>
    <para>
     frame buffer info structure
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
<title>Description</title>
<para>
   Sets the colormap <parameter>cmap</parameter> for a screen of device <parameter>info</parameter>.
   </para><para>

   Returns negative errno on error, or zero on success.
</para>
</refsect1>
</refentry>

<refentry id="API-fb-default-cmap">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>July 2015</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>fb_default_cmap</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.4.104</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>fb_default_cmap</refname>
 <refpurpose>
     get default colormap
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>const struct fb_cmap * <function>fb_default_cmap </function></funcdef>
   <paramdef>int <parameter>len</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>len</parameter></term>
   <listitem>
    <para>
     size of palette for a depth
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
<title>Description</title>
<para>
   Gets the default colormap for a specific screen depth.  <parameter>len</parameter>
   is the size of the palette for a particular screen depth.
   </para><para>

   Returns pointer to a frame buffer colormap structure.
</para>
</refsect1>
</refentry>

<refentry id="API-fb-invert-cmaps">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>July 2015</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>fb_invert_cmaps</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.4.104</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>fb_invert_cmaps</refname>
 <refpurpose>
     invert all defaults colormaps
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>void <function>fb_invert_cmaps </function></funcdef>
   <paramdef> <parameter>void</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>void</parameter></term>
   <listitem>
    <para>
     no arguments
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
<title>Description</title>
<para>
   </para><para>

   Invert all default colormaps.
</para>
</refsect1>
</refentry>

     </sect1>
<!-- FIXME:
  drivers/video/fbgen.c has no docs, which stuffs up the sgml.  Comment
  out until somebody adds docs.  KAO
     <sect1><title>Frame Buffer Generic Functions</title>
X!Idrivers/video/fbgen.c
     </sect1>
KAO -->
     <sect1><title>Frame Buffer Video Mode Database</title>
<!-- drivers/video/modedb.c -->
<refentry id="API-fb-try-mode">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>July 2015</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>fb_try_mode</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.4.104</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>fb_try_mode</refname>
 <refpurpose>
  test a video mode
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>int <function>fb_try_mode </function></funcdef>
   <paramdef>struct fb_var_screeninfo * <parameter>var</parameter></paramdef>
   <paramdef>struct fb_info * <parameter>info</parameter></paramdef>
   <paramdef>const struct fb_videomode * <parameter>mode</parameter></paramdef>
   <paramdef>unsigned int <parameter>bpp</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>var</parameter></term>
   <listitem>
    <para>
     frame buffer user defined part of display
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>info</parameter></term>
   <listitem>
    <para>
     frame buffer info structure
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>mode</parameter></term>
   <listitem>
    <para>
     frame buffer video mode structure
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>bpp</parameter></term>
   <listitem>
    <para>
     color depth in bits per pixel
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
<title>Description</title>
<para>
   Tries a video mode to test it's validity for device <parameter>info</parameter>.
   </para><para>

   Returns 1 on success.
</para>
</refsect1>
</refentry>

<refentry id="API-fb-delete-videomode">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>July 2015</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>fb_delete_videomode</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.4.104</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>fb_delete_videomode</refname>
 <refpurpose>
     removed videomode entry from modelist
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>void <function>fb_delete_videomode </function></funcdef>
   <paramdef>const struct fb_videomode * <parameter>mode</parameter></paramdef>
   <paramdef>struct list_head * <parameter>head</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>mode</parameter></term>
   <listitem>
    <para>
     videomode to remove
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>head</parameter></term>
   <listitem>
    <para>
     struct list_head of modelist
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
<title>NOTES</title>
<para>
   Will remove all matching mode entries
</para>
</refsect1>
</refentry>

<!-- drivers/video/modedb.c -->
<refentry id="API-fb-find-mode">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>July 2015</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>fb_find_mode</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.4.104</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>fb_find_mode</refname>
 <refpurpose>
  finds a valid video mode
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>int <function>fb_find_mode </function></funcdef>
   <paramdef>struct fb_var_screeninfo * <parameter>var</parameter></paramdef>
   <paramdef>struct fb_info * <parameter>info</parameter></paramdef>
   <paramdef>const char * <parameter>mode_option</parameter></paramdef>
   <paramdef>const struct fb_videomode * <parameter>db</parameter></paramdef>
   <paramdef>unsigned int <parameter>dbsize</parameter></paramdef>
   <paramdef>const struct fb_videomode * <parameter>default_mode</parameter></paramdef>
   <paramdef>unsigned int <parameter>default_bpp</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>var</parameter></term>
   <listitem>
    <para>
     frame buffer user defined part of display
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>info</parameter></term>
   <listitem>
    <para>
     frame buffer info structure
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>mode_option</parameter></term>
   <listitem>
    <para>
     string video mode to find
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>db</parameter></term>
   <listitem>
    <para>
     video mode database
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>dbsize</parameter></term>
   <listitem>
    <para>
     size of <parameter>db</parameter>
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>default_mode</parameter></term>
   <listitem>
    <para>
     default video mode to fall back to
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>default_bpp</parameter></term>
   <listitem>
    <para>
     default color depth in bits per pixel
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
<title>Description</title>
<para>
   Finds a suitable video mode, starting with the specified mode
   in <parameter>mode_option</parameter> with fallback to <parameter>default_mode</parameter>.  If
   <parameter>default_mode</parameter> fails, all modes in the video mode database will
   be tried.
   </para><para>

   Valid mode specifiers for <parameter>mode_option</parameter>:
   </para><para>

   &lt;xres&gt;x&lt;yres&gt;[M][R][-&lt;bpp&gt;][@&lt;refresh&gt;][i][m] or
   &lt;name&gt;[-&lt;bpp&gt;][@&lt;refresh&gt;]
   </para><para>

   with &lt;xres&gt;, &lt;yres&gt;, &lt;bpp&gt; and &lt;refresh&gt; decimal numbers and
   &lt;name&gt; a string.
   </para><para>

   If 'M' is present after yres (and before refresh/bpp if present),
   the function will compute the timings using VESA(tm) Coordinated
   Video Timings (CVT).  If 'R' is present after 'M', will compute with
   reduced blanking (for flatpanels).  If 'i' is present, compute
   interlaced mode.  If 'm' is present, add margins equal to 1.8%
   of xres rounded down to 8 pixels, and 1.8% of yres. The char
   'i' and 'm' must be after 'M' and 'R'. Example:
   </para><para>

   1024x768MR-8<parameter>60m</parameter> - Reduced blank with margins at 60Hz.
</para>
</refsect1>
<refsect1>
<title>NOTE</title>
<para>
   The passed struct <parameter>var</parameter> is _not_ cleared!  This allows you
   to supply values for e.g. the grayscale and accel_flags fields.
   </para><para>

   Returns zero for failure, 1 if using specified <parameter>mode_option</parameter>,
   2 if using specified <parameter>mode_option</parameter> with an ignored refresh rate,
   3 if default mode is used, 4 if fall back to any valid mode.
</para>
</refsect1>
</refentry>

<refentry id="API-fb-var-to-videomode">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>July 2015</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>fb_var_to_videomode</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.4.104</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>fb_var_to_videomode</refname>
 <refpurpose>
     convert fb_var_screeninfo to fb_videomode
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>void <function>fb_var_to_videomode </function></funcdef>
   <paramdef>struct fb_videomode * <parameter>mode</parameter></paramdef>
   <paramdef>const struct fb_var_screeninfo * <parameter>var</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>mode</parameter></term>
   <listitem>
    <para>
     pointer to struct fb_videomode
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>var</parameter></term>
   <listitem>
    <para>
     pointer to struct fb_var_screeninfo
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
</refentry>

<refentry id="API-fb-videomode-to-var">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>July 2015</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>fb_videomode_to_var</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.4.104</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>fb_videomode_to_var</refname>
 <refpurpose>
     convert fb_videomode to fb_var_screeninfo
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>void <function>fb_videomode_to_var </function></funcdef>
   <paramdef>struct fb_var_screeninfo * <parameter>var</parameter></paramdef>
   <paramdef>const struct fb_videomode * <parameter>mode</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>var</parameter></term>
   <listitem>
    <para>
     pointer to struct fb_var_screeninfo
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>mode</parameter></term>
   <listitem>
    <para>
     pointer to struct fb_videomode
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
</refentry>

<refentry id="API-fb-mode-is-equal">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>July 2015</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>fb_mode_is_equal</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.4.104</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>fb_mode_is_equal</refname>
 <refpurpose>
     compare 2 videomodes
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>int <function>fb_mode_is_equal </function></funcdef>
   <paramdef>const struct fb_videomode * <parameter>mode1</parameter></paramdef>
   <paramdef>const struct fb_videomode * <parameter>mode2</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>mode1</parameter></term>
   <listitem>
    <para>
     first videomode
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>mode2</parameter></term>
   <listitem>
    <para>
     second videomode
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
<title>RETURNS</title>
<para>
   1 if equal, 0 if not
</para>
</refsect1>
</refentry>

<refentry id="API-fb-find-best-mode">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>July 2015</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>fb_find_best_mode</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.4.104</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>fb_find_best_mode</refname>
 <refpurpose>
     find best matching videomode
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>const struct fb_videomode * <function>fb_find_best_mode </function></funcdef>
   <paramdef>const struct fb_var_screeninfo * <parameter>var</parameter></paramdef>
   <paramdef>struct list_head * <parameter>head</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>var</parameter></term>
   <listitem>
    <para>
     pointer to struct fb_var_screeninfo
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>head</parameter></term>
   <listitem>
    <para>
     pointer to struct list_head of modelist
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
<title>RETURNS</title>
<para>
   struct fb_videomode, NULL if none found
</para>
</refsect1>
<refsect1>
<title>IMPORTANT</title>
<para>
   This function assumes that all modelist entries in
   info-&gt;modelist are valid.
</para>
</refsect1>
<refsect1>
<title>NOTES</title>
<para>
   Finds best matching videomode which has an equal or greater dimension than
   var-&gt;xres and var-&gt;yres.  If more than 1 videomode is found, will return
   the videomode with the highest refresh rate
</para>
</refsect1>
</refentry>

<refentry id="API-fb-find-nearest-mode">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>July 2015</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>fb_find_nearest_mode</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.4.104</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>fb_find_nearest_mode</refname>
 <refpurpose>
     find closest videomode
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>const struct fb_videomode * <function>fb_find_nearest_mode </function></funcdef>
   <paramdef>const struct fb_videomode * <parameter>mode</parameter></paramdef>
   <paramdef>struct list_head * <parameter>head</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>mode</parameter></term>
   <listitem>
    <para>
     pointer to struct fb_videomode
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>head</parameter></term>
   <listitem>
    <para>
     pointer to modelist
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
<title>Description</title>
<para>
   Finds best matching videomode, smaller or greater in dimension.
   If more than 1 videomode is found, will return the videomode with
   the closest refresh rate.
</para>
</refsect1>
</refentry>

<refentry id="API-fb-match-mode">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>July 2015</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>fb_match_mode</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.4.104</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>fb_match_mode</refname>
 <refpurpose>
     find a videomode which exactly matches the timings in var
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>const struct fb_videomode * <function>fb_match_mode </function></funcdef>
   <paramdef>const struct fb_var_screeninfo * <parameter>var</parameter></paramdef>
   <paramdef>struct list_head * <parameter>head</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>var</parameter></term>
   <listitem>
    <para>
     pointer to struct fb_var_screeninfo
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>head</parameter></term>
   <listitem>
    <para>
     pointer to struct list_head of modelist
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
<title>RETURNS</title>
<para>
   struct fb_videomode, NULL if none found
</para>
</refsect1>
</refentry>

<refentry id="API-fb-add-videomode">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>July 2015</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>fb_add_videomode</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.4.104</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>fb_add_videomode</refname>
 <refpurpose>
     adds videomode entry to modelist
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>int <function>fb_add_videomode </function></funcdef>
   <paramdef>const struct fb_videomode * <parameter>mode</parameter></paramdef>
   <paramdef>struct list_head * <parameter>head</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>mode</parameter></term>
   <listitem>
    <para>
     videomode to add
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>head</parameter></term>
   <listitem>
    <para>
     struct list_head of modelist
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
<title>NOTES</title>
<para>
   Will only add unmatched mode entries
</para>
</refsect1>
</refentry>

<refentry id="API-fb-destroy-modelist">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>July 2015</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>fb_destroy_modelist</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.4.104</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>fb_destroy_modelist</refname>
 <refpurpose>
     destroy modelist
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>void <function>fb_destroy_modelist </function></funcdef>
   <paramdef>struct list_head * <parameter>head</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>head</parameter></term>
   <listitem>
    <para>
     struct list_head of modelist
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
</refentry>

<refentry id="API-fb-videomode-to-modelist">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>July 2015</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>fb_videomode_to_modelist</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.4.104</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>fb_videomode_to_modelist</refname>
 <refpurpose>
     convert mode array to mode list
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>void <function>fb_videomode_to_modelist </function></funcdef>
   <paramdef>const struct fb_videomode * <parameter>modedb</parameter></paramdef>
   <paramdef>int <parameter>num</parameter></paramdef>
   <paramdef>struct list_head * <parameter>head</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>modedb</parameter></term>
   <listitem>
    <para>
     array of struct fb_videomode
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>num</parameter></term>
   <listitem>
    <para>
     number of entries in array
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>head</parameter></term>
   <listitem>
    <para>
     struct list_head of modelist
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
</refentry>

     </sect1>
     <sect1><title>Frame Buffer Macintosh Video Mode Database</title>
<!-- drivers/video/macmodes.c -->
<refentry id="API-mac-vmode-to-var">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>July 2015</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>mac_vmode_to_var</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.4.104</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>mac_vmode_to_var</refname>
 <refpurpose>
  converts vmode/cmode pair to var structure
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>int <function>mac_vmode_to_var </function></funcdef>
   <paramdef>int <parameter>vmode</parameter></paramdef>
   <paramdef>int <parameter>cmode</parameter></paramdef>
   <paramdef>struct fb_var_screeninfo * <parameter>var</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>vmode</parameter></term>
   <listitem>
    <para>
     MacOS video mode
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>cmode</parameter></term>
   <listitem>
    <para>
     MacOS color mode
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>var</parameter></term>
   <listitem>
    <para>
     frame buffer video mode structure
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
<title>Description</title>
<para>
   Converts a MacOS vmode/cmode pair to a frame buffer video
   mode structure.
   </para><para>

   Returns negative errno on error, or zero for success.
</para>
</refsect1>
</refentry>

<refentry id="API-mac-map-monitor-sense">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>July 2015</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>mac_map_monitor_sense</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.4.104</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>mac_map_monitor_sense</refname>
 <refpurpose>
     Convert monitor sense to vmode
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>int <function>mac_map_monitor_sense </function></funcdef>
   <paramdef>int <parameter>sense</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>sense</parameter></term>
   <listitem>
    <para>
     Macintosh monitor sense number
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
<title>Description</title>
<para>
   Converts a Macintosh monitor sense number to a MacOS
   vmode number.
   </para><para>

   Returns MacOS vmode video mode number.
</para>
</refsect1>
</refentry>

<refentry id="API-mac-find-mode">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>July 2015</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>mac_find_mode</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.4.104</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>mac_find_mode</refname>
 <refpurpose>
     find a video mode
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>int <function>mac_find_mode </function></funcdef>
   <paramdef>struct fb_var_screeninfo * <parameter>var</parameter></paramdef>
   <paramdef>struct fb_info * <parameter>info</parameter></paramdef>
   <paramdef>const char * <parameter>mode_option</parameter></paramdef>
   <paramdef>unsigned int <parameter>default_bpp</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>var</parameter></term>
   <listitem>
    <para>
     frame buffer user defined part of display
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>info</parameter></term>
   <listitem>
    <para>
     frame buffer info structure
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>mode_option</parameter></term>
   <listitem>
    <para>
     video mode name (see mac_modedb[])
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>default_bpp</parameter></term>
   <listitem>
    <para>
     default color depth in bits per pixel
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
<title>Description</title>
<para>
   Finds a suitable video mode.  Tries to set mode specified
   by <parameter>mode_option</parameter>.  If the name of the wanted mode begins with
   'mac', the Mac video mode database will be used, otherwise it
   will fall back to the standard video mode database.
</para>
</refsect1>
<refsect1>
<title>Note</title>
<para>
   Function marked as __init and can only be used during
   system boot.
   </para><para>

   Returns error code from fb_find_mode (see fb_find_mode
   function).
</para>
</refsect1>
</refentry>

     </sect1>
     <sect1><title>Frame Buffer Fonts</title>
        <para>
           Refer to the file drivers/video/console/fonts.c for more information.
        </para>
<!-- FIXME: Removed for now since no structured comments in source
X!Idrivers/video/console/fonts.c
-->
     </sect1>
  </chapter>

  <chapter id="input_subsystem">
     <title>Input Subsystem</title>
     <sect1><title>Input core</title>
<!-- include/linux/input.h -->
<refentry id="API-struct-input-absinfo">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>July 2015</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>struct input_absinfo</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.4.104</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>struct input_absinfo</refname>
 <refpurpose>
  used by EVIOCGABS/EVIOCSABS ioctls
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <programlisting>
struct input_absinfo {
  __s32 value;
  __s32 minimum;
  __s32 maximum;
  __s32 fuzz;
  __s32 flat;
  __s32 resolution;
};  </programlisting>
</refsynopsisdiv>
 <refsect1>
  <title>Members</title>
  <variablelist>
    <varlistentry>      <term>value</term>
      <listitem><para>
latest reported value for the axis.
      </para></listitem>
    </varlistentry>
    <varlistentry>      <term>minimum</term>
      <listitem><para>
specifies minimum value for the axis.
      </para></listitem>
    </varlistentry>
    <varlistentry>      <term>maximum</term>
      <listitem><para>
specifies maximum value for the axis.
      </para></listitem>
    </varlistentry>
    <varlistentry>      <term>fuzz</term>
      <listitem><para>
specifies fuzz value that is used to filter noise from
the event stream.
      </para></listitem>
    </varlistentry>
    <varlistentry>      <term>flat</term>
      <listitem><para>
values that are within this value will be discarded by
joydev interface and reported as 0 instead.
      </para></listitem>
    </varlistentry>
    <varlistentry>      <term>resolution</term>
      <listitem><para>
specifies resolution for the values reported for
the axis.
      </para></listitem>
    </varlistentry>
  </variablelist>
 </refsect1>
<refsect1>
<title>Description</title>
<para>
   Note that input core does not clamp reported values to the
   [minimum, maximum] limits, such task is left to userspace.
   </para><para>

   Resolution for main axes (ABS_X, ABS_Y, ABS_Z) is reported in
   units per millimeter (units/mm), resolution for rotational axes
   (ABS_RX, ABS_RY, ABS_RZ) is reported in units per radian.
</para>
</refsect1>
</refentry>

<refentry id="API-struct-input-keymap-entry">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>July 2015</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>struct input_keymap_entry</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.4.104</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>struct input_keymap_entry</refname>
 <refpurpose>
     used by EVIOCGKEYCODE/EVIOCSKEYCODE ioctls
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <programlisting>
struct input_keymap_entry {
#define INPUT_KEYMAP_BY_INDEX	(1 &lt;&lt; 0)
  __u8 flags;
  __u8 len;
  __u16 index;
  __u32 keycode;
  __u8 scancode[32];
};  </programlisting>
</refsynopsisdiv>
 <refsect1>
  <title>Members</title>
  <variablelist>
    <varlistentry>      <term>flags</term>
      <listitem><para>
   allows to specify how kernel should handle the request. For
   example, setting INPUT_KEYMAP_BY_INDEX flag indicates that kernel
   should perform lookup in keymap by <parameter>index</parameter> instead of <parameter>scancode</parameter>
      </para></listitem>
    </varlistentry>
    <varlistentry>      <term>len</term>
      <listitem><para>
   length of the scancode that resides in <parameter>scancode</parameter> buffer.
      </para></listitem>
    </varlistentry>
    <varlistentry>      <term>index</term>
      <listitem><para>
   index in the keymap, may be used instead of scancode
      </para></listitem>
    </varlistentry>
    <varlistentry>      <term>keycode</term>
      <listitem><para>
   key code assigned to this scancode
      </para></listitem>
    </varlistentry>
    <varlistentry>      <term>scancode[32]</term>
      <listitem><para>
   scancode represented in machine-endian form.
      </para></listitem>
    </varlistentry>
  </variablelist>
 </refsect1>
<refsect1>
<title>Description</title>
<para>
   The structure is used to retrieve and modify keymap data. Users have
   option of performing lookup either by <parameter>scancode</parameter> itself or by <parameter>index</parameter>
   in keymap entry. EVIOCGKEYCODE will also return scancode or index
   (depending on which element was used to perform lookup).
</para>
</refsect1>
</refentry>

<refentry id="API-EVIOCGMTSLOTS">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>July 2015</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>EVIOCGMTSLOTS</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.4.104</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>EVIOCGMTSLOTS</refname>
 <refpurpose>
     get MT slot values
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef> <function>EVIOCGMTSLOTS </function></funcdef>
   <paramdef> <parameter>len</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>len</parameter></term>
   <listitem>
    <para>
     -- undescribed --
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
<title>Description</title>
<para>
   </para><para>

   The ioctl buffer argument should be binary equivalent to
   </para><para>

   struct input_mt_request_layout {
   __u32 code;
   __s32 values[num_slots];
   };
   </para><para>

   where num_slots is the (arbitrary) number of MT slots to extract.
   </para><para>

   The ioctl size argument (len) is the size of the buffer, which
   should satisfy len = (num_slots + 1) * sizeof(__s32).  If len is
   too small to fit all available slots, the first num_slots are
   returned.
   </para><para>

   Before the call, code is set to the wanted ABS_MT event type. On
   return, values[] is filled with the slot values for the specified
   ABS_MT code.
   </para><para>

   If the request code is not an ABS_MT value, -EINVAL is returned.
</para>
</refsect1>
</refentry>

<refentry id="API-struct-ff-replay">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>July 2015</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>struct ff_replay</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.4.104</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>struct ff_replay</refname>
 <refpurpose>
     defines scheduling of the force-feedback effect
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <programlisting>
struct ff_replay {
  __u16 length;
  __u16 delay;
};  </programlisting>
</refsynopsisdiv>
 <refsect1>
  <title>Members</title>
  <variablelist>
    <varlistentry>      <term>length</term>
      <listitem><para>
   duration of the effect
      </para></listitem>
    </varlistentry>
    <varlistentry>      <term>delay</term>
      <listitem><para>
   delay before effect should start playing
      </para></listitem>
    </varlistentry>
  </variablelist>
 </refsect1>
</refentry>

<refentry id="API-struct-ff-trigger">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>July 2015</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>struct ff_trigger</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.4.104</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>struct ff_trigger</refname>
 <refpurpose>
     defines what triggers the force-feedback effect
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <programlisting>
struct ff_trigger {
  __u16 button;
  __u16 interval;
};  </programlisting>
</refsynopsisdiv>
 <refsect1>
  <title>Members</title>
  <variablelist>
    <varlistentry>      <term>button</term>
      <listitem><para>
   number of the button triggering the effect
      </para></listitem>
    </varlistentry>
    <varlistentry>      <term>interval</term>
      <listitem><para>
   controls how soon the effect can be re-triggered
      </para></listitem>
    </varlistentry>
  </variablelist>
 </refsect1>
</refentry>

<refentry id="API-struct-ff-envelope">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>July 2015</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>struct ff_envelope</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.4.104</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>struct ff_envelope</refname>
 <refpurpose>
     generic force-feedback effect envelope
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <programlisting>
struct ff_envelope {
  __u16 attack_length;
  __u16 attack_level;
  __u16 fade_length;
  __u16 fade_level;
};  </programlisting>
</refsynopsisdiv>
 <refsect1>
  <title>Members</title>
  <variablelist>
    <varlistentry>      <term>attack_length</term>
      <listitem><para>
   duration of the attack (ms)
      </para></listitem>
    </varlistentry>
    <varlistentry>      <term>attack_level</term>
      <listitem><para>
   level at the beginning of the attack
      </para></listitem>
    </varlistentry>
    <varlistentry>      <term>fade_length</term>
      <listitem><para>
   duration of fade (ms)
      </para></listitem>
    </varlistentry>
    <varlistentry>      <term>fade_level</term>
      <listitem><para>
   level at the end of fade
      </para></listitem>
    </varlistentry>
  </variablelist>
 </refsect1>
<refsect1>
<title>Description</title>
<para>
   The <parameter>attack_level</parameter> and <parameter>fade_level</parameter> are absolute values; when applying
   envelope force-feedback core will convert to positive/negative
   value based on polarity of the default level of the effect.
   Valid range for the attack and fade levels is 0x0000 - 0x7fff
</para>
</refsect1>
</refentry>

<refentry id="API-struct-ff-constant-effect">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>July 2015</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>struct ff_constant_effect</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.4.104</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>struct ff_constant_effect</refname>
 <refpurpose>
     defines parameters of a constant force-feedback effect
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <programlisting>
struct ff_constant_effect {
  __s16 level;
  struct ff_envelope envelope;
};  </programlisting>
</refsynopsisdiv>
 <refsect1>
  <title>Members</title>
  <variablelist>
    <varlistentry>      <term>level</term>
      <listitem><para>
   strength of the effect; may be negative
      </para></listitem>
    </varlistentry>
    <varlistentry>      <term>envelope</term>
      <listitem><para>
   envelope data
      </para></listitem>
    </varlistentry>
  </variablelist>
 </refsect1>
</refentry>

<refentry id="API-struct-ff-ramp-effect">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>July 2015</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>struct ff_ramp_effect</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.4.104</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>struct ff_ramp_effect</refname>
 <refpurpose>
     defines parameters of a ramp force-feedback effect
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <programlisting>
struct ff_ramp_effect {
  __s16 start_level;
  __s16 end_level;
  struct ff_envelope envelope;
};  </programlisting>
</refsynopsisdiv>
 <refsect1>
  <title>Members</title>
  <variablelist>
    <varlistentry>      <term>start_level</term>
      <listitem><para>
   beginning strength of the effect; may be negative
      </para></listitem>
    </varlistentry>
    <varlistentry>      <term>end_level</term>
      <listitem><para>
   final strength of the effect; may be negative
      </para></listitem>
    </varlistentry>
    <varlistentry>      <term>envelope</term>
      <listitem><para>
   envelope data
      </para></listitem>
    </varlistentry>
  </variablelist>
 </refsect1>
</refentry>

<refentry id="API-struct-ff-condition-effect">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>July 2015</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>struct ff_condition_effect</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.4.104</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>struct ff_condition_effect</refname>
 <refpurpose>
     defines a spring or friction force-feedback effect
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <programlisting>
struct ff_condition_effect {
  __u16 right_saturation;
  __u16 left_saturation;
  __s16 right_coeff;
  __s16 left_coeff;
  __u16 deadband;
  __s16 center;
};  </programlisting>
</refsynopsisdiv>
 <refsect1>
  <title>Members</title>
  <variablelist>
    <varlistentry>      <term>right_saturation</term>
      <listitem><para>
   maximum level when joystick moved all way to the right
      </para></listitem>
    </varlistentry>
    <varlistentry>      <term>left_saturation</term>
      <listitem><para>
   same for the left side
      </para></listitem>
    </varlistentry>
    <varlistentry>      <term>right_coeff</term>
      <listitem><para>
   controls how fast the force grows when the joystick moves
   to the right
      </para></listitem>
    </varlistentry>
    <varlistentry>      <term>left_coeff</term>
      <listitem><para>
   same for the left side
      </para></listitem>
    </varlistentry>
    <varlistentry>      <term>deadband</term>
      <listitem><para>
   size of the dead zone, where no force is produced
      </para></listitem>
    </varlistentry>
    <varlistentry>      <term>center</term>
      <listitem><para>
   position of the dead zone
      </para></listitem>
    </varlistentry>
  </variablelist>
 </refsect1>
</refentry>

<refentry id="API-struct-ff-periodic-effect">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>July 2015</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>struct ff_periodic_effect</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.4.104</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>struct ff_periodic_effect</refname>
 <refpurpose>
     defines parameters of a periodic force-feedback effect
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <programlisting>
struct ff_periodic_effect {
  __u16 waveform;
  __u16 period;
  __s16 magnitude;
  __s16 offset;
  __u16 phase;
  struct ff_envelope envelope;
  __u32 custom_len;
  __s16 __user * custom_data;
};  </programlisting>
</refsynopsisdiv>
 <refsect1>
  <title>Members</title>
  <variablelist>
    <varlistentry>      <term>waveform</term>
      <listitem><para>
   kind of the effect (wave)
      </para></listitem>
    </varlistentry>
    <varlistentry>      <term>period</term>
      <listitem><para>
   period of the wave (ms)
      </para></listitem>
    </varlistentry>
    <varlistentry>      <term>magnitude</term>
      <listitem><para>
   peak value
      </para></listitem>
    </varlistentry>
    <varlistentry>      <term>offset</term>
      <listitem><para>
   mean value of the wave (roughly)
      </para></listitem>
    </varlistentry>
    <varlistentry>      <term>phase</term>
      <listitem><para>
   'horizontal' shift
      </para></listitem>
    </varlistentry>
    <varlistentry>      <term>envelope</term>
      <listitem><para>
   envelope data
      </para></listitem>
    </varlistentry>
    <varlistentry>      <term>custom_len</term>
      <listitem><para>
   number of samples (FF_CUSTOM only)
      </para></listitem>
    </varlistentry>
    <varlistentry>      <term>custom_data</term>
      <listitem><para>
   buffer of samples (FF_CUSTOM only)
      </para></listitem>
    </varlistentry>
  </variablelist>
 </refsect1>
<refsect1>
<title>Description</title>
<para>
   Known waveforms - FF_SQUARE, FF_TRIANGLE, FF_SINE, FF_SAW_UP,
   FF_SAW_DOWN, FF_CUSTOM. The exact syntax FF_CUSTOM is undefined
   for the time being as no driver supports it yet.
</para>
</refsect1>
<refsect1>
<title>Note</title>
<para>
   the data pointed by custom_data is copied by the driver.
   You can therefore dispose of the memory after the upload/update.
</para>
</refsect1>
</refentry>

<refentry id="API-struct-ff-rumble-effect">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>July 2015</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>struct ff_rumble_effect</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.4.104</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>struct ff_rumble_effect</refname>
 <refpurpose>
     defines parameters of a periodic force-feedback effect
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <programlisting>
struct ff_rumble_effect {
  __u16 strong_magnitude;
  __u16 weak_magnitude;
};  </programlisting>
</refsynopsisdiv>
 <refsect1>
  <title>Members</title>
  <variablelist>
    <varlistentry>      <term>strong_magnitude</term>
      <listitem><para>
   magnitude of the heavy motor
      </para></listitem>
    </varlistentry>
    <varlistentry>      <term>weak_magnitude</term>
      <listitem><para>
   magnitude of the light one
      </para></listitem>
    </varlistentry>
  </variablelist>
 </refsect1>
<refsect1>
<title>Description</title>
<para>
   Some rumble pads have two motors of different weight. Strong_magnitude
   represents the magnitude of the vibration generated by the heavy one.
</para>
</refsect1>
</refentry>

<refentry id="API-struct-ff-effect">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>July 2015</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>struct ff_effect</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.4.104</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>struct ff_effect</refname>
 <refpurpose>
     defines force feedback effect
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <programlisting>
struct ff_effect {
  __u16 type;
  __s16 id;
  __u16 direction;
  struct ff_trigger trigger;
  struct ff_replay replay;
  union u;
};  </programlisting>
</refsynopsisdiv>
 <refsect1>
  <title>Members</title>
  <variablelist>
    <varlistentry>      <term>type</term>
      <listitem><para>
   type of the effect (FF_CONSTANT, FF_PERIODIC, FF_RAMP, FF_SPRING,
   FF_FRICTION, FF_DAMPER, FF_RUMBLE, FF_INERTIA, or FF_CUSTOM)
      </para></listitem>
    </varlistentry>
    <varlistentry>      <term>id</term>
      <listitem><para>
   an unique id assigned to an effect
      </para></listitem>
    </varlistentry>
    <varlistentry>      <term>direction</term>
      <listitem><para>
   direction of the effect
      </para></listitem>
    </varlistentry>
    <varlistentry>      <term>trigger</term>
      <listitem><para>
   trigger conditions (struct ff_trigger)
      </para></listitem>
    </varlistentry>
    <varlistentry>      <term>replay</term>
      <listitem><para>
   scheduling of the effect (struct ff_replay)
      </para></listitem>
    </varlistentry>
    <varlistentry>      <term>u</term>
      <listitem><para>
   effect-specific structure (one of ff_constant_effect, ff_ramp_effect,
   ff_periodic_effect, ff_condition_effect, ff_rumble_effect) further
   defining effect parameters
      </para></listitem>
    </varlistentry>
  </variablelist>
 </refsect1>
<refsect1>
<title>Description</title>
<para>
   This structure is sent through ioctl from the application to the driver.
   To create a new effect application should set its <parameter>id</parameter> to -1; the kernel
   will return assigned <parameter>id</parameter> which can later be used to update or delete
   this effect.
</para>
</refsect1>
<refsect1>
<title>Direction of the effect is encoded as follows</title>
<para>
   0 deg -&gt; 0x0000 (down)
   90 deg -&gt; 0x4000 (left)
   180 deg -&gt; 0x8000 (up)
   270 deg -&gt; 0xC000 (right)
</para>
</refsect1>
</refentry>

<refentry id="API-struct-input-dev">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>July 2015</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>struct input_dev</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.4.104</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>struct input_dev</refname>
 <refpurpose>
     represents an input device
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <programlisting>
struct input_dev {
  const char * name;
  const char * phys;
  const char * uniq;
  struct input_id id;
  unsigned long propbit[BITS_TO_LONGS(INPUT_PROP_CNT)];
  unsigned long evbit[BITS_TO_LONGS(EV_CNT)];
  unsigned long keybit[BITS_TO_LONGS(KEY_CNT)];
  unsigned long relbit[BITS_TO_LONGS(REL_CNT)];
  unsigned long absbit[BITS_TO_LONGS(ABS_CNT)];
  unsigned long mscbit[BITS_TO_LONGS(MSC_CNT)];
  unsigned long ledbit[BITS_TO_LONGS(LED_CNT)];
  unsigned long sndbit[BITS_TO_LONGS(SND_CNT)];
  unsigned long ffbit[BITS_TO_LONGS(FF_CNT)];
  unsigned long swbit[BITS_TO_LONGS(SW_CNT)];
  unsigned int hint_events_per_packet;
  unsigned int keycodemax;
  unsigned int keycodesize;
  void * keycode;
  int (* setkeycode) (struct input_dev *dev,const struct input_keymap_entry *ke,unsigned int *old_keycode);
  int (* getkeycode) (struct input_dev *dev,struct input_keymap_entry *ke);
  struct ff_device * ff;
  unsigned int repeat_key;
  struct timer_list timer;
  int rep[REP_CNT];
  struct input_mt_slot * mt;
  int mtsize;
  int slot;
  int trkid;
  struct input_absinfo * absinfo;
  unsigned long key[BITS_TO_LONGS(KEY_CNT)];
  unsigned long led[BITS_TO_LONGS(LED_CNT)];
  unsigned long snd[BITS_TO_LONGS(SND_CNT)];
  unsigned long sw[BITS_TO_LONGS(SW_CNT)];
  int (* open) (struct input_dev *dev);
  void (* close) (struct input_dev *dev);
  int (* flush) (struct input_dev *dev, struct file *file);
  int (* event) (struct input_dev *dev, unsigned int type, unsigned int code, int value);
  struct input_handle __rcu * grab;
  spinlock_t event_lock;
  struct mutex mutex;
  unsigned int users;
  bool going_away;
  bool sync;
  struct device dev;
  struct list_head h_list;
  struct list_head node;
};  </programlisting>
</refsynopsisdiv>
 <refsect1>
  <title>Members</title>
  <variablelist>
    <varlistentry>      <term>name</term>
      <listitem><para>
   name of the device
      </para></listitem>
    </varlistentry>
    <varlistentry>      <term>phys</term>
      <listitem><para>
   physical path to the device in the system hierarchy
      </para></listitem>
    </varlistentry>
    <varlistentry>      <term>uniq</term>
      <listitem><para>
   unique identification code for the device (if device has it)
      </para></listitem>
    </varlistentry>
    <varlistentry>      <term>id</term>
      <listitem><para>
   id of the device (struct input_id)
      </para></listitem>
    </varlistentry>
    <varlistentry>      <term>propbit[BITS_TO_LONGS(INPUT_PROP_CNT)]</term>
      <listitem><para>
   bitmap of device properties and quirks
      </para></listitem>
    </varlistentry>
    <varlistentry>      <term>evbit[BITS_TO_LONGS(EV_CNT)]</term>
      <listitem><para>
   bitmap of types of events supported by the device (EV_KEY,
   EV_REL, etc.)
      </para></listitem>
    </varlistentry>
    <varlistentry>      <term>keybit[BITS_TO_LONGS(KEY_CNT)]</term>
      <listitem><para>
   bitmap of keys/buttons this device has
      </para></listitem>
    </varlistentry>
    <varlistentry>      <term>relbit[BITS_TO_LONGS(REL_CNT)]</term>
      <listitem><para>
   bitmap of relative axes for the device
      </para></listitem>
    </varlistentry>
    <varlistentry>      <term>absbit[BITS_TO_LONGS(ABS_CNT)]</term>
      <listitem><para>
   bitmap of absolute axes for the device
      </para></listitem>
    </varlistentry>
    <varlistentry>      <term>mscbit[BITS_TO_LONGS(MSC_CNT)]</term>
      <listitem><para>
   bitmap of miscellaneous events supported by the device
      </para></listitem>
    </varlistentry>
    <varlistentry>      <term>ledbit[BITS_TO_LONGS(LED_CNT)]</term>
      <listitem><para>
   bitmap of leds present on the device
      </para></listitem>
    </varlistentry>
    <varlistentry>      <term>sndbit[BITS_TO_LONGS(SND_CNT)]</term>
      <listitem><para>
   bitmap of sound effects supported by the device
      </para></listitem>
    </varlistentry>
    <varlistentry>      <term>ffbit[BITS_TO_LONGS(FF_CNT)]</term>
      <listitem><para>
   bitmap of force feedback effects supported by the device
      </para></listitem>
    </varlistentry>
    <varlistentry>      <term>swbit[BITS_TO_LONGS(SW_CNT)]</term>
      <listitem><para>
   bitmap of switches present on the device
      </para></listitem>
    </varlistentry>
    <varlistentry>      <term>hint_events_per_packet</term>
      <listitem><para>
   average number of events generated by the
   device in a packet (between EV_SYN/SYN_REPORT events). Used by
   event handlers to estimate size of the buffer needed to hold
   events.
      </para></listitem>
    </varlistentry>
    <varlistentry>      <term>keycodemax</term>
      <listitem><para>
   size of keycode table
      </para></listitem>
    </varlistentry>
    <varlistentry>      <term>keycodesize</term>
      <listitem><para>
   size of elements in keycode table
      </para></listitem>
    </varlistentry>
    <varlistentry>      <term>keycode</term>
      <listitem><para>
   map of scancodes to keycodes for this device
      </para></listitem>
    </varlistentry>
    <varlistentry>      <term>setkeycode</term>
      <listitem><para>
   optional method to alter current keymap, used to implement
   sparse keymaps. If not supplied default mechanism will be used.
   The method is being called while holding event_lock and thus must
   not sleep
      </para></listitem>
    </varlistentry>
    <varlistentry>      <term>getkeycode</term>
      <listitem><para>
   optional legacy method to retrieve current keymap.
      </para></listitem>
    </varlistentry>
    <varlistentry>      <term>ff</term>
      <listitem><para>
   force feedback structure associated with the device if device
   supports force feedback effects
      </para></listitem>
    </varlistentry>
    <varlistentry>      <term>repeat_key</term>
      <listitem><para>
   stores key code of the last key pressed; used to implement
   software autorepeat
      </para></listitem>
    </varlistentry>
    <varlistentry>      <term>timer</term>
      <listitem><para>
   timer for software autorepeat
      </para></listitem>
    </varlistentry>
    <varlistentry>      <term>rep[REP_CNT]</term>
      <listitem><para>
   current values for autorepeat parameters (delay, rate)
      </para></listitem>
    </varlistentry>
    <varlistentry>      <term>mt</term>
      <listitem><para>
   pointer to array of struct input_mt_slot holding current values
   of tracked contacts
      </para></listitem>
    </varlistentry>
    <varlistentry>      <term>mtsize</term>
      <listitem><para>
   number of MT slots the device uses
      </para></listitem>
    </varlistentry>
    <varlistentry>      <term>slot</term>
      <listitem><para>
   MT slot currently being transmitted
      </para></listitem>
    </varlistentry>
    <varlistentry>      <term>trkid</term>
      <listitem><para>
   stores MT tracking ID for the current contact
      </para></listitem>
    </varlistentry>
    <varlistentry>      <term>absinfo</term>
      <listitem><para>
   array of <structname>struct input_absinfo</structname> elements holding information
   about absolute axes (current value, min, max, flat, fuzz,
   resolution)
      </para></listitem>
    </varlistentry>
    <varlistentry>      <term>key[BITS_TO_LONGS(KEY_CNT)]</term>
      <listitem><para>
   reflects current state of device's keys/buttons
      </para></listitem>
    </varlistentry>
    <varlistentry>      <term>led[BITS_TO_LONGS(LED_CNT)]</term>
      <listitem><para>
   reflects current state of device's LEDs
      </para></listitem>
    </varlistentry>
    <varlistentry>      <term>snd[BITS_TO_LONGS(SND_CNT)]</term>
      <listitem><para>
   reflects current state of sound effects
      </para></listitem>
    </varlistentry>
    <varlistentry>      <term>sw[BITS_TO_LONGS(SW_CNT)]</term>
      <listitem><para>
   reflects current state of device's switches
      </para></listitem>
    </varlistentry>
    <varlistentry>      <term>open</term>
      <listitem><para>
   this method is called when the very first user calls
   <function>input_open_device</function>. The driver must prepare the device
   to start generating events (start polling thread,
   request an IRQ, submit URB, etc.)
      </para></listitem>
    </varlistentry>
    <varlistentry>      <term>close</term>
      <listitem><para>
   this method is called when the very last user calls
   <function>input_close_device</function>.
      </para></listitem>
    </varlistentry>
    <varlistentry>      <term>flush</term>
      <listitem><para>
   purges the device. Most commonly used to get rid of force
   feedback effects loaded into the device when disconnecting
   from it
      </para></listitem>
    </varlistentry>
    <varlistentry>      <term>event</term>
      <listitem><para>
   event handler for events sent _to_ the device, like EV_LED
   or EV_SND. The device is expected to carry out the requested
   action (turn on a LED, play sound, etc.) The call is protected
   by <parameter>event_lock</parameter> and must not sleep
      </para></listitem>
    </varlistentry>
    <varlistentry>      <term>grab</term>
      <listitem><para>
   input handle that currently has the device grabbed (via
   EVIOCGRAB ioctl). When a handle grabs a device it becomes sole
   recipient for all input events coming from the device
      </para></listitem>
    </varlistentry>
    <varlistentry>      <term>event_lock</term>
      <listitem><para>
   this spinlock is is taken when input core receives
   and processes a new event for the device (in <function>input_event</function>).
   Code that accesses and/or modifies parameters of a device
   (such as keymap or absmin, absmax, absfuzz, etc.) after device
   has been registered with input core must take this lock.
      </para></listitem>
    </varlistentry>
    <varlistentry>      <term>mutex</term>
      <listitem><para>
   serializes calls to <function>open</function>, <function>close</function> and <function>flush</function> methods
      </para></listitem>
    </varlistentry>
    <varlistentry>      <term>users</term>
      <listitem><para>
   stores number of users (input handlers) that opened this
   device. It is used by <function>input_open_device</function> and <function>input_close_device</function>
   to make sure that dev-&gt;<function>open</function> is only called when the first
   user opens device and dev-&gt;<function>close</function> is called when the very
   last user closes the device
      </para></listitem>
    </varlistentry>
    <varlistentry>      <term>going_away</term>
      <listitem><para>
   marks devices that are in a middle of unregistering and
   causes input_open_device*() fail with -ENODEV.
      </para></listitem>
    </varlistentry>
    <varlistentry>      <term>sync</term>
      <listitem><para>
   set to <constant>true</constant> when there were no new events since last EV_SYN
      </para></listitem>
    </varlistentry>
    <varlistentry>      <term>dev</term>
      <listitem><para>
   driver model's view of this device
      </para></listitem>
    </varlistentry>
    <varlistentry>      <term>h_list</term>
      <listitem><para>
   list of input handles associated with the device. When
   accessing the list dev-&gt;mutex must be held
      </para></listitem>
    </varlistentry>
    <varlistentry>      <term>node</term>
      <listitem><para>
   used to place the device onto input_dev_list
      </para></listitem>
    </varlistentry>
  </variablelist>
 </refsect1>
</refentry>

<refentry id="API-struct-input-handler">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>July 2015</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>struct input_handler</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.4.104</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>struct input_handler</refname>
 <refpurpose>
     implements one of interfaces for input devices
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <programlisting>
struct input_handler {
  void * private;
  void (* event) (struct input_handle *handle, unsigned int type, unsigned int code, int value);
  bool (* filter) (struct input_handle *handle, unsigned int type, unsigned int code, int value);
  bool (* match) (struct input_handler *handler, struct input_dev *dev);
  int (* connect) (struct input_handler *handler, struct input_dev *dev, const struct input_device_id *id);
  void (* disconnect) (struct input_handle *handle);
  void (* start) (struct input_handle *handle);
  const struct file_operations * fops;
  int minor;
  const char * name;
  const struct input_device_id * id_table;
  struct list_head h_list;
  struct list_head node;
};  </programlisting>
</refsynopsisdiv>
 <refsect1>
  <title>Members</title>
  <variablelist>
    <varlistentry>      <term>private</term>
      <listitem><para>
   driver-specific data
      </para></listitem>
    </varlistentry>
    <varlistentry>      <term>event</term>
      <listitem><para>
   event handler. This method is being called by input core with
   interrupts disabled and dev-&gt;event_lock spinlock held and so
   it may not sleep
      </para></listitem>
    </varlistentry>
    <varlistentry>      <term>filter</term>
      <listitem><para>
   similar to <parameter>event</parameter>; separates normal event handlers from
   <quote>filters</quote>.
      </para></listitem>
    </varlistentry>
    <varlistentry>      <term>match</term>
      <listitem><para>
   called after comparing device's id with handler's id_table
   to perform fine-grained matching between device and handler
      </para></listitem>
    </varlistentry>
    <varlistentry>      <term>connect</term>
      <listitem><para>
   called when attaching a handler to an input device
      </para></listitem>
    </varlistentry>
    <varlistentry>      <term>disconnect</term>
      <listitem><para>
   disconnects a handler from input device
      </para></listitem>
    </varlistentry>
    <varlistentry>      <term>start</term>
      <listitem><para>
   starts handler for given handle. This function is called by
   input core right after <function>connect</function> method and also when a process
   that <quote>grabbed</quote> a device releases it
      </para></listitem>
    </varlistentry>
    <varlistentry>      <term>fops</term>
      <listitem><para>
   file operations this driver implements
      </para></listitem>
    </varlistentry>
    <varlistentry>      <term>minor</term>
      <listitem><para>
   beginning of range of 32 minors for devices this driver
   can provide
      </para></listitem>
    </varlistentry>
    <varlistentry>      <term>name</term>
      <listitem><para>
   name of the handler, to be shown in /proc/bus/input/handlers
      </para></listitem>
    </varlistentry>
    <varlistentry>      <term>id_table</term>
      <listitem><para>
   pointer to a table of input_device_ids this driver can
   handle
      </para></listitem>
    </varlistentry>
    <varlistentry>      <term>h_list</term>
      <listitem><para>
   list of input handles associated with the handler
      </para></listitem>
    </varlistentry>
    <varlistentry>      <term>node</term>
      <listitem><para>
   for placing the driver onto input_handler_list
      </para></listitem>
    </varlistentry>
  </variablelist>
 </refsect1>
<refsect1>
<title>Description</title>
<para>
   Input handlers attach to input devices and create input handles. There
   are likely several handlers attached to any given input device at the
   same time. All of them will get their copy of input event generated by
   the device.
   </para><para>

   The very same structure is used to implement input filters. Input core
   allows filters to run first and will not pass event to regular handlers
   if any of the filters indicate that the event should be filtered (by
   returning <constant>true</constant> from their <function>filter</function> method).
   </para><para>

   Note that input core serializes calls to <function>connect</function> and <function>disconnect</function>
   methods.
</para>
</refsect1>
</refentry>

<refentry id="API-struct-input-handle">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>July 2015</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>struct input_handle</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.4.104</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>struct input_handle</refname>
 <refpurpose>
     links input device with an input handler
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <programlisting>
struct input_handle {
  void * private;
  int open;
  const char * name;
  struct input_dev * dev;
  struct input_handler * handler;
  struct list_head d_node;
  struct list_head h_node;
};  </programlisting>
</refsynopsisdiv>
 <refsect1>
  <title>Members</title>
  <variablelist>
    <varlistentry>      <term>private</term>
      <listitem><para>
   handler-specific data
      </para></listitem>
    </varlistentry>
    <varlistentry>      <term>open</term>
      <listitem><para>
   counter showing whether the handle is 'open', i.e. should deliver
   events from its device
      </para></listitem>
    </varlistentry>
    <varlistentry>      <term>name</term>
      <listitem><para>
   name given to the handle by handler that created it
      </para></listitem>
    </varlistentry>
    <varlistentry>      <term>dev</term>
      <listitem><para>
   input device the handle is attached to
      </para></listitem>
    </varlistentry>
    <varlistentry>      <term>handler</term>
      <listitem><para>
   handler that works with the device through this handle
      </para></listitem>
    </varlistentry>
    <varlistentry>      <term>d_node</term>
      <listitem><para>
   used to put the handle on device's list of attached handles
      </para></listitem>
    </varlistentry>
    <varlistentry>      <term>h_node</term>
      <listitem><para>
   used to put the handle on handler's list of handles from which
   it gets events
      </para></listitem>
    </varlistentry>
  </variablelist>
 </refsect1>
</refentry>

<refentry id="API-input-set-events-per-packet">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>July 2015</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>input_set_events_per_packet</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.4.104</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>input_set_events_per_packet</refname>
 <refpurpose>
     tell handlers about the driver event rate
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>void <function>input_set_events_per_packet </function></funcdef>
   <paramdef>struct input_dev * <parameter>dev</parameter></paramdef>
   <paramdef>int <parameter>n_events</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>dev</parameter></term>
   <listitem>
    <para>
     the input device used by the driver
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>n_events</parameter></term>
   <listitem>
    <para>
     the average number of events between calls to <function>input_sync</function>
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
<title>Description</title>
<para>
   If the event rate sent from a device is unusually large, use this
   function to set the expected event rate. This will allow handlers
   to set up an appropriate buffer size for the event stream, in order
   to minimize information loss.
</para>
</refsect1>
</refentry>

<refentry id="API-struct-ff-device">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>July 2015</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>struct ff_device</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.4.104</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>struct ff_device</refname>
 <refpurpose>
     force-feedback part of an input device
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <programlisting>
struct ff_device {
  int (* upload) (struct input_dev *dev, struct ff_effect *effect,struct ff_effect *old);
  int (* erase) (struct input_dev *dev, int effect_id);
  int (* playback) (struct input_dev *dev, int effect_id, int value);
  void (* set_gain) (struct input_dev *dev, u16 gain);
  void (* set_autocenter) (struct input_dev *dev, u16 magnitude);
  void (* destroy) (struct ff_device *);
  void * private;
  unsigned long ffbit[BITS_TO_LONGS(FF_CNT)];
  struct mutex mutex;
  int max_effects;
  struct ff_effect * effects;
  struct file * effect_owners[];
};  </programlisting>
</refsynopsisdiv>
 <refsect1>
  <title>Members</title>
  <variablelist>
    <varlistentry>      <term>upload</term>
      <listitem><para>
   Called to upload an new effect into device
      </para></listitem>
    </varlistentry>
    <varlistentry>      <term>erase</term>
      <listitem><para>
   Called to erase an effect from device
      </para></listitem>
    </varlistentry>
    <varlistentry>      <term>playback</term>
      <listitem><para>
   Called to request device to start playing specified effect
      </para></listitem>
    </varlistentry>
    <varlistentry>      <term>set_gain</term>
      <listitem><para>
   Called to set specified gain
      </para></listitem>
    </varlistentry>
    <varlistentry>      <term>set_autocenter</term>
      <listitem><para>
   Called to auto-center device
      </para></listitem>
    </varlistentry>
    <varlistentry>      <term>destroy</term>
      <listitem><para>
   called by input core when parent input device is being
   destroyed
      </para></listitem>
    </varlistentry>
    <varlistentry>      <term>private</term>
      <listitem><para>
   driver-specific data, will be freed automatically
      </para></listitem>
    </varlistentry>
    <varlistentry>      <term>ffbit[BITS_TO_LONGS(FF_CNT)]</term>
      <listitem><para>
   bitmap of force feedback capabilities truly supported by
   device (not emulated like ones in input_dev-&gt;ffbit)
      </para></listitem>
    </varlistentry>
    <varlistentry>      <term>mutex</term>
      <listitem><para>
   mutex for serializing access to the device
      </para></listitem>
    </varlistentry>
    <varlistentry>      <term>max_effects</term>
      <listitem><para>
   maximum number of effects supported by device
      </para></listitem>
    </varlistentry>
    <varlistentry>      <term>effects</term>
      <listitem><para>
   pointer to an array of effects currently loaded into device
      </para></listitem>
    </varlistentry>
    <varlistentry>      <term>effect_owners[]</term>
      <listitem><para>
   array of effect owners; when file handle owning
   an effect gets closed the effect is automatically erased
      </para></listitem>
    </varlistentry>
  </variablelist>
 </refsect1>
<refsect1>
<title>Description</title>
<para>
   Every force-feedback device must implement <function>upload</function> and <function>playback</function>
   methods; <function>erase</function> is optional. <function>set_gain</function> and <function>set_autocenter</function> need
   only be implemented if driver sets up FF_GAIN and FF_AUTOCENTER
   bits.
   </para><para>

   Note that <function>playback</function>, <function>set_gain</function> and <function>set_autocenter</function> are called with
   dev-&gt;event_lock spinlock held and interrupts off and thus may not
   sleep.
</para>
</refsect1>
</refentry>

<!-- drivers/input/input.c -->
<refentry id="API-input-event">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>July 2015</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>input_event</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.4.104</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>input_event</refname>
 <refpurpose>
  report new input event
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>void <function>input_event </function></funcdef>
   <paramdef>struct input_dev * <parameter>dev</parameter></paramdef>
   <paramdef>unsigned int <parameter>type</parameter></paramdef>
   <paramdef>unsigned int <parameter>code</parameter></paramdef>
   <paramdef>int <parameter>value</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>dev</parameter></term>
   <listitem>
    <para>
     device that generated the event
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>type</parameter></term>
   <listitem>
    <para>
     type of the event
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>code</parameter></term>
   <listitem>
    <para>
     event code
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>value</parameter></term>
   <listitem>
    <para>
     value of the event
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
<title>Description</title>
<para>
   This function should be used by drivers implementing various input
   devices to report input events. See also <function>input_inject_event</function>.
</para>
</refsect1>
<refsect1>
<title>NOTE</title>
<para>
   <function>input_event</function> may be safely used right after input device was
   allocated with <function>input_allocate_device</function>, even before it is registered
   with <function>input_register_device</function>, but the event will not reach any of the
   input handlers. Such early invocation of <function>input_event</function> may be used
   to 'seed' initial state of a switch or initial position of absolute
   axis, etc.
</para>
</refsect1>
</refentry>

<refentry id="API-input-inject-event">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>July 2015</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>input_inject_event</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.4.104</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>input_inject_event</refname>
 <refpurpose>
     send input event from input handler
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>void <function>input_inject_event </function></funcdef>
   <paramdef>struct input_handle * <parameter>handle</parameter></paramdef>
   <paramdef>unsigned int <parameter>type</parameter></paramdef>
   <paramdef>unsigned int <parameter>code</parameter></paramdef>
   <paramdef>int <parameter>value</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>handle</parameter></term>
   <listitem>
    <para>
     input handle to send event through
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>type</parameter></term>
   <listitem>
    <para>
     type of the event
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>code</parameter></term>
   <listitem>
    <para>
     event code
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>value</parameter></term>
   <listitem>
    <para>
     value of the event
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
<title>Description</title>
<para>
   Similar to <function>input_event</function> but will ignore event if device is
   <quote>grabbed</quote> and handle injecting event is not the one that owns
   the device.
</para>
</refsect1>
</refentry>

<refentry id="API-input-alloc-absinfo">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>July 2015</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>input_alloc_absinfo</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.4.104</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>input_alloc_absinfo</refname>
 <refpurpose>
     allocates array of input_absinfo structs
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>void <function>input_alloc_absinfo </function></funcdef>
   <paramdef>struct input_dev * <parameter>dev</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>dev</parameter></term>
   <listitem>
    <para>
     the input device emitting absolute events
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
<title>Description</title>
<para>
   If the absinfo struct the caller asked for is already allocated, this
   functions will not do anything.
</para>
</refsect1>
</refentry>

<refentry id="API-input-grab-device">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>July 2015</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>input_grab_device</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.4.104</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>input_grab_device</refname>
 <refpurpose>
     grabs device for exclusive use
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>int <function>input_grab_device </function></funcdef>
   <paramdef>struct input_handle * <parameter>handle</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>handle</parameter></term>
   <listitem>
    <para>
     input handle that wants to own the device
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
<title>Description</title>
<para>
   When a device is grabbed by an input handle all events generated by
   the device are delivered only to this handle. Also events injected
   by other input handles are ignored while device is grabbed.
</para>
</refsect1>
</refentry>

<refentry id="API-input-release-device">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>July 2015</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>input_release_device</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.4.104</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>input_release_device</refname>
 <refpurpose>
     release previously grabbed device
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>void <function>input_release_device </function></funcdef>
   <paramdef>struct input_handle * <parameter>handle</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>handle</parameter></term>
   <listitem>
    <para>
     input handle that owns the device
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
<title>Description</title>
<para>
   Releases previously grabbed device so that other input handles can
   start receiving input events. Upon release all handlers attached
   to the device have their <function>start</function> method called so they have a change
   to synchronize device state with the rest of the system.
</para>
</refsect1>
</refentry>

<refentry id="API-input-open-device">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>July 2015</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>input_open_device</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.4.104</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>input_open_device</refname>
 <refpurpose>
     open input device
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>int <function>input_open_device </function></funcdef>
   <paramdef>struct input_handle * <parameter>handle</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>handle</parameter></term>
   <listitem>
    <para>
     handle through which device is being accessed
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
<title>Description</title>
<para>
   This function should be called by input handlers when they
   want to start receive events from given input device.
</para>
</refsect1>
</refentry>

<refentry id="API-input-close-device">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>July 2015</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>input_close_device</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.4.104</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>input_close_device</refname>
 <refpurpose>
     close input device
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>void <function>input_close_device </function></funcdef>
   <paramdef>struct input_handle * <parameter>handle</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>handle</parameter></term>
   <listitem>
    <para>
     handle through which device is being accessed
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
<title>Description</title>
<para>
   This function should be called by input handlers when they
   want to stop receive events from given input device.
</para>
</refsect1>
</refentry>

<refentry id="API-input-scancode-to-scalar">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>July 2015</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>input_scancode_to_scalar</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.4.104</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>input_scancode_to_scalar</refname>
 <refpurpose>
     converts scancode in <structname>struct input_keymap_entry</structname>
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>int <function>input_scancode_to_scalar </function></funcdef>
   <paramdef>const struct input_keymap_entry * <parameter>ke</parameter></paramdef>
   <paramdef>unsigned int * <parameter>scancode</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>ke</parameter></term>
   <listitem>
    <para>
     keymap entry containing scancode to be converted.
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>scancode</parameter></term>
   <listitem>
    <para>
     pointer to the location where converted scancode should
     be stored.
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
<title>Description</title>
<para>
   This function is used to convert scancode stored in <structname>struct keymap_entry</structname>
   into scalar form understood by legacy keymap handling methods. These
   methods expect scancodes to be represented as 'unsigned int'.
</para>
</refsect1>
</refentry>

<refentry id="API-input-get-keycode">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>July 2015</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>input_get_keycode</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.4.104</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>input_get_keycode</refname>
 <refpurpose>
     retrieve keycode currently mapped to a given scancode
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>int <function>input_get_keycode </function></funcdef>
   <paramdef>struct input_dev * <parameter>dev</parameter></paramdef>
   <paramdef>struct input_keymap_entry * <parameter>ke</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>dev</parameter></term>
   <listitem>
    <para>
     input device which keymap is being queried
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>ke</parameter></term>
   <listitem>
    <para>
     keymap entry
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
<title>Description</title>
<para>
   This function should be called by anyone interested in retrieving current
   keymap. Presently evdev handlers use it.
</para>
</refsect1>
</refentry>

<refentry id="API-input-set-keycode">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>July 2015</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>input_set_keycode</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.4.104</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>input_set_keycode</refname>
 <refpurpose>
     attribute a keycode to a given scancode
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>int <function>input_set_keycode </function></funcdef>
   <paramdef>struct input_dev * <parameter>dev</parameter></paramdef>
   <paramdef>const struct input_keymap_entry * <parameter>ke</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>dev</parameter></term>
   <listitem>
    <para>
     input device which keymap is being updated
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>ke</parameter></term>
   <listitem>
    <para>
     new keymap entry
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
<title>Description</title>
<para>
   This function should be called by anyone needing to update current
   keymap. Presently keyboard and evdev handlers use it.
</para>
</refsect1>
</refentry>

<refentry id="API-input-reset-device">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>July 2015</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>input_reset_device</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.4.104</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>input_reset_device</refname>
 <refpurpose>
     reset/restore the state of input device
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>void <function>input_reset_device </function></funcdef>
   <paramdef>struct input_dev * <parameter>dev</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>dev</parameter></term>
   <listitem>
    <para>
     input device whose state needs to be reset
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
<title>Description</title>
<para>
   This function tries to reset the state of an opened input device and
   bring internal state and state if the hardware in sync with each other.
   We mark all keys as released, restore LED state, repeat rate, etc.
</para>
</refsect1>
</refentry>

<refentry id="API-input-allocate-device">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>July 2015</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>input_allocate_device</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.4.104</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>input_allocate_device</refname>
 <refpurpose>
     allocate memory for new input device
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>struct input_dev * <function>input_allocate_device </function></funcdef>
   <paramdef> <parameter>void</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>void</parameter></term>
   <listitem>
    <para>
     no arguments
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
<title>Description</title>
<para>
   </para><para>

   Returns prepared struct input_dev or NULL.
</para>
</refsect1>
<refsect1>
<title>NOTE</title>
<para>
   Use <function>input_free_device</function> to free devices that have not been
   registered; <function>input_unregister_device</function> should be used for already
   registered devices.
</para>
</refsect1>
</refentry>

<refentry id="API-input-free-device">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>July 2015</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>input_free_device</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.4.104</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>input_free_device</refname>
 <refpurpose>
     free memory occupied by input_dev structure
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>void <function>input_free_device </function></funcdef>
   <paramdef>struct input_dev * <parameter>dev</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>dev</parameter></term>
   <listitem>
    <para>
     input device to free
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
<title>Description</title>
<para>
   This function should only be used if <function>input_register_device</function>
   was not called yet or if it failed. Once device was registered
   use <function>input_unregister_device</function> and memory will be freed once last
   reference to the device is dropped.
   </para><para>

   Device should be allocated by <function>input_allocate_device</function>.
</para>
</refsect1>
<refsect1>
<title>NOTE</title>
<para>
   If there are references to the input device then memory
   will not be freed until last reference is dropped.
</para>
</refsect1>
</refentry>

<refentry id="API-input-set-capability">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>July 2015</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>input_set_capability</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.4.104</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>input_set_capability</refname>
 <refpurpose>
     mark device as capable of a certain event
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>void <function>input_set_capability </function></funcdef>
   <paramdef>struct input_dev * <parameter>dev</parameter></paramdef>
   <paramdef>unsigned int <parameter>type</parameter></paramdef>
   <paramdef>unsigned int <parameter>code</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>dev</parameter></term>
   <listitem>
    <para>
     device that is capable of emitting or accepting event
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>type</parameter></term>
   <listitem>
    <para>
     type of the event (EV_KEY, EV_REL, etc...)
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>code</parameter></term>
   <listitem>
    <para>
     event code
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
<title>Description</title>
<para>
   In addition to setting up corresponding bit in appropriate capability
   bitmap the function also adjusts dev-&gt;evbit.
</para>
</refsect1>
</refentry>

<refentry id="API-input-register-device">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>July 2015</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>input_register_device</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.4.104</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>input_register_device</refname>
 <refpurpose>
     register device with input core
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>int <function>input_register_device </function></funcdef>
   <paramdef>struct input_dev * <parameter>dev</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>dev</parameter></term>
   <listitem>
    <para>
     device to be registered
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
<title>Description</title>
<para>
   This function registers device with input core. The device must be
   allocated with <function>input_allocate_device</function> and all it's capabilities
   set up before registering.
   If function fails the device must be freed with <function>input_free_device</function>.
   Once device has been successfully registered it can be unregistered
   with <function>input_unregister_device</function>; <function>input_free_device</function> should not be
   called in this case.
</para>
</refsect1>
</refentry>

<refentry id="API-input-unregister-device">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>July 2015</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>input_unregister_device</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.4.104</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>input_unregister_device</refname>
 <refpurpose>
     unregister previously registered device
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>void <function>input_unregister_device </function></funcdef>
   <paramdef>struct input_dev * <parameter>dev</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>dev</parameter></term>
   <listitem>
    <para>
     device to be unregistered
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
<title>Description</title>
<para>
   This function unregisters an input device. Once device is unregistered
   the caller should not try to access it as it may get freed at any moment.
</para>
</refsect1>
</refentry>

<refentry id="API-input-register-handler">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>July 2015</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>input_register_handler</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.4.104</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>input_register_handler</refname>
 <refpurpose>
     register a new input handler
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>int <function>input_register_handler </function></funcdef>
   <paramdef>struct input_handler * <parameter>handler</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>handler</parameter></term>
   <listitem>
    <para>
     handler to be registered
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
<title>Description</title>
<para>
   This function registers a new input handler (interface) for input
   devices in the system and attaches it to all input devices that
   are compatible with the handler.
</para>
</refsect1>
</refentry>

<refentry id="API-input-unregister-handler">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>July 2015</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>input_unregister_handler</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.4.104</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>input_unregister_handler</refname>
 <refpurpose>
     unregisters an input handler
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>void <function>input_unregister_handler </function></funcdef>
   <paramdef>struct input_handler * <parameter>handler</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>handler</parameter></term>
   <listitem>
    <para>
     handler to be unregistered
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
<title>Description</title>
<para>
   This function disconnects a handler from its input devices and
   removes it from lists of known handlers.
</para>
</refsect1>
</refentry>

<refentry id="API-input-handler-for-each-handle">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>July 2015</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>input_handler_for_each_handle</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.4.104</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>input_handler_for_each_handle</refname>
 <refpurpose>
     handle iterator
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>int <function>input_handler_for_each_handle </function></funcdef>
   <paramdef>struct input_handler * <parameter>handler</parameter></paramdef>
   <paramdef>void * <parameter>data</parameter></paramdef>
   <paramdef>int (*<parameter>fn</parameter>)
     <funcparams>struct input_handle *, void *</funcparams></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>handler</parameter></term>
   <listitem>
    <para>
     input handler to iterate
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>data</parameter></term>
   <listitem>
    <para>
     data for the callback
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>fn</parameter></term>
   <listitem>
    <para>
     function to be called for each handle
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
<title>Description</title>
<para>
   Iterate over <parameter>bus</parameter>'s list of devices, and call <parameter>fn</parameter> for each, passing
   it <parameter>data</parameter> and stop when <parameter>fn</parameter> returns a non-zero value. The function is
   using RCU to traverse the list and therefore may be usind in atonic
   contexts. The <parameter>fn</parameter> callback is invoked from RCU critical section and
   thus must not sleep.
</para>
</refsect1>
</refentry>

<refentry id="API-input-register-handle">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>July 2015</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>input_register_handle</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.4.104</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>input_register_handle</refname>
 <refpurpose>
     register a new input handle
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>int <function>input_register_handle </function></funcdef>
   <paramdef>struct input_handle * <parameter>handle</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>handle</parameter></term>
   <listitem>
    <para>
     handle to register
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
<title>Description</title>
<para>
   This function puts a new input handle onto device's
   and handler's lists so that events can flow through
   it once it is opened using <function>input_open_device</function>.
   </para><para>

   This function is supposed to be called from handler's
   <function>connect</function> method.
</para>
</refsect1>
</refentry>

<refentry id="API-input-unregister-handle">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>July 2015</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>input_unregister_handle</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.4.104</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>input_unregister_handle</refname>
 <refpurpose>
     unregister an input handle
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>void <function>input_unregister_handle </function></funcdef>
   <paramdef>struct input_handle * <parameter>handle</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>handle</parameter></term>
   <listitem>
    <para>
     handle to unregister
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
<title>Description</title>
<para>
   This function removes input handle from device's
   and handler's lists.
   </para><para>

   This function is supposed to be called from handler's
   <function>disconnect</function> method.
</para>
</refsect1>
</refentry>

<!-- drivers/input/ff-core.c -->
<refentry id="API-input-ff-upload">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>July 2015</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>input_ff_upload</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.4.104</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>input_ff_upload</refname>
 <refpurpose>
  upload effect into force-feedback device
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>int <function>input_ff_upload </function></funcdef>
   <paramdef>struct input_dev * <parameter>dev</parameter></paramdef>
   <paramdef>struct ff_effect * <parameter>effect</parameter></paramdef>
   <paramdef>struct file * <parameter>file</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>dev</parameter></term>
   <listitem>
    <para>
     input device
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>effect</parameter></term>
   <listitem>
    <para>
     effect to be uploaded
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>file</parameter></term>
   <listitem>
    <para>
     owner of the effect
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
</refentry>

<refentry id="API-input-ff-erase">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>July 2015</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>input_ff_erase</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.4.104</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>input_ff_erase</refname>
 <refpurpose>
     erase a force-feedback effect from device
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>int <function>input_ff_erase </function></funcdef>
   <paramdef>struct input_dev * <parameter>dev</parameter></paramdef>
   <paramdef>int <parameter>effect_id</parameter></paramdef>
   <paramdef>struct file * <parameter>file</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>dev</parameter></term>
   <listitem>
    <para>
     input device to erase effect from
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>effect_id</parameter></term>
   <listitem>
    <para>
     id of the ffect to be erased
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>file</parameter></term>
   <listitem>
    <para>
     purported owner of the request
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
<title>Description</title>
<para>
   This function erases a force-feedback effect from specified device.
   The effect will only be erased if it was uploaded through the same
   file handle that is requesting erase.
</para>
</refsect1>
</refentry>

<refentry id="API-input-ff-event">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>July 2015</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>input_ff_event</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.4.104</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>input_ff_event</refname>
 <refpurpose>
     generic handler for force-feedback events
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>int <function>input_ff_event </function></funcdef>
   <paramdef>struct input_dev * <parameter>dev</parameter></paramdef>
   <paramdef>unsigned int <parameter>type</parameter></paramdef>
   <paramdef>unsigned int <parameter>code</parameter></paramdef>
   <paramdef>int <parameter>value</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>dev</parameter></term>
   <listitem>
    <para>
     input device to send the effect to
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>type</parameter></term>
   <listitem>
    <para>
     event type (anything but EV_FF is ignored)
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>code</parameter></term>
   <listitem>
    <para>
     event code
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>value</parameter></term>
   <listitem>
    <para>
     event value
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
</refentry>

<refentry id="API-input-ff-create">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>July 2015</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>input_ff_create</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.4.104</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>input_ff_create</refname>
 <refpurpose>
     create force-feedback device
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>int <function>input_ff_create </function></funcdef>
   <paramdef>struct input_dev * <parameter>dev</parameter></paramdef>
   <paramdef>unsigned int <parameter>max_effects</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>dev</parameter></term>
   <listitem>
    <para>
     input device supporting force-feedback
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>max_effects</parameter></term>
   <listitem>
    <para>
     maximum number of effects supported by the device
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
<title>Description</title>
<para>
   This function allocates all necessary memory for a force feedback
   portion of an input device and installs all default handlers.
   <parameter>dev</parameter>-&gt;ffbit should be already set up before calling this function.
   Once ff device is created you need to setup its upload, erase,
   playback and other handlers before registering input device
</para>
</refsect1>
</refentry>

<refentry id="API-input-ff-destroy">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>July 2015</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>input_ff_destroy</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.4.104</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>input_ff_destroy</refname>
 <refpurpose>
     frees force feedback portion of input device
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>void <function>input_ff_destroy </function></funcdef>
   <paramdef>struct input_dev * <parameter>dev</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>dev</parameter></term>
   <listitem>
    <para>
     input device supporting force feedback
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
<title>Description</title>
<para>
   This function is only needed in error path as input core will
   automatically free force feedback structures when device is
   destroyed.
</para>
</refsect1>
</refentry>

<!-- drivers/input/ff-memless.c -->
<refentry id="API-input-ff-create-memless">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>July 2015</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>input_ff_create_memless</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.4.104</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>input_ff_create_memless</refname>
 <refpurpose>
  create memoryless force-feedback device
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>int <function>input_ff_create_memless </function></funcdef>
   <paramdef>struct input_dev * <parameter>dev</parameter></paramdef>
   <paramdef>void * <parameter>data</parameter></paramdef>
   <paramdef>int (*<parameter>play_effect</parameter>)
     <funcparams>struct input_dev *, void *, struct ff_effect *</funcparams></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>dev</parameter></term>
   <listitem>
    <para>
     input device supporting force-feedback
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>data</parameter></term>
   <listitem>
    <para>
     driver-specific data to be passed into <parameter>play_effect</parameter>
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>play_effect</parameter></term>
   <listitem>
    <para>
     driver-specific method for playing FF effect
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
</refentry>

     </sect1>
     <sect1><title>Multitouch Library</title>
<!-- include/linux/input/mt.h -->
<refentry id="API-struct-input-mt-slot">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>July 2015</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>struct input_mt_slot</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.4.104</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>struct input_mt_slot</refname>
 <refpurpose>
  represents the state of an input MT slot
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <programlisting>
struct input_mt_slot {
  int abs[ABS_MT_LAST - ABS_MT_FIRST + 1];
};  </programlisting>
</refsynopsisdiv>
 <refsect1>
  <title>Members</title>
  <variablelist>
    <varlistentry>      <term>abs[ABS_MT_LAST - ABS_MT_FIRST + 1]</term>
      <listitem><para>
holds current values of ABS_MT axes for this slot
      </para></listitem>
    </varlistentry>
  </variablelist>
 </refsect1>
</refentry>

<!-- drivers/input/input-mt.c -->
<refentry id="API-input-mt-init-slots">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>July 2015</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>input_mt_init_slots</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.4.104</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>input_mt_init_slots</refname>
 <refpurpose>
  initialize MT input slots
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>int <function>input_mt_init_slots </function></funcdef>
   <paramdef>struct input_dev * <parameter>dev</parameter></paramdef>
   <paramdef>unsigned int <parameter>num_slots</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>dev</parameter></term>
   <listitem>
    <para>
     input device supporting MT events and finger tracking
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>num_slots</parameter></term>
   <listitem>
    <para>
     number of slots used by the device
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
<title>Description</title>
<para>
   This function allocates all necessary memory for MT slot handling
   in the input device, prepares the ABS_MT_SLOT and
   ABS_MT_TRACKING_ID events for use and sets up appropriate buffers.
   May be called repeatedly. Returns -EINVAL if attempting to
   reinitialize with a different number of slots.
</para>
</refsect1>
</refentry>

<refentry id="API-input-mt-destroy-slots">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>July 2015</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>input_mt_destroy_slots</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.4.104</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>input_mt_destroy_slots</refname>
 <refpurpose>
     frees the MT slots of the input device
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>void <function>input_mt_destroy_slots </function></funcdef>
   <paramdef>struct input_dev * <parameter>dev</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>dev</parameter></term>
   <listitem>
    <para>
     input device with allocated MT slots
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
<title>Description</title>
<para>
   This function is only needed in error path as the input core will
   automatically free the MT slots when the device is destroyed.
</para>
</refsect1>
</refentry>

<refentry id="API-input-mt-report-slot-state">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>July 2015</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>input_mt_report_slot_state</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.4.104</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>input_mt_report_slot_state</refname>
 <refpurpose>
     report contact state
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>void <function>input_mt_report_slot_state </function></funcdef>
   <paramdef>struct input_dev * <parameter>dev</parameter></paramdef>
   <paramdef>unsigned int <parameter>tool_type</parameter></paramdef>
   <paramdef>bool <parameter>active</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>dev</parameter></term>
   <listitem>
    <para>
     input device with allocated MT slots
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>tool_type</parameter></term>
   <listitem>
    <para>
     the tool type to use in this slot
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>active</parameter></term>
   <listitem>
    <para>
     true if contact is active, false otherwise
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
<title>Description</title>
<para>
   Reports a contact via ABS_MT_TRACKING_ID, and optionally
   ABS_MT_TOOL_TYPE. If active is true and the slot is currently
   inactive, or if the tool type is changed, a new tracking id is
   assigned to the slot. The tool type is only reported if the
   corresponding absbit field is set.
</para>
</refsect1>
</refentry>

<refentry id="API-input-mt-report-finger-count">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>July 2015</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>input_mt_report_finger_count</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.4.104</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>input_mt_report_finger_count</refname>
 <refpurpose>
     report contact count
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>void <function>input_mt_report_finger_count </function></funcdef>
   <paramdef>struct input_dev * <parameter>dev</parameter></paramdef>
   <paramdef>int <parameter>count</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>dev</parameter></term>
   <listitem>
    <para>
     input device with allocated MT slots
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>count</parameter></term>
   <listitem>
    <para>
     the number of contacts
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
<title>Description</title>
<para>
   Reports the contact count via BTN_TOOL_FINGER, BTN_TOOL_DOUBLETAP,
   BTN_TOOL_TRIPLETAP and BTN_TOOL_QUADTAP.
   </para><para>

   The input core ensures only the KEY events already setup for
   this device will produce output.
</para>
</refsect1>
</refentry>

<refentry id="API-input-mt-report-pointer-emulation">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>July 2015</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>input_mt_report_pointer_emulation</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.4.104</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>input_mt_report_pointer_emulation</refname>
 <refpurpose>
     common pointer emulation
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>void <function>input_mt_report_pointer_emulation </function></funcdef>
   <paramdef>struct input_dev * <parameter>dev</parameter></paramdef>
   <paramdef>bool <parameter>use_count</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>dev</parameter></term>
   <listitem>
    <para>
     input device with allocated MT slots
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>use_count</parameter></term>
   <listitem>
    <para>
     report number of active contacts as finger count
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
<title>Description</title>
<para>
   Performs legacy pointer emulation via BTN_TOUCH, ABS_X, ABS_Y and
   ABS_PRESSURE. Touchpad finger count is emulated if use_count is true.
   </para><para>

   The input core ensures only the KEY and ABS axes already setup for
   this device will produce output.
</para>
</refsect1>
</refentry>

     </sect1>
     <sect1><title>Polled input devices</title>
<!-- include/linux/input-polldev.h -->
<refentry id="API-struct-input-polled-dev">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>July 2015</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>struct input_polled_dev</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.4.104</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>struct input_polled_dev</refname>
 <refpurpose>
  simple polled input device
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <programlisting>
struct input_polled_dev {
  void * private;
  void (* open) (struct input_polled_dev *dev);
  void (* close) (struct input_polled_dev *dev);
  void (* poll) (struct input_polled_dev *dev);
  unsigned int poll_interval;
  unsigned int poll_interval_max;
  unsigned int poll_interval_min;
  struct input_dev * input;
};  </programlisting>
</refsynopsisdiv>
 <refsect1>
  <title>Members</title>
  <variablelist>
    <varlistentry>      <term>private</term>
      <listitem><para>
private driver data.
      </para></listitem>
    </varlistentry>
    <varlistentry>      <term>open</term>
      <listitem><para>
driver-supplied method that prepares device for polling
(enabled the device and maybe flushes device state).
      </para></listitem>
    </varlistentry>
    <varlistentry>      <term>close</term>
      <listitem><para>
driver-supplied method that is called when device is no
longer being polled. Used to put device into low power mode.
      </para></listitem>
    </varlistentry>
    <varlistentry>      <term>poll</term>
      <listitem><para>
driver-supplied method that polls the device and posts
input events (mandatory).
      </para></listitem>
    </varlistentry>
    <varlistentry>      <term>poll_interval</term>
      <listitem><para>
specifies how often the <function>poll</function> method should be called.
Defaults to 500 msec unless overridden when registering the device.
      </para></listitem>
    </varlistentry>
    <varlistentry>      <term>poll_interval_max</term>
      <listitem><para>
specifies upper bound for the poll interval.
Defaults to the initial value of <parameter>poll_interval</parameter>.
      </para></listitem>
    </varlistentry>
    <varlistentry>      <term>poll_interval_min</term>
      <listitem><para>
specifies lower bound for the poll interval.
Defaults to 0.
      </para></listitem>
    </varlistentry>
    <varlistentry>      <term>input</term>
      <listitem><para>
input device structure associated with the polled device.
Must be properly initialized by the driver (id, name, phys, bits).
      </para></listitem>
    </varlistentry>
  </variablelist>
 </refsect1>
<refsect1>
<title>Description</title>
<para>
   Polled input device provides a skeleton for supporting simple input
   devices that do not raise interrupts but have to be periodically
   scanned or polled to detect changes in their state.
</para>
</refsect1>
</refentry>

<!-- drivers/input/input-polldev.c -->
<refentry id="API-input-allocate-polled-device">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>July 2015</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>input_allocate_polled_device</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.4.104</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>input_allocate_polled_device</refname>
 <refpurpose>
  allocate memory for polled device
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>struct input_polled_dev * <function>input_allocate_polled_device </function></funcdef>
   <paramdef> <parameter>void</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>void</parameter></term>
   <listitem>
    <para>
     no arguments
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
<title>Description</title>
<para>
   </para><para>

   The function allocates memory for a polled device and also
   for an input device associated with this polled device.
</para>
</refsect1>
</refentry>

<refentry id="API-input-free-polled-device">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>July 2015</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>input_free_polled_device</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.4.104</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>input_free_polled_device</refname>
 <refpurpose>
     free memory allocated for polled device
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>void <function>input_free_polled_device </function></funcdef>
   <paramdef>struct input_polled_dev * <parameter>dev</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>dev</parameter></term>
   <listitem>
    <para>
     device to free
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
<title>Description</title>
<para>
   The function frees memory allocated for polling device and drops
   reference to the associated input device.
</para>
</refsect1>
</refentry>

<refentry id="API-input-register-polled-device">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>July 2015</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>input_register_polled_device</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.4.104</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>input_register_polled_device</refname>
 <refpurpose>
     register polled device
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>int <function>input_register_polled_device </function></funcdef>
   <paramdef>struct input_polled_dev * <parameter>dev</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>dev</parameter></term>
   <listitem>
    <para>
     device to register
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
<title>Description</title>
<para>
   The function registers previously initialized polled input device
   with input layer. The device should be allocated with call to
   <function>input_allocate_polled_device</function>. Callers should also set up <function>poll</function>
   method and set up capabilities (id, name, phys, bits) of the
   corresponding input_dev structure.
</para>
</refsect1>
</refentry>

<refentry id="API-input-unregister-polled-device">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>July 2015</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>input_unregister_polled_device</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.4.104</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>input_unregister_polled_device</refname>
 <refpurpose>
     unregister polled device
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>void <function>input_unregister_polled_device </function></funcdef>
   <paramdef>struct input_polled_dev * <parameter>dev</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>dev</parameter></term>
   <listitem>
    <para>
     device to unregister
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
<title>Description</title>
<para>
   The function unregisters previously registered polled input
   device from input layer. Polling is stopped and device is
   ready to be freed with call to <function>input_free_polled_device</function>.
</para>
</refsect1>
</refentry>

     </sect1>
     <sect1><title>Matrix keyboars/keypads</title>
<!-- include/linux/input/matrix_keypad.h -->
<refentry id="API-struct-matrix-keymap-data">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>July 2015</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>struct matrix_keymap_data</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.4.104</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>struct matrix_keymap_data</refname>
 <refpurpose>
  keymap for matrix keyboards
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <programlisting>
struct matrix_keymap_data {
  const uint32_t * keymap;
  unsigned int keymap_size;
};  </programlisting>
</refsynopsisdiv>
 <refsect1>
  <title>Members</title>
  <variablelist>
    <varlistentry>      <term>keymap</term>
      <listitem><para>
pointer to array of uint32 values encoded with <function>KEY</function> macro
representing keymap
      </para></listitem>
    </varlistentry>
    <varlistentry>      <term>keymap_size</term>
      <listitem><para>
number of entries (initialized) in this keymap
      </para></listitem>
    </varlistentry>
  </variablelist>
 </refsect1>
<refsect1>
<title>Description</title>
<para>
   This structure is supposed to be used by platform code to supply
   keymaps to drivers that implement matrix-like keypads/keyboards.
</para>
</refsect1>
</refentry>

<refentry id="API-struct-matrix-keypad-platform-data">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>July 2015</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>struct matrix_keypad_platform_data</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.4.104</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>struct matrix_keypad_platform_data</refname>
 <refpurpose>
     platform-dependent keypad data
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <programlisting>
struct matrix_keypad_platform_data {
  const struct matrix_keymap_data * keymap_data;
  const unsigned int * row_gpios;
  const unsigned int * col_gpios;
  unsigned int num_row_gpios;
  unsigned int num_col_gpios;
  unsigned int col_scan_delay_us;
  unsigned int debounce_ms;
  unsigned int clustered_irq;
  unsigned int clustered_irq_flags;
  bool active_low;
  bool wakeup;
  bool no_autorepeat;
};  </programlisting>
</refsynopsisdiv>
 <refsect1>
  <title>Members</title>
  <variablelist>
    <varlistentry>      <term>keymap_data</term>
      <listitem><para>
   pointer to <structname>matrix_keymap_data</structname>
      </para></listitem>
    </varlistentry>
    <varlistentry>      <term>row_gpios</term>
      <listitem><para>
   pointer to array of gpio numbers representing rows
      </para></listitem>
    </varlistentry>
    <varlistentry>      <term>col_gpios</term>
      <listitem><para>
   pointer to array of gpio numbers reporesenting colums
      </para></listitem>
    </varlistentry>
    <varlistentry>      <term>num_row_gpios</term>
      <listitem><para>
   actual number of row gpios used by device
      </para></listitem>
    </varlistentry>
    <varlistentry>      <term>num_col_gpios</term>
      <listitem><para>
   actual number of col gpios used by device
      </para></listitem>
    </varlistentry>
    <varlistentry>      <term>col_scan_delay_us</term>
      <listitem><para>
   delay, measured in microseconds, that is
   needed before we can keypad after activating column gpio
      </para></listitem>
    </varlistentry>
    <varlistentry>      <term>debounce_ms</term>
      <listitem><para>
   debounce interval in milliseconds
      </para></listitem>
    </varlistentry>
    <varlistentry>      <term>clustered_irq</term>
      <listitem><para>
   may be specified if interrupts of all row/column GPIOs
   are bundled to one single irq
      </para></listitem>
    </varlistentry>
    <varlistentry>      <term>clustered_irq_flags</term>
      <listitem><para>
   flags that are needed for the clustered irq
      </para></listitem>
    </varlistentry>
    <varlistentry>      <term>active_low</term>
      <listitem><para>
   gpio polarity
      </para></listitem>
    </varlistentry>
    <varlistentry>      <term>wakeup</term>
      <listitem><para>
   controls whether the device should be set up as wakeup
   source
      </para></listitem>
    </varlistentry>
    <varlistentry>      <term>no_autorepeat</term>
      <listitem><para>
   disable key autorepeat
      </para></listitem>
    </varlistentry>
  </variablelist>
 </refsect1>
<refsect1>
<title>Description</title>
<para>
   This structure represents platform-specific data that use used by
   matrix_keypad driver to perform proper initialization.
</para>
</refsect1>
</refentry>

<refentry id="API-matrix-keypad-build-keymap">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>July 2015</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>matrix_keypad_build_keymap</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.4.104</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>matrix_keypad_build_keymap</refname>
 <refpurpose>
     convert platform keymap into matrix keymap
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>void <function>matrix_keypad_build_keymap </function></funcdef>
   <paramdef>const struct matrix_keymap_data * <parameter>keymap_data</parameter></paramdef>
   <paramdef>unsigned int <parameter>row_shift</parameter></paramdef>
   <paramdef>unsigned short * <parameter>keymap</parameter></paramdef>
   <paramdef>unsigned long * <parameter>keybit</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>keymap_data</parameter></term>
   <listitem>
    <para>
     keymap supplied by the platform code
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>row_shift</parameter></term>
   <listitem>
    <para>
     number of bits to shift row value by to advance to the next
     line in the keymap
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>keymap</parameter></term>
   <listitem>
    <para>
     expanded version of keymap that is suitable for use by
     matrix keyboad driver
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>keybit</parameter></term>
   <listitem>
    <para>
     pointer to bitmap of keys supported by input device
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
<title>Description</title>
<para>
   This function converts platform keymap (encoded with <function>KEY</function> macro) into
   an array of keycodes that is suitable for using in a standard matrix
   keyboard driver that uses row and col as indices.
</para>
</refsect1>
</refentry>

     </sect1>
     <sect1><title>Sparse keymap support</title>
<!-- include/linux/input/sparse-keymap.h -->
<refentry id="API-struct-key-entry">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>July 2015</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>struct key_entry</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.4.104</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>struct key_entry</refname>
 <refpurpose>
  keymap entry for use in sparse keymap
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <programlisting>
struct key_entry {
  int type;
  u32 code;
  union {unnamed_union};
};  </programlisting>
</refsynopsisdiv>
 <refsect1>
  <title>Members</title>
  <variablelist>
    <varlistentry>      <term>type</term>
      <listitem><para>
Type of the key entry (KE_KEY, KE_SW, KE_VSW, KE_END);
drivers are allowed to extend the list with their own
private definitions.
      </para></listitem>
    </varlistentry>
    <varlistentry>      <term>code</term>
      <listitem><para>
Device-specific data identifying the button/switch
      </para></listitem>
    </varlistentry>
    <varlistentry>      <term>{unnamed_union}</term>
      <listitem><para>
anonymous
      </para></listitem>
    </varlistentry>
  </variablelist>
 </refsect1>
<refsect1>
<title>Description</title>
<para>
   This structure defines an entry in a sparse keymap used by some
   input devices for which traditional table-based approach is not
   suitable.
</para>
</refsect1>
</refentry>

<!-- drivers/input/sparse-keymap.c -->
<refentry id="API-sparse-keymap-entry-from-scancode">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>July 2015</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>sparse_keymap_entry_from_scancode</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.4.104</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>sparse_keymap_entry_from_scancode</refname>
 <refpurpose>
  perform sparse keymap lookup
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>struct key_entry * <function>sparse_keymap_entry_from_scancode </function></funcdef>
   <paramdef>struct input_dev * <parameter>dev</parameter></paramdef>
   <paramdef>unsigned int <parameter>code</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>dev</parameter></term>
   <listitem>
    <para>
     Input device using sparse keymap
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>code</parameter></term>
   <listitem>
    <para>
     Scan code
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
<title>Description</title>
<para>
   This function is used to perform <structname>struct key_entry</structname> lookup in an
   input device using sparse keymap.
</para>
</refsect1>
</refentry>

<refentry id="API-sparse-keymap-entry-from-keycode">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>July 2015</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>sparse_keymap_entry_from_keycode</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.4.104</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>sparse_keymap_entry_from_keycode</refname>
 <refpurpose>
     perform sparse keymap lookup
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>struct key_entry * <function>sparse_keymap_entry_from_keycode </function></funcdef>
   <paramdef>struct input_dev * <parameter>dev</parameter></paramdef>
   <paramdef>unsigned int <parameter>keycode</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>dev</parameter></term>
   <listitem>
    <para>
     Input device using sparse keymap
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>keycode</parameter></term>
   <listitem>
    <para>
     Key code
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
<title>Description</title>
<para>
   This function is used to perform <structname>struct key_entry</structname> lookup in an
   input device using sparse keymap.
</para>
</refsect1>
</refentry>

<refentry id="API-sparse-keymap-setup">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>July 2015</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>sparse_keymap_setup</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.4.104</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>sparse_keymap_setup</refname>
 <refpurpose>
     set up sparse keymap for an input device
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>int <function>sparse_keymap_setup </function></funcdef>
   <paramdef>struct input_dev * <parameter>dev</parameter></paramdef>
   <paramdef>const struct key_entry * <parameter>keymap</parameter></paramdef>
   <paramdef>int (*<parameter>setup</parameter>)
     <funcparams>struct input_dev *, struct key_entry *</funcparams></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>dev</parameter></term>
   <listitem>
    <para>
     Input device
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>keymap</parameter></term>
   <listitem>
    <para>
     Keymap in form of array of <structname>key_entry</structname> structures ending
     with <constant>KE_END</constant> type entry
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>setup</parameter></term>
   <listitem>
    <para>
     Function that can be used to adjust keymap entries
     depending on device's deeds, may be <constant>NULL</constant>
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
<title>Description</title>
<para>
   The function calculates size and allocates copy of the original
   keymap after which sets up input device event bits appropriately.
   Before destroying input device allocated keymap should be freed
   with a call to <function>sparse_keymap_free</function>.
</para>
</refsect1>
</refentry>

<refentry id="API-sparse-keymap-free">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>July 2015</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>sparse_keymap_free</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.4.104</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>sparse_keymap_free</refname>
 <refpurpose>
     free memory allocated for sparse keymap
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>void <function>sparse_keymap_free </function></funcdef>
   <paramdef>struct input_dev * <parameter>dev</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>dev</parameter></term>
   <listitem>
    <para>
     Input device using sparse keymap
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
<title>Description</title>
<para>
   This function is used to free memory allocated by sparse keymap
   in an input device that was set up by <function>sparse_keymap_setup</function>.
</para>
</refsect1>
<refsect1>
<title>NOTE</title>
<para>
   It is safe to cal this function while input device is
   still registered (however the drivers should care not to try to
   use freed keymap and thus have to shut off interrups/polling
   before freeing the keymap).
</para>
</refsect1>
</refentry>

<refentry id="API-sparse-keymap-report-entry">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>July 2015</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>sparse_keymap_report_entry</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.4.104</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>sparse_keymap_report_entry</refname>
 <refpurpose>
     report event corresponding to given key entry
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>void <function>sparse_keymap_report_entry </function></funcdef>
   <paramdef>struct input_dev * <parameter>dev</parameter></paramdef>
   <paramdef>const struct key_entry * <parameter>ke</parameter></paramdef>
   <paramdef>unsigned int <parameter>value</parameter></paramdef>
   <paramdef>bool <parameter>autorelease</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>dev</parameter></term>
   <listitem>
    <para>
     Input device for which event should be reported
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>ke</parameter></term>
   <listitem>
    <para>
     key entry describing event
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>value</parameter></term>
   <listitem>
    <para>
     Value that should be reported (ignored by <constant>KE_SW</constant> entries)
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>autorelease</parameter></term>
   <listitem>
    <para>
     Signals whether release event should be emitted for <constant>KE_KEY</constant>
     entries right after reporting press event, ignored by all other
     entries
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
<title>Description</title>
<para>
   This function is used to report input event described by given
   <structname>struct key_entry</structname>.
</para>
</refsect1>
</refentry>

<refentry id="API-sparse-keymap-report-event">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>July 2015</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>sparse_keymap_report_event</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.4.104</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>sparse_keymap_report_event</refname>
 <refpurpose>
     report event corresponding to given scancode
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>bool <function>sparse_keymap_report_event </function></funcdef>
   <paramdef>struct input_dev * <parameter>dev</parameter></paramdef>
   <paramdef>unsigned int <parameter>code</parameter></paramdef>
   <paramdef>unsigned int <parameter>value</parameter></paramdef>
   <paramdef>bool <parameter>autorelease</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>dev</parameter></term>
   <listitem>
    <para>
     Input device using sparse keymap
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>code</parameter></term>
   <listitem>
    <para>
     Scan code
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>value</parameter></term>
   <listitem>
    <para>
     Value that should be reported (ignored by <constant>KE_SW</constant> entries)
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>autorelease</parameter></term>
   <listitem>
    <para>
     Signals whether release event should be emitted for <constant>KE_KEY</constant>
     entries right after reporting press event, ignored by all other
     entries
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
<title>Description</title>
<para>
   This function is used to perform lookup in an input device using sparse
   keymap and report corresponding event. Returns <constant>true</constant> if lookup was
   successful and <constant>false</constant> otherwise.
</para>
</refsect1>
</refentry>

     </sect1>
  </chapter>

  <chapter id="spi">
      <title>Serial Peripheral Interface (SPI)</title>
  <para>
	SPI is the "Serial Peripheral Interface", widely used with
	embedded systems because it is a simple and efficient
	interface:  basically a multiplexed shift register.
	Its three signal wires hold a clock (SCK, often in the range
	of 1-20 MHz), a "Master Out, Slave In" (MOSI) data line, and
	a "Master In, Slave Out" (MISO) data line.
	SPI is a full duplex protocol; for each bit shifted out the
	MOSI line (one per clock) another is shifted in on the MISO line.
	Those bits are assembled into words of various sizes on the
	way to and from system memory.
	An additional chipselect line is usually active-low (nCS);
	four signals are normally used for each peripheral, plus
	sometimes an interrupt.
  </para>
  <para>
	The SPI bus facilities listed here provide a generalized
	interface to declare SPI busses and devices, manage them
	according to the standard Linux driver model, and perform
	input/output operations.
	At this time, only "master" side interfaces are supported,
	where Linux talks to SPI peripherals and does not implement
	such a peripheral itself.
	(Interfaces to support implementing SPI slaves would
	necessarily look different.)
  </para>
  <para>
	The programming interface is structured around two kinds of driver,
	and two kinds of device.
	A "Controller Driver" abstracts the controller hardware, which may
	be as simple as a set of GPIO pins or as complex as a pair of FIFOs
	connected to dual DMA engines on the other side of the SPI shift
	register (maximizing throughput).  Such drivers bridge between
	whatever bus they sit on (often the platform bus) and SPI, and
	expose the SPI side of their device as a
	<structname>struct spi_master</structname>.
	SPI devices are children of that master, represented as a
	<structname>struct spi_device</structname> and manufactured from
	<structname>struct spi_board_info</structname> descriptors which
	are usually provided by board-specific initialization code.
	A <structname>struct spi_driver</structname> is called a
	"Protocol Driver", and is bound to a spi_device using normal
	driver model calls.
  </para>
  <para>
	The I/O model is a set of queued messages.  Protocol drivers
	submit one or more <structname>struct spi_message</structname>
	objects, which are processed and completed asynchronously.
	(There are synchronous wrappers, however.)  Messages are
	built from one or more <structname>struct spi_transfer</structname>
	objects, each of which wraps a full duplex SPI transfer.
	A variety of protocol tweaking options are needed, because
	different chips adopt very different policies for how they
	use the bits transferred with SPI.
  </para>
<!-- include/linux/spi/spi.h -->
<refentry id="API-struct-spi-device">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>July 2015</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>struct spi_device</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.4.104</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>struct spi_device</refname>
 <refpurpose>
  Master side proxy for an SPI slave device
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <programlisting>
struct spi_device {
  struct device dev;
  struct spi_master * master;
  u32 max_speed_hz;
  u8 chip_select;
  u8 mode;
#define SPI_CPHA	0x01
#define SPI_CPOL	0x02
#define SPI_MODE_0	(0|0)
#define SPI_MODE_1	(0|SPI_CPHA)
#define SPI_MODE_2	(SPI_CPOL|0)
#define SPI_MODE_3	(SPI_CPOL|SPI_CPHA)
#define SPI_CS_HIGH	0x04
#define SPI_LSB_FIRST	0x08
#define SPI_3WIRE	0x10
#define SPI_LOOP	0x20
#define SPI_NO_CS	0x40
#define SPI_READY	0x80
  u8 bits_per_word;
  int irq;
  void * controller_state;
  void * controller_data;
  char modalias[SPI_NAME_SIZE];
};  </programlisting>
</refsynopsisdiv>
 <refsect1>
  <title>Members</title>
  <variablelist>
    <varlistentry>      <term>dev</term>
      <listitem><para>
Driver model representation of the device.
      </para></listitem>
    </varlistentry>
    <varlistentry>      <term>master</term>
      <listitem><para>
SPI controller used with the device.
      </para></listitem>
    </varlistentry>
    <varlistentry>      <term>max_speed_hz</term>
      <listitem><para>
Maximum clock rate to be used with this chip
(on this board); may be changed by the device's driver.
The spi_transfer.speed_hz can override this for each transfer.
      </para></listitem>
    </varlistentry>
    <varlistentry>      <term>chip_select</term>
      <listitem><para>
Chipselect, distinguishing chips handled by <parameter>master</parameter>.
      </para></listitem>
    </varlistentry>
    <varlistentry>      <term>mode</term>
      <listitem><para>
The spi mode defines how data is clocked out and in.
This may be changed by the device's driver.
The <quote>active low</quote> default for chipselect mode can be overridden
(by specifying SPI_CS_HIGH) as can the <quote>MSB first</quote> default for
each word in a transfer (by specifying SPI_LSB_FIRST).
      </para></listitem>
    </varlistentry>
    <varlistentry>      <term>bits_per_word</term>
      <listitem><para>
Data transfers involve one or more words; word sizes
like eight or 12 bits are common.  In-memory wordsizes are
powers of two bytes (e.g. 20 bit samples use 32 bits).
This may be changed by the device's driver, or left at the
default (0) indicating protocol words are eight bit bytes.
The spi_transfer.bits_per_word can override this for each transfer.
      </para></listitem>
    </varlistentry>
    <varlistentry>      <term>irq</term>
      <listitem><para>
Negative, or the number passed to <function>request_irq</function> to receive
interrupts from this device.
      </para></listitem>
    </varlistentry>
    <varlistentry>      <term>controller_state</term>
      <listitem><para>
Controller's runtime state
      </para></listitem>
    </varlistentry>
    <varlistentry>      <term>controller_data</term>
      <listitem><para>
Board-specific definitions for controller, such as
FIFO initialization parameters; from board_info.controller_data
      </para></listitem>
    </varlistentry>
    <varlistentry>      <term>modalias[SPI_NAME_SIZE]</term>
      <listitem><para>
Name of the driver to use with this device, or an alias
for that name.  This appears in the sysfs <quote>modalias</quote> attribute
for driver coldplugging, and in uevents used for hotplugging
      </para></listitem>
    </varlistentry>
  </variablelist>
 </refsect1>
<refsect1>
<title>Description</title>
<para>
   A <parameter>spi_device</parameter> is used to interchange data between an SPI slave
   (usually a discrete chip) and CPU memory.
   </para><para>

   In <parameter>dev</parameter>, the platform_data is used to hold information about this
   device that's meaningful to the device's protocol driver, but not
   to its controller.  One example might be an identifier for a chip
   variant with slightly different functionality; another might be
   information about how this particular board wires the chip's pins.
</para>
</refsect1>
</refentry>

<refentry id="API-struct-spi-driver">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>July 2015</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>struct spi_driver</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.4.104</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>struct spi_driver</refname>
 <refpurpose>
     Host side <quote>protocol</quote> driver
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <programlisting>
struct spi_driver {
  const struct spi_device_id * id_table;
  int (* probe) (struct spi_device *spi);
  int (* remove) (struct spi_device *spi);
  void (* shutdown) (struct spi_device *spi);
  int (* suspend) (struct spi_device *spi, pm_message_t mesg);
  int (* resume) (struct spi_device *spi);
  struct device_driver driver;
};  </programlisting>
</refsynopsisdiv>
 <refsect1>
  <title>Members</title>
  <variablelist>
    <varlistentry>      <term>id_table</term>
      <listitem><para>
   List of SPI devices supported by this driver
      </para></listitem>
    </varlistentry>
    <varlistentry>      <term>probe</term>
      <listitem><para>
   Binds this driver to the spi device.  Drivers can verify
   that the device is actually present, and may need to configure
   characteristics (such as bits_per_word) which weren't needed for
   the initial configuration done during system setup.
      </para></listitem>
    </varlistentry>
    <varlistentry>      <term>remove</term>
      <listitem><para>
   Unbinds this driver from the spi device
      </para></listitem>
    </varlistentry>
    <varlistentry>      <term>shutdown</term>
      <listitem><para>
   Standard shutdown callback used during system state
   transitions such as powerdown/halt and kexec
      </para></listitem>
    </varlistentry>
    <varlistentry>      <term>suspend</term>
      <listitem><para>
   Standard suspend callback used during system state transitions
      </para></listitem>
    </varlistentry>
    <varlistentry>      <term>resume</term>
      <listitem><para>
   Standard resume callback used during system state transitions
      </para></listitem>
    </varlistentry>
    <varlistentry>      <term>driver</term>
      <listitem><para>
   SPI device drivers should initialize the name and owner
   field of this structure.
      </para></listitem>
    </varlistentry>
  </variablelist>
 </refsect1>
<refsect1>
<title>Description</title>
<para>
   This represents the kind of device driver that uses SPI messages to
   interact with the hardware at the other end of a SPI link.  It's called
   a <quote>protocol</quote> driver because it works through messages rather than talking
   directly to SPI hardware (which is what the underlying SPI controller
   driver does to pass those messages).  These protocols are defined in the
   specification for the device(s) supported by the driver.
   </para><para>

   As a rule, those device protocols represent the lowest level interface
   supported by a driver, and it will support upper level interfaces too.
   Examples of such upper levels include frameworks like MTD, networking,
   MMC, RTC, filesystem character device nodes, and hardware monitoring.
</para>
</refsect1>
</refentry>

<refentry id="API-spi-unregister-driver">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>July 2015</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>spi_unregister_driver</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.4.104</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>spi_unregister_driver</refname>
 <refpurpose>
     reverse effect of spi_register_driver
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>void <function>spi_unregister_driver </function></funcdef>
   <paramdef>struct spi_driver * <parameter>sdrv</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>sdrv</parameter></term>
   <listitem>
    <para>
     the driver to unregister
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
<title>Context</title>
<para>
   can sleep
</para>
</refsect1>
</refentry>

<refentry id="API-module-spi-driver">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>July 2015</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>module_spi_driver</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.4.104</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>module_spi_driver</refname>
 <refpurpose>
     Helper macro for registering a SPI driver
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef> <function>module_spi_driver </function></funcdef>
   <paramdef> <parameter>__spi_driver</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>__spi_driver</parameter></term>
   <listitem>
    <para>
     spi_driver struct
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
<title>Description</title>
<para>
   Helper macro for SPI drivers which do not do anything special in module
   init/exit. This eliminates a lot of boilerplate. Each module may only
   use this macro once, and calling it replaces <function>module_init</function> and <function>module_exit</function>
</para>
</refsect1>
</refentry>

<refentry id="API-struct-spi-master">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>July 2015</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>struct spi_master</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.4.104</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>struct spi_master</refname>
 <refpurpose>
     interface to SPI master controller
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <programlisting>
struct spi_master {
  struct device dev;
  struct list_head list;
  s16 bus_num;
  u16 num_chipselect;
  u16 dma_alignment;
  u16 mode_bits;
  u16 flags;
#define SPI_MASTER_HALF_DUPLEX	BIT(0)
#define SPI_MASTER_NO_RX	BIT(1)
#define SPI_MASTER_NO_TX	BIT(2)
  spinlock_t bus_lock_spinlock;
  struct mutex bus_lock_mutex;
  bool bus_lock_flag;
  int (* setup) (struct spi_device *spi);
  int (* transfer) (struct spi_device *spi,struct spi_message *mesg);
  void (* cleanup) (struct spi_device *spi);
  bool queued;
  struct kthread_worker kworker;
  struct task_struct * kworker_task;
  struct kthread_work pump_messages;
  spinlock_t queue_lock;
  struct list_head queue;
  struct spi_message * cur_msg;
  bool busy;
  bool running;
  bool rt;
  int (* prepare_transfer_hardware) (struct spi_master *master);
  int (* transfer_one_message) (struct spi_master *master,struct spi_message *mesg);
  int (* unprepare_transfer_hardware) (struct spi_master *master);
};  </programlisting>
</refsynopsisdiv>
 <refsect1>
  <title>Members</title>
  <variablelist>
    <varlistentry>      <term>dev</term>
      <listitem><para>
   device interface to this driver
      </para></listitem>
    </varlistentry>
    <varlistentry>      <term>list</term>
      <listitem><para>
   link with the global spi_master list
      </para></listitem>
    </varlistentry>
    <varlistentry>      <term>bus_num</term>
      <listitem><para>
   board-specific (and often SOC-specific) identifier for a
   given SPI controller.
      </para></listitem>
    </varlistentry>
    <varlistentry>      <term>num_chipselect</term>
      <listitem><para>
   chipselects are used to distinguish individual
   SPI slaves, and are numbered from zero to num_chipselects.
   each slave has a chipselect signal, but it's common that not
   every chipselect is connected to a slave.
      </para></listitem>
    </varlistentry>
    <varlistentry>      <term>dma_alignment</term>
      <listitem><para>
   SPI controller constraint on DMA buffers alignment.
      </para></listitem>
    </varlistentry>
    <varlistentry>      <term>mode_bits</term>
      <listitem><para>
   flags understood by this controller driver
      </para></listitem>
    </varlistentry>
    <varlistentry>      <term>flags</term>
      <listitem><para>
   other constraints relevant to this driver
      </para></listitem>
    </varlistentry>
    <varlistentry>      <term>bus_lock_spinlock</term>
      <listitem><para>
   spinlock for SPI bus locking
      </para></listitem>
    </varlistentry>
    <varlistentry>      <term>bus_lock_mutex</term>
      <listitem><para>
   mutex for SPI bus locking
      </para></listitem>
    </varlistentry>
    <varlistentry>      <term>bus_lock_flag</term>
      <listitem><para>
   indicates that the SPI bus is locked for exclusive use
      </para></listitem>
    </varlistentry>
    <varlistentry>      <term>setup</term>
      <listitem><para>
   updates the device mode and clocking records used by a
   device's SPI controller; protocol code may call this.  This
   must fail if an unrecognized or unsupported mode is requested.
   It's always safe to call this unless transfers are pending on
   the device whose settings are being modified.
      </para></listitem>
    </varlistentry>
    <varlistentry>      <term>transfer</term>
      <listitem><para>
   adds a message to the controller's transfer queue.
      </para></listitem>
    </varlistentry>
    <varlistentry>      <term>cleanup</term>
      <listitem><para>
   frees controller-specific state
      </para></listitem>
    </varlistentry>
    <varlistentry>      <term>queued</term>
      <listitem><para>
   whether this master is providing an internal message queue
      </para></listitem>
    </varlistentry>
    <varlistentry>      <term>kworker</term>
      <listitem><para>
   thread struct for message pump
      </para></listitem>
    </varlistentry>
    <varlistentry>      <term>kworker_task</term>
      <listitem><para>
   pointer to task for message pump kworker thread
      </para></listitem>
    </varlistentry>
    <varlistentry>      <term>pump_messages</term>
      <listitem><para>
   work struct for scheduling work to the message pump
      </para></listitem>
    </varlistentry>
    <varlistentry>      <term>queue_lock</term>
      <listitem><para>
   spinlock to syncronise access to message queue
      </para></listitem>
    </varlistentry>
    <varlistentry>      <term>queue</term>
      <listitem><para>
   message queue
      </para></listitem>
    </varlistentry>
    <varlistentry>      <term>cur_msg</term>
      <listitem><para>
   the currently in-flight message
      </para></listitem>
    </varlistentry>
    <varlistentry>      <term>busy</term>
      <listitem><para>
   message pump is busy
      </para></listitem>
    </varlistentry>
    <varlistentry>      <term>running</term>
      <listitem><para>
   message pump is running
      </para></listitem>
    </varlistentry>
    <varlistentry>      <term>rt</term>
      <listitem><para>
   whether this queue is set to run as a realtime task
      </para></listitem>
    </varlistentry>
    <varlistentry>      <term>prepare_transfer_hardware</term>
      <listitem><para>
   a message will soon arrive from the queue
   so the subsystem requests the driver to prepare the transfer hardware
   by issuing this call
      </para></listitem>
    </varlistentry>
    <varlistentry>      <term>transfer_one_message</term>
      <listitem><para>
   the subsystem calls the driver to transfer a single
   message while queuing transfers that arrive in the meantime. When the
   driver is finished with this message, it must call
   <function>spi_finalize_current_message</function> so the subsystem can issue the next
   transfer
      </para></listitem>
    </varlistentry>
    <varlistentry>      <term>unprepare_transfer_hardware</term>
      <listitem><para>
   there are currently no more messages on the
   queue so the subsystem notifies the driver that it may relax the
   hardware by issuing this call
      </para></listitem>
    </varlistentry>
  </variablelist>
 </refsect1>
<refsect1>
<title>Description</title>
<para>
   Each SPI master controller can communicate with one or more <parameter>spi_device</parameter>
   children.  These make a small bus, sharing MOSI, MISO and SCK signals
   but not chip select signals.  Each device may be configured to use a
   different clock rate, since those shared signals are ignored unless
   the chip is selected.
   </para><para>

   The driver for an SPI controller manages access to those devices through
   a queue of spi_message transactions, copying data between CPU memory and
   an SPI slave device.  For each such message it queues, it calls the
   message's completion function when the transaction completes.
</para>
</refsect1>
</refentry>

<refentry id="API-struct-spi-transfer">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>July 2015</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>struct spi_transfer</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.4.104</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>struct spi_transfer</refname>
 <refpurpose>
     a read/write buffer pair
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <programlisting>
struct spi_transfer {
  const void * tx_buf;
  void * rx_buf;
  unsigned len;
  dma_addr_t tx_dma;
  dma_addr_t rx_dma;
  unsigned cs_change:1;
  u8 bits_per_word;
  u16 delay_usecs;
  u32 speed_hz;
  struct list_head transfer_list;
};  </programlisting>
</refsynopsisdiv>
 <refsect1>
  <title>Members</title>
  <variablelist>
    <varlistentry>      <term>tx_buf</term>
      <listitem><para>
   data to be written (dma-safe memory), or NULL
      </para></listitem>
    </varlistentry>
    <varlistentry>      <term>rx_buf</term>
      <listitem><para>
   data to be read (dma-safe memory), or NULL
      </para></listitem>
    </varlistentry>
    <varlistentry>      <term>len</term>
      <listitem><para>
   size of rx and tx buffers (in bytes)
      </para></listitem>
    </varlistentry>
    <varlistentry>      <term>tx_dma</term>
      <listitem><para>
   DMA address of tx_buf, if <parameter>spi_message</parameter>.is_dma_mapped
      </para></listitem>
    </varlistentry>
    <varlistentry>      <term>rx_dma</term>
      <listitem><para>
   DMA address of rx_buf, if <parameter>spi_message</parameter>.is_dma_mapped
      </para></listitem>
    </varlistentry>
    <varlistentry>      <term>cs_change</term>
      <listitem><para>
   affects chipselect after this transfer completes
      </para></listitem>
    </varlistentry>
    <varlistentry>      <term>bits_per_word</term>
      <listitem><para>
   select a bits_per_word other than the device default
   for this transfer. If 0 the default (from <parameter>spi_device</parameter>) is used.
      </para></listitem>
    </varlistentry>
    <varlistentry>      <term>delay_usecs</term>
      <listitem><para>
   microseconds to delay after this transfer before
   (optionally) changing the chipselect status, then starting
   the next transfer or completing this <parameter>spi_message</parameter>.
      </para></listitem>
    </varlistentry>
    <varlistentry>      <term>speed_hz</term>
      <listitem><para>
   Select a speed other than the device default for this
   transfer. If 0 the default (from <parameter>spi_device</parameter>) is used.
      </para></listitem>
    </varlistentry>
    <varlistentry>      <term>transfer_list</term>
      <listitem><para>
   transfers are sequenced through <parameter>spi_message</parameter>.transfers
      </para></listitem>
    </varlistentry>
  </variablelist>
 </refsect1>
<refsect1>
<title>Description</title>
<para>
   SPI transfers always write the same number of bytes as they read.
   Protocol drivers should always provide <parameter>rx_buf</parameter> and/or <parameter>tx_buf</parameter>.
   In some cases, they may also want to provide DMA addresses for
   the data being transferred; that may reduce overhead, when the
   underlying driver uses dma.
   </para><para>

   If the transmit buffer is null, zeroes will be shifted out
   while filling <parameter>rx_buf</parameter>.  If the receive buffer is null, the data
   shifted in will be discarded.  Only <quote>len</quote> bytes shift out (or in).
   It's an error to try to shift out a partial word.  (For example, by
   shifting out three bytes with word size of sixteen or twenty bits;
   the former uses two bytes per word, the latter uses four bytes.)
   </para><para>

   In-memory data values are always in native CPU byte order, translated
   from the wire byte order (big-endian except with SPI_LSB_FIRST).  So
   for example when bits_per_word is sixteen, buffers are 2N bytes long
   (<parameter>len</parameter> = 2N) and hold N sixteen bit words in CPU byte order.
   </para><para>

   When the word size of the SPI transfer is not a power-of-two multiple
   of eight bits, those in-memory words include extra bits.  In-memory
   words are always seen by protocol drivers as right-justified, so the
   undefined (rx) or unused (tx) bits are always the most significant bits.
   </para><para>

   All SPI transfers start with the relevant chipselect active.  Normally
   it stays selected until after the last transfer in a message.  Drivers
   can affect the chipselect signal using cs_change.
   </para><para>

   (i) If the transfer isn't the last one in the message, this flag is
   used to make the chipselect briefly go inactive in the middle of the
   message.  Toggling chipselect in this way may be needed to terminate
   a chip command, letting a single spi_message perform all of group of
   chip transactions together.
   </para><para>

   (ii) When the transfer is the last one in the message, the chip may
   stay selected until the next transfer.  On multi-device SPI busses
   with nothing blocking messages going to other devices, this is just
   a performance hint; starting a message to another device deselects
   this one.  But in other cases, this can be used to ensure correctness.
   Some devices need protocol transactions to be built from a series of
   spi_message submissions, where the content of one message is determined
   by the results of previous messages and where the whole transaction
   ends when the chipselect goes intactive.
   </para><para>

   The code that submits an spi_message (and its spi_transfers)
   to the lower layers is responsible for managing its memory.
   Zero-initialize every field you don't set up explicitly, to
   insulate against future API updates.  After you submit a message
   and its transfers, ignore them until its completion callback.
</para>
</refsect1>
</refentry>

<refentry id="API-struct-spi-message">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>July 2015</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>struct spi_message</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.4.104</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>struct spi_message</refname>
 <refpurpose>
     one multi-segment SPI transaction
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <programlisting>
struct spi_message {
  struct list_head transfers;
  struct spi_device * spi;
  unsigned is_dma_mapped:1;
  void (* complete) (void *context);
  void * context;
  unsigned actual_length;
  int status;
  struct list_head queue;
  void * state;
};  </programlisting>
</refsynopsisdiv>
 <refsect1>
  <title>Members</title>
  <variablelist>
    <varlistentry>      <term>transfers</term>
      <listitem><para>
   list of transfer segments in this transaction
      </para></listitem>
    </varlistentry>
    <varlistentry>      <term>spi</term>
      <listitem><para>
   SPI device to which the transaction is queued
      </para></listitem>
    </varlistentry>
    <varlistentry>      <term>is_dma_mapped</term>
      <listitem><para>
   if true, the caller provided both dma and cpu virtual
   addresses for each transfer buffer
      </para></listitem>
    </varlistentry>
    <varlistentry>      <term>complete</term>
      <listitem><para>
   called to report transaction completions
      </para></listitem>
    </varlistentry>
    <varlistentry>      <term>context</term>
      <listitem><para>
   the argument to <function>complete</function> when it's called
      </para></listitem>
    </varlistentry>
    <varlistentry>      <term>actual_length</term>
      <listitem><para>
   the total number of bytes that were transferred in all
   successful segments
      </para></listitem>
    </varlistentry>
    <varlistentry>      <term>status</term>
      <listitem><para>
   zero for success, else negative errno
      </para></listitem>
    </varlistentry>
    <varlistentry>      <term>queue</term>
      <listitem><para>
   for use by whichever driver currently owns the message
      </para></listitem>
    </varlistentry>
    <varlistentry>      <term>state</term>
      <listitem><para>
   for use by whichever driver currently owns the message
      </para></listitem>
    </varlistentry>
  </variablelist>
 </refsect1>
<refsect1>
<title>Description</title>
<para>
   A <parameter>spi_message</parameter> is used to execute an atomic sequence of data transfers,
   each represented by a struct spi_transfer.  The sequence is <quote>atomic</quote>
   in the sense that no other spi_message may use that SPI bus until that
   sequence completes.  On some systems, many such sequences can execute as
   as single programmed DMA transfer.  On all systems, these messages are
   queued, and might complete after transactions to other devices.  Messages
   sent to a given spi_device are alway executed in FIFO order.
   </para><para>

   The code that submits an spi_message (and its spi_transfers)
   to the lower layers is responsible for managing its memory.
   Zero-initialize every field you don't set up explicitly, to
   insulate against future API updates.  After you submit a message
   and its transfers, ignore them until its completion callback.
</para>
</refsect1>
</refentry>

<refentry id="API-spi-write">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>July 2015</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>spi_write</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.4.104</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>spi_write</refname>
 <refpurpose>
     SPI synchronous write
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>int <function>spi_write </function></funcdef>
   <paramdef>struct spi_device * <parameter>spi</parameter></paramdef>
   <paramdef>const void * <parameter>buf</parameter></paramdef>
   <paramdef>size_t <parameter>len</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>spi</parameter></term>
   <listitem>
    <para>
     device to which data will be written
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>buf</parameter></term>
   <listitem>
    <para>
     data buffer
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>len</parameter></term>
   <listitem>
    <para>
     data buffer size
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
<title>Context</title>
<para>
   can sleep
</para>
</refsect1>
<refsect1>
<title>Description</title>
<para>
   This writes the buffer and returns zero or a negative error code.
   Callable only from contexts that can sleep.
</para>
</refsect1>
</refentry>

<refentry id="API-spi-read">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>July 2015</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>spi_read</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.4.104</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>spi_read</refname>
 <refpurpose>
     SPI synchronous read
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>int <function>spi_read </function></funcdef>
   <paramdef>struct spi_device * <parameter>spi</parameter></paramdef>
   <paramdef>void * <parameter>buf</parameter></paramdef>
   <paramdef>size_t <parameter>len</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>spi</parameter></term>
   <listitem>
    <para>
     device from which data will be read
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>buf</parameter></term>
   <listitem>
    <para>
     data buffer
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>len</parameter></term>
   <listitem>
    <para>
     data buffer size
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
<title>Context</title>
<para>
   can sleep
</para>
</refsect1>
<refsect1>
<title>Description</title>
<para>
   This reads the buffer and returns zero or a negative error code.
   Callable only from contexts that can sleep.
</para>
</refsect1>
</refentry>

<refentry id="API-spi-w8r8">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>July 2015</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>spi_w8r8</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.4.104</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>spi_w8r8</refname>
 <refpurpose>
     SPI synchronous 8 bit write followed by 8 bit read
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>ssize_t <function>spi_w8r8 </function></funcdef>
   <paramdef>struct spi_device * <parameter>spi</parameter></paramdef>
   <paramdef>u8 <parameter>cmd</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>spi</parameter></term>
   <listitem>
    <para>
     device with which data will be exchanged
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>cmd</parameter></term>
   <listitem>
    <para>
     command to be written before data is read back
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
<title>Context</title>
<para>
   can sleep
</para>
</refsect1>
<refsect1>
<title>Description</title>
<para>
   This returns the (unsigned) eight bit number returned by the
   device, or else a negative error code.  Callable only from
   contexts that can sleep.
</para>
</refsect1>
</refentry>

<refentry id="API-spi-w8r16">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>July 2015</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>spi_w8r16</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.4.104</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>spi_w8r16</refname>
 <refpurpose>
     SPI synchronous 8 bit write followed by 16 bit read
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>ssize_t <function>spi_w8r16 </function></funcdef>
   <paramdef>struct spi_device * <parameter>spi</parameter></paramdef>
   <paramdef>u8 <parameter>cmd</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>spi</parameter></term>
   <listitem>
    <para>
     device with which data will be exchanged
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>cmd</parameter></term>
   <listitem>
    <para>
     command to be written before data is read back
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
<title>Context</title>
<para>
   can sleep
</para>
</refsect1>
<refsect1>
<title>Description</title>
<para>
   This returns the (unsigned) sixteen bit number returned by the
   device, or else a negative error code.  Callable only from
   contexts that can sleep.
   </para><para>

   The number is returned in wire-order, which is at least sometimes
   big-endian.
</para>
</refsect1>
</refentry>

<refentry id="API-struct-spi-board-info">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>July 2015</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>struct spi_board_info</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.4.104</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>struct spi_board_info</refname>
 <refpurpose>
     board-specific template for a SPI device
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <programlisting>
struct spi_board_info {
  char modalias[SPI_NAME_SIZE];
  const void * platform_data;
  void * controller_data;
  int irq;
  u32 max_speed_hz;
  u16 bus_num;
  u16 chip_select;
  u8 mode;
};  </programlisting>
</refsynopsisdiv>
 <refsect1>
  <title>Members</title>
  <variablelist>
    <varlistentry>      <term>modalias[SPI_NAME_SIZE]</term>
      <listitem><para>
   Initializes spi_device.modalias; identifies the driver.
      </para></listitem>
    </varlistentry>
    <varlistentry>      <term>platform_data</term>
      <listitem><para>
   Initializes spi_device.platform_data; the particular
   data stored there is driver-specific.
      </para></listitem>
    </varlistentry>
    <varlistentry>      <term>controller_data</term>
      <listitem><para>
   Initializes spi_device.controller_data; some
   controllers need hints about hardware setup, e.g. for DMA.
      </para></listitem>
    </varlistentry>
    <varlistentry>      <term>irq</term>
      <listitem><para>
   Initializes spi_device.irq; depends on how the board is wired.
      </para></listitem>
    </varlistentry>
    <varlistentry>      <term>max_speed_hz</term>
      <listitem><para>
   Initializes spi_device.max_speed_hz; based on limits
   from the chip datasheet and board-specific signal quality issues.
      </para></listitem>
    </varlistentry>
    <varlistentry>      <term>bus_num</term>
      <listitem><para>
   Identifies which spi_master parents the spi_device; unused
   by <function>spi_new_device</function>, and otherwise depends on board wiring.
      </para></listitem>
    </varlistentry>
    <varlistentry>      <term>chip_select</term>
      <listitem><para>
   Initializes spi_device.chip_select; depends on how
   the board is wired.
      </para></listitem>
    </varlistentry>
    <varlistentry>      <term>mode</term>
      <listitem><para>
   Initializes spi_device.mode; based on the chip datasheet, board
   wiring (some devices support both 3WIRE and standard modes), and
   possibly presence of an inverter in the chipselect path.
      </para></listitem>
    </varlistentry>
  </variablelist>
 </refsect1>
<refsect1>
<title>Description</title>
<para>
   When adding new SPI devices to the device tree, these structures serve
   as a partial device template.  They hold information which can't always
   be determined by drivers.  Information that <function>probe</function> can establish (such
   as the default transfer wordsize) is not included here.
   </para><para>

   These structures are used in two places.  Their primary role is to
   be stored in tables of board-specific device descriptors, which are
   declared early in board initialization and then used (much later) to
   populate a controller's device tree after the that controller's driver
   initializes.  A secondary (and atypical) role is as a parameter to
   <function>spi_new_device</function> call, which happens after those controller drivers
   are active in some dynamic board configuration models.
</para>
</refsect1>
</refentry>

<refentry id="API-spi-register-board-info">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>July 2015</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>spi_register_board_info</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.4.104</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>spi_register_board_info</refname>
 <refpurpose>
  register SPI devices for a given board
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>int <function>spi_register_board_info </function></funcdef>
   <paramdef>struct spi_board_info const * <parameter>info</parameter></paramdef>
   <paramdef>unsigned <parameter>n</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>info</parameter></term>
   <listitem>
    <para>
     array of chip descriptors
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>n</parameter></term>
   <listitem>
    <para>
     how many descriptors are provided
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
<title>Context</title>
<para>
   can sleep
</para>
</refsect1>
<refsect1>
<title>Description</title>
<para>
   Board-specific early init code calls this (probably during arch_initcall)
   with segments of the SPI device table.  Any device nodes are created later,
   after the relevant parent SPI controller (bus_num) is defined.  We keep
   this table of devices forever, so that reloading a controller driver will
   not make Linux forget about these hard-wired devices.
   </para><para>

   Other code can also call this, e.g. a particular add-on board might provide
   SPI devices through its expansion connector, so code initializing that board
   would naturally declare its SPI devices.
   </para><para>

   The board info passed can safely be __initdata ... but be careful of
   any embedded pointers (platform_data, etc), they're copied as-is.
</para>
</refsect1>
</refentry>

<!-- drivers/spi/spi.c -->
<refentry id="API-spi-register-driver">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>July 2015</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>spi_register_driver</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.4.104</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>spi_register_driver</refname>
 <refpurpose>
  register a SPI driver
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>int <function>spi_register_driver </function></funcdef>
   <paramdef>struct spi_driver * <parameter>sdrv</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>sdrv</parameter></term>
   <listitem>
    <para>
     the driver to register
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
<title>Context</title>
<para>
   can sleep
</para>
</refsect1>
</refentry>

<refentry id="API-spi-alloc-device">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>July 2015</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>spi_alloc_device</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.4.104</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>spi_alloc_device</refname>
 <refpurpose>
     Allocate a new SPI device
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>struct spi_device * <function>spi_alloc_device </function></funcdef>
   <paramdef>struct spi_master * <parameter>master</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>master</parameter></term>
   <listitem>
    <para>
     Controller to which device is connected
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
<title>Context</title>
<para>
   can sleep
</para>
</refsect1>
<refsect1>
<title>Description</title>
<para>
   Allows a driver to allocate and initialize a spi_device without
   registering it immediately.  This allows a driver to directly
   fill the spi_device with device parameters before calling
   <function>spi_add_device</function> on it.
   </para><para>

   Caller is responsible to call <function>spi_add_device</function> on the returned
   spi_device structure to add it to the SPI master.  If the caller
   needs to discard the spi_device without adding it, then it should
   call <function>spi_dev_put</function> on it.
   </para><para>

   Returns a pointer to the new device, or NULL.
</para>
</refsect1>
</refentry>

<refentry id="API-spi-add-device">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>July 2015</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>spi_add_device</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.4.104</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>spi_add_device</refname>
 <refpurpose>
     Add spi_device allocated with spi_alloc_device
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>int <function>spi_add_device </function></funcdef>
   <paramdef>struct spi_device * <parameter>spi</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>spi</parameter></term>
   <listitem>
    <para>
     spi_device to register
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
<title>Description</title>
<para>
   Companion function to spi_alloc_device.  Devices allocated with
   spi_alloc_device can be added onto the spi bus with this function.
   </para><para>

   Returns 0 on success; negative errno on failure
</para>
</refsect1>
</refentry>

<refentry id="API-spi-new-device">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>July 2015</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>spi_new_device</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.4.104</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>spi_new_device</refname>
 <refpurpose>
     instantiate one new SPI device
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>struct spi_device * <function>spi_new_device </function></funcdef>
   <paramdef>struct spi_master * <parameter>master</parameter></paramdef>
   <paramdef>struct spi_board_info * <parameter>chip</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>master</parameter></term>
   <listitem>
    <para>
     Controller to which device is connected
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>chip</parameter></term>
   <listitem>
    <para>
     Describes the SPI device
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
<title>Context</title>
<para>
   can sleep
</para>
</refsect1>
<refsect1>
<title>Description</title>
<para>
   On typical mainboards, this is purely internal; and it's not needed
   after board init creates the hard-wired devices.  Some development
   platforms may not be able to use spi_register_board_info though, and
   this is exported so that for example a USB or parport based adapter
   driver could add devices (which it would learn about out-of-band).
   </para><para>

   Returns the new device, or NULL.
</para>
</refsect1>
</refentry>

<refentry id="API-spi-get-next-queued-message">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>July 2015</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>spi_get_next_queued_message</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.4.104</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>spi_get_next_queued_message</refname>
 <refpurpose>
     called by driver to check for queued messages
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>struct spi_message * <function>spi_get_next_queued_message </function></funcdef>
   <paramdef>struct spi_master * <parameter>master</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>master</parameter></term>
   <listitem>
    <para>
     the master to check for queued messages
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
<title>Description</title>
<para>
   If there are more messages in the queue, the next message is returned from
   this call.
</para>
</refsect1>
</refentry>

<refentry id="API-spi-finalize-current-message">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>July 2015</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>spi_finalize_current_message</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.4.104</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>spi_finalize_current_message</refname>
 <refpurpose>
     the current message is complete
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>void <function>spi_finalize_current_message </function></funcdef>
   <paramdef>struct spi_master * <parameter>master</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>master</parameter></term>
   <listitem>
    <para>
     the master to return the message to
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
<title>Description</title>
<para>
   Called by the driver to notify the core that the message in the front of the
   queue is complete and can be removed from the queue.
</para>
</refsect1>
</refentry>

<refentry id="API-spi-alloc-master">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>July 2015</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>spi_alloc_master</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.4.104</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>spi_alloc_master</refname>
 <refpurpose>
     allocate SPI master controller
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>struct spi_master * <function>spi_alloc_master </function></funcdef>
   <paramdef>struct device * <parameter>dev</parameter></paramdef>
   <paramdef>unsigned <parameter>size</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>dev</parameter></term>
   <listitem>
    <para>
     the controller, possibly using the platform_bus
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>size</parameter></term>
   <listitem>
    <para>
     how much zeroed driver-private data to allocate; the pointer to this
     memory is in the driver_data field of the returned device,
     accessible with <function>spi_master_get_devdata</function>.
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
<title>Context</title>
<para>
   can sleep
</para>
</refsect1>
<refsect1>
<title>Description</title>
<para>
   This call is used only by SPI master controller drivers, which are the
   only ones directly touching chip registers.  It's how they allocate
   an spi_master structure, prior to calling <function>spi_register_master</function>.
   </para><para>

   This must be called from context that can sleep.  It returns the SPI
   master structure on success, else NULL.
   </para><para>

   The caller is responsible for assigning the bus number and initializing
   the master's methods before calling <function>spi_register_master</function>; and (after errors
   adding the device) calling <function>spi_master_put</function> and <function>kfree</function> to prevent a memory
   leak.
</para>
</refsect1>
</refentry>

<refentry id="API-spi-register-master">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>July 2015</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>spi_register_master</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.4.104</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>spi_register_master</refname>
 <refpurpose>
     register SPI master controller
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>int <function>spi_register_master </function></funcdef>
   <paramdef>struct spi_master * <parameter>master</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>master</parameter></term>
   <listitem>
    <para>
     initialized master, originally from <function>spi_alloc_master</function>
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
<title>Context</title>
<para>
   can sleep
</para>
</refsect1>
<refsect1>
<title>Description</title>
<para>
   SPI master controllers connect to their drivers using some non-SPI bus,
   such as the platform bus.  The final stage of <function>probe</function> in that code
   includes calling <function>spi_register_master</function> to hook up to this SPI bus glue.
   </para><para>

   SPI controllers use board specific (often SOC specific) bus numbers,
   and board-specific addressing for SPI devices combines those numbers
   with chip select numbers.  Since SPI does not directly support dynamic
   device identification, boards need configuration tables telling which
   chip is at which address.
   </para><para>

   This must be called from context that can sleep.  It returns zero on
   success, else a negative error code (dropping the master's refcount).
   After a successful return, the caller is responsible for calling
   <function>spi_unregister_master</function>.
</para>
</refsect1>
</refentry>

<refentry id="API-spi-unregister-master">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>July 2015</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>spi_unregister_master</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.4.104</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>spi_unregister_master</refname>
 <refpurpose>
     unregister SPI master controller
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>void <function>spi_unregister_master </function></funcdef>
   <paramdef>struct spi_master * <parameter>master</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>master</parameter></term>
   <listitem>
    <para>
     the master being unregistered
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
<title>Context</title>
<para>
   can sleep
</para>
</refsect1>
<refsect1>
<title>Description</title>
<para>
   This call is used only by SPI master controller drivers, which are the
   only ones directly touching chip registers.
   </para><para>

   This must be called from context that can sleep.
</para>
</refsect1>
</refentry>

<refentry id="API-spi-busnum-to-master">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>July 2015</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>spi_busnum_to_master</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.4.104</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>spi_busnum_to_master</refname>
 <refpurpose>
     look up master associated with bus_num
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>struct spi_master * <function>spi_busnum_to_master </function></funcdef>
   <paramdef>u16 <parameter>bus_num</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>bus_num</parameter></term>
   <listitem>
    <para>
     the master's bus number
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
<title>Context</title>
<para>
   can sleep
</para>
</refsect1>
<refsect1>
<title>Description</title>
<para>
   This call may be used with devices that are registered after
   arch init time.  It returns a refcounted pointer to the relevant
   spi_master (which the caller must release), or NULL if there is
   no such master registered.
</para>
</refsect1>
</refentry>

<refentry id="API-spi-setup">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>July 2015</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>spi_setup</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.4.104</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>spi_setup</refname>
 <refpurpose>
     setup SPI mode and clock rate
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>int <function>spi_setup </function></funcdef>
   <paramdef>struct spi_device * <parameter>spi</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>spi</parameter></term>
   <listitem>
    <para>
     the device whose settings are being modified
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
<title>Context</title>
<para>
   can sleep, and no requests are queued to the device
</para>
</refsect1>
<refsect1>
<title>Description</title>
<para>
   SPI protocol drivers may need to update the transfer mode if the
   device doesn't work with its default.  They may likewise need
   to update clock rates or word sizes from initial values.  This function
   changes those settings, and must be called from a context that can sleep.
   Except for SPI_CS_HIGH, which takes effect immediately, the changes take
   effect the next time the device is selected and data is transferred to
   or from it.  When this function returns, the spi device is deselected.
   </para><para>

   Note that this call will fail if the protocol driver specifies an option
   that the underlying controller or its driver does not support.  For
   example, not all hardware supports wire transfers using nine bit words,
   LSB-first wire encoding, or active-high chipselects.
</para>
</refsect1>
</refentry>

<refentry id="API-spi-async">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>July 2015</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>spi_async</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.4.104</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>spi_async</refname>
 <refpurpose>
     asynchronous SPI transfer
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>int <function>spi_async </function></funcdef>
   <paramdef>struct spi_device * <parameter>spi</parameter></paramdef>
   <paramdef>struct spi_message * <parameter>message</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>spi</parameter></term>
   <listitem>
    <para>
     device with which data will be exchanged
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>message</parameter></term>
   <listitem>
    <para>
     describes the data transfers, including completion callback
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
<title>Context</title>
<para>
   any (irqs may be blocked, etc)
</para>
</refsect1>
<refsect1>
<title>Description</title>
<para>
   This call may be used in_irq and other contexts which can't sleep,
   as well as from task contexts which can sleep.
   </para><para>

   The completion callback is invoked in a context which can't sleep.
   Before that invocation, the value of message-&gt;status is undefined.
   When the callback is issued, message-&gt;status holds either zero (to
   indicate complete success) or a negative error code.  After that
   callback returns, the driver which issued the transfer request may
   deallocate the associated memory; it's no longer in use by any SPI
   core or controller driver code.
   </para><para>

   Note that although all messages to a spi_device are handled in
   FIFO order, messages may go to different devices in other orders.
   Some device might be higher priority, or have various <quote>hard</quote> access
   time requirements, for example.
   </para><para>

   On detection of any fault during the transfer, processing of
   the entire message is aborted, and the device is deselected.
   Until returning from the associated message completion callback,
   no other spi_message queued to that device will be processed.
   (This rule applies equally to all the synchronous transfer calls,
   which are wrappers around this core asynchronous primitive.)
</para>
</refsect1>
</refentry>

<refentry id="API-spi-async-locked">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>July 2015</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>spi_async_locked</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.4.104</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>spi_async_locked</refname>
 <refpurpose>
     version of spi_async with exclusive bus usage
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>int <function>spi_async_locked </function></funcdef>
   <paramdef>struct spi_device * <parameter>spi</parameter></paramdef>
   <paramdef>struct spi_message * <parameter>message</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>spi</parameter></term>
   <listitem>
    <para>
     device with which data will be exchanged
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>message</parameter></term>
   <listitem>
    <para>
     describes the data transfers, including completion callback
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
<title>Context</title>
<para>
   any (irqs may be blocked, etc)
</para>
</refsect1>
<refsect1>
<title>Description</title>
<para>
   This call may be used in_irq and other contexts which can't sleep,
   as well as from task contexts which can sleep.
   </para><para>

   The completion callback is invoked in a context which can't sleep.
   Before that invocation, the value of message-&gt;status is undefined.
   When the callback is issued, message-&gt;status holds either zero (to
   indicate complete success) or a negative error code.  After that
   callback returns, the driver which issued the transfer request may
   deallocate the associated memory; it's no longer in use by any SPI
   core or controller driver code.
   </para><para>

   Note that although all messages to a spi_device are handled in
   FIFO order, messages may go to different devices in other orders.
   Some device might be higher priority, or have various <quote>hard</quote> access
   time requirements, for example.
   </para><para>

   On detection of any fault during the transfer, processing of
   the entire message is aborted, and the device is deselected.
   Until returning from the associated message completion callback,
   no other spi_message queued to that device will be processed.
   (This rule applies equally to all the synchronous transfer calls,
   which are wrappers around this core asynchronous primitive.)
</para>
</refsect1>
</refentry>

<refentry id="API-spi-sync">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>July 2015</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>spi_sync</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.4.104</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>spi_sync</refname>
 <refpurpose>
     blocking/synchronous SPI data transfers
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>int <function>spi_sync </function></funcdef>
   <paramdef>struct spi_device * <parameter>spi</parameter></paramdef>
   <paramdef>struct spi_message * <parameter>message</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>spi</parameter></term>
   <listitem>
    <para>
     device with which data will be exchanged
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>message</parameter></term>
   <listitem>
    <para>
     describes the data transfers
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
<title>Context</title>
<para>
   can sleep
</para>
</refsect1>
<refsect1>
<title>Description</title>
<para>
   This call may only be used from a context that may sleep.  The sleep
   is non-interruptible, and has no timeout.  Low-overhead controller
   drivers may DMA directly into and out of the message buffers.
   </para><para>

   Note that the SPI device's chip select is active during the message,
   and then is normally disabled between messages.  Drivers for some
   frequently-used devices may want to minimize costs of selecting a chip,
   by leaving it selected in anticipation that the next message will go
   to the same chip.  (That may increase power usage.)
   </para><para>

   Also, the caller is guaranteeing that the memory associated with the
   message will not be freed before this call returns.
   </para><para>

   It returns zero on success, else a negative error code.
</para>
</refsect1>
</refentry>

<refentry id="API-spi-sync-locked">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>July 2015</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>spi_sync_locked</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.4.104</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>spi_sync_locked</refname>
 <refpurpose>
     version of spi_sync with exclusive bus usage
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>int <function>spi_sync_locked </function></funcdef>
   <paramdef>struct spi_device * <parameter>spi</parameter></paramdef>
   <paramdef>struct spi_message * <parameter>message</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>spi</parameter></term>
   <listitem>
    <para>
     device with which data will be exchanged
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>message</parameter></term>
   <listitem>
    <para>
     describes the data transfers
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
<title>Context</title>
<para>
   can sleep
</para>
</refsect1>
<refsect1>
<title>Description</title>
<para>
   This call may only be used from a context that may sleep.  The sleep
   is non-interruptible, and has no timeout.  Low-overhead controller
   drivers may DMA directly into and out of the message buffers.
   </para><para>

   This call should be used by drivers that require exclusive access to the
   SPI bus. It has to be preceded by a spi_bus_lock call. The SPI bus must
   be released by a spi_bus_unlock call when the exclusive access is over.
   </para><para>

   It returns zero on success, else a negative error code.
</para>
</refsect1>
</refentry>

<refentry id="API-spi-bus-lock">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>July 2015</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>spi_bus_lock</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.4.104</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>spi_bus_lock</refname>
 <refpurpose>
     obtain a lock for exclusive SPI bus usage
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>int <function>spi_bus_lock </function></funcdef>
   <paramdef>struct spi_master * <parameter>master</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>master</parameter></term>
   <listitem>
    <para>
     SPI bus master that should be locked for exclusive bus access
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
<title>Context</title>
<para>
   can sleep
</para>
</refsect1>
<refsect1>
<title>Description</title>
<para>
   This call may only be used from a context that may sleep.  The sleep
   is non-interruptible, and has no timeout.
   </para><para>

   This call should be used by drivers that require exclusive access to the
   SPI bus. The SPI bus must be released by a spi_bus_unlock call when the
   exclusive access is over. Data transfer must be done by spi_sync_locked
   and spi_async_locked calls when the SPI bus lock is held.
   </para><para>

   It returns zero on success, else a negative error code.
</para>
</refsect1>
</refentry>

<refentry id="API-spi-bus-unlock">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>July 2015</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>spi_bus_unlock</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.4.104</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>spi_bus_unlock</refname>
 <refpurpose>
     release the lock for exclusive SPI bus usage
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>int <function>spi_bus_unlock </function></funcdef>
   <paramdef>struct spi_master * <parameter>master</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>master</parameter></term>
   <listitem>
    <para>
     SPI bus master that was locked for exclusive bus access
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
<title>Context</title>
<para>
   can sleep
</para>
</refsect1>
<refsect1>
<title>Description</title>
<para>
   This call may only be used from a context that may sleep.  The sleep
   is non-interruptible, and has no timeout.
   </para><para>

   This call releases an SPI bus lock previously obtained by an spi_bus_lock
   call.
   </para><para>

   It returns zero on success, else a negative error code.
</para>
</refsect1>
</refentry>

<refentry id="API-spi-write-then-read">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>July 2015</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>spi_write_then_read</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.4.104</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>spi_write_then_read</refname>
 <refpurpose>
     SPI synchronous write followed by read
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>int <function>spi_write_then_read </function></funcdef>
   <paramdef>struct spi_device * <parameter>spi</parameter></paramdef>
   <paramdef>const void * <parameter>txbuf</parameter></paramdef>
   <paramdef>unsigned <parameter>n_tx</parameter></paramdef>
   <paramdef>void * <parameter>rxbuf</parameter></paramdef>
   <paramdef>unsigned <parameter>n_rx</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>spi</parameter></term>
   <listitem>
    <para>
     device with which data will be exchanged
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>txbuf</parameter></term>
   <listitem>
    <para>
     data to be written (need not be dma-safe)
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>n_tx</parameter></term>
   <listitem>
    <para>
     size of txbuf, in bytes
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>rxbuf</parameter></term>
   <listitem>
    <para>
     buffer into which data will be read (need not be dma-safe)
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>n_rx</parameter></term>
   <listitem>
    <para>
     size of rxbuf, in bytes
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
<title>Context</title>
<para>
   can sleep
</para>
</refsect1>
<refsect1>
<title>Description</title>
<para>
   This performs a half duplex MicroWire style transaction with the
   device, sending txbuf and then reading rxbuf.  The return value
   is zero for success, else a negative errno status code.
   This call may only be used from a context that may sleep.
   </para><para>

   Parameters to this routine are always copied using a small buffer;
   portable code should never use this for more than 32 bytes.
   Performance-sensitive or bulk transfer code should instead use
   spi_{async,sync}() calls with dma-safe buffers.
</para>
</refsect1>
</refentry>

  </chapter>

  <chapter id="i2c">
     <title>I<superscript>2</superscript>C and SMBus Subsystem</title>

     <para>
	I<superscript>2</superscript>C (or without fancy typography, "I2C")
	is an acronym for the "Inter-IC" bus, a simple bus protocol which is
	widely used where low data rate communications suffice.
	Since it's also a licensed trademark, some vendors use another
	name (such as "Two-Wire Interface", TWI) for the same bus.
	I2C only needs two signals (SCL for clock, SDA for data), conserving
	board real estate and minimizing signal quality issues.
	Most I2C devices use seven bit addresses, and bus speeds of up
	to 400 kHz; there's a high speed extension (3.4 MHz) that's not yet
	found wide use.
	I2C is a multi-master bus; open drain signaling is used to
	arbitrate between masters, as well as to handshake and to
	synchronize clocks from slower clients.
     </para>

     <para>
	The Linux I2C programming interfaces support only the master
	side of bus interactions, not the slave side.
	The programming interface is structured around two kinds of driver,
	and two kinds of device.
	An I2C "Adapter Driver" abstracts the controller hardware; it binds
	to a physical device (perhaps a PCI device or platform_device) and
	exposes a <structname>struct i2c_adapter</structname> representing
	each I2C bus segment it manages.
	On each I2C bus segment will be I2C devices represented by a
	<structname>struct i2c_client</structname>.  Those devices will
	be bound to a <structname>struct i2c_driver</structname>,
	which should follow the standard Linux driver model.
	(At this writing, a legacy model is more widely used.)
	There are functions to perform various I2C protocol operations; at
	this writing all such functions are usable only from task context.
     </para>

     <para>
	The System Management Bus (SMBus) is a sibling protocol.  Most SMBus
	systems are also I2C conformant.  The electrical constraints are
	tighter for SMBus, and it standardizes particular protocol messages
	and idioms.  Controllers that support I2C can also support most
	SMBus operations, but SMBus controllers don't support all the protocol
	options that an I2C controller will.
	There are functions to perform various SMBus protocol operations,
	either using I2C primitives or by issuing SMBus commands to
	i2c_adapter devices which don't support those I2C operations.
     </para>

<!-- include/linux/i2c.h -->
<refentry id="API-struct-i2c-driver">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>July 2015</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>struct i2c_driver</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.4.104</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>struct i2c_driver</refname>
 <refpurpose>
  represent an I2C device driver
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <programlisting>
struct i2c_driver {
  unsigned int class;
  int (* attach_adapter) (struct i2c_adapter *);
  int (* detach_adapter) (struct i2c_adapter *);
  int (* probe) (struct i2c_client *, const struct i2c_device_id *);
  int (* remove) (struct i2c_client *);
  void (* shutdown) (struct i2c_client *);
  int (* suspend) (struct i2c_client *, pm_message_t mesg);
  int (* resume) (struct i2c_client *);
  void (* alert) (struct i2c_client *, unsigned int data);
  int (* command) (struct i2c_client *client, unsigned int cmd, void *arg);
  struct device_driver driver;
  const struct i2c_device_id * id_table;
  int (* detect) (struct i2c_client *, struct i2c_board_info *);
  const unsigned short * address_list;
  struct list_head clients;
};  </programlisting>
</refsynopsisdiv>
 <refsect1>
  <title>Members</title>
  <variablelist>
    <varlistentry>      <term>class</term>
      <listitem><para>
What kind of i2c device we instantiate (for detect)
      </para></listitem>
    </varlistentry>
    <varlistentry>      <term>attach_adapter</term>
      <listitem><para>
Callback for bus addition (deprecated)
      </para></listitem>
    </varlistentry>
    <varlistentry>      <term>detach_adapter</term>
      <listitem><para>
Callback for bus removal (deprecated)
      </para></listitem>
    </varlistentry>
    <varlistentry>      <term>probe</term>
      <listitem><para>
Callback for device binding
      </para></listitem>
    </varlistentry>
    <varlistentry>      <term>remove</term>
      <listitem><para>
Callback for device unbinding
      </para></listitem>
    </varlistentry>
    <varlistentry>      <term>shutdown</term>
      <listitem><para>
Callback for device shutdown
      </para></listitem>
    </varlistentry>
    <varlistentry>      <term>suspend</term>
      <listitem><para>
Callback for device suspend
      </para></listitem>
    </varlistentry>
    <varlistentry>      <term>resume</term>
      <listitem><para>
Callback for device resume
      </para></listitem>
    </varlistentry>
    <varlistentry>      <term>alert</term>
      <listitem><para>
Alert callback, for example for the SMBus alert protocol
      </para></listitem>
    </varlistentry>
    <varlistentry>      <term>command</term>
      <listitem><para>
Callback for bus-wide signaling (optional)
      </para></listitem>
    </varlistentry>
    <varlistentry>      <term>driver</term>
      <listitem><para>
Device driver model driver
      </para></listitem>
    </varlistentry>
    <varlistentry>      <term>id_table</term>
      <listitem><para>
List of I2C devices supported by this driver
      </para></listitem>
    </varlistentry>
    <varlistentry>      <term>detect</term>
      <listitem><para>
Callback for device detection
      </para></listitem>
    </varlistentry>
    <varlistentry>      <term>address_list</term>
      <listitem><para>
The I2C addresses to probe (for detect)
      </para></listitem>
    </varlistentry>
    <varlistentry>      <term>clients</term>
      <listitem><para>
List of detected clients we created (for i2c-core use only)
      </para></listitem>
    </varlistentry>
  </variablelist>
 </refsect1>
<refsect1>
<title>Description</title>
<para>
   The driver.owner field should be set to the module owner of this driver.
   The driver.name field should be set to the name of this driver.
   </para><para>

   For automatic device detection, both <parameter>detect</parameter> and <parameter>address_data</parameter> must
   be defined. <parameter>class</parameter> should also be set, otherwise only devices forced
   with module parameters will be created. The detect function must
   fill at least the name field of the i2c_board_info structure it is
   handed upon successful detection, and possibly also the flags field.
   </para><para>

   If <parameter>detect</parameter> is missing, the driver will still work fine for enumerated
   devices. Detected devices simply won't be supported. This is expected
   for the many I2C/SMBus devices which can't be detected reliably, and
   the ones which can always be enumerated in practice.
   </para><para>

   The i2c_client structure which is handed to the <parameter>detect</parameter> callback is
   not a real i2c_client. It is initialized just enough so that you can
   call i2c_smbus_read_byte_data and friends on it. Don't do anything
   else with it. In particular, calling dev_dbg and friends on it is
   not allowed.
</para>
</refsect1>
</refentry>

<refentry id="API-struct-i2c-client">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>July 2015</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>struct i2c_client</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.4.104</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>struct i2c_client</refname>
 <refpurpose>
     represent an I2C slave device
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <programlisting>
struct i2c_client {
  unsigned short flags;
  unsigned short addr;
  char name[I2C_NAME_SIZE];
  struct i2c_adapter * adapter;
  struct i2c_driver * driver;
  struct device dev;
  int irq;
  struct list_head detected;
};  </programlisting>
</refsynopsisdiv>
 <refsect1>
  <title>Members</title>
  <variablelist>
    <varlistentry>      <term>flags</term>
      <listitem><para>
   I2C_CLIENT_TEN indicates the device uses a ten bit chip address;
   I2C_CLIENT_PEC indicates it uses SMBus Packet Error Checking
      </para></listitem>
    </varlistentry>
    <varlistentry>      <term>addr</term>
      <listitem><para>
   Address used on the I2C bus connected to the parent adapter.
      </para></listitem>
    </varlistentry>
    <varlistentry>      <term>name[I2C_NAME_SIZE]</term>
      <listitem><para>
   Indicates the type of the device, usually a chip name that's
   generic enough to hide second-sourcing and compatible revisions.
      </para></listitem>
    </varlistentry>
    <varlistentry>      <term>adapter</term>
      <listitem><para>
   manages the bus segment hosting this I2C device
      </para></listitem>
    </varlistentry>
    <varlistentry>      <term>driver</term>
      <listitem><para>
   device's driver, hence pointer to access routines
      </para></listitem>
    </varlistentry>
    <varlistentry>      <term>dev</term>
      <listitem><para>
   Driver model device node for the slave.
      </para></listitem>
    </varlistentry>
    <varlistentry>      <term>irq</term>
      <listitem><para>
   indicates the IRQ generated by this device (if any)
      </para></listitem>
    </varlistentry>
    <varlistentry>      <term>detected</term>
      <listitem><para>
   member of an i2c_driver.clients list or i2c-core's
   userspace_devices list
      </para></listitem>
    </varlistentry>
  </variablelist>
 </refsect1>
<refsect1>
<title>Description</title>
<para>
   An i2c_client identifies a single device (i.e. chip) connected to an
   i2c bus. The behaviour exposed to Linux is defined by the driver
   managing the device.
</para>
</refsect1>
</refentry>

<refentry id="API-struct-i2c-board-info">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>July 2015</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>struct i2c_board_info</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.4.104</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>struct i2c_board_info</refname>
 <refpurpose>
     template for device creation
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <programlisting>
struct i2c_board_info {
  char type[I2C_NAME_SIZE];
  unsigned short flags;
  unsigned short addr;
  void * platform_data;
  struct dev_archdata * archdata;
  struct device_node * of_node;
  int irq;
};  </programlisting>
</refsynopsisdiv>
 <refsect1>
  <title>Members</title>
  <variablelist>
    <varlistentry>      <term>type[I2C_NAME_SIZE]</term>
      <listitem><para>
   chip type, to initialize i2c_client.name
      </para></listitem>
    </varlistentry>
    <varlistentry>      <term>flags</term>
      <listitem><para>
   to initialize i2c_client.flags
      </para></listitem>
    </varlistentry>
    <varlistentry>      <term>addr</term>
      <listitem><para>
   stored in i2c_client.addr
      </para></listitem>
    </varlistentry>
    <varlistentry>      <term>platform_data</term>
      <listitem><para>
   stored in i2c_client.dev.platform_data
      </para></listitem>
    </varlistentry>
    <varlistentry>      <term>archdata</term>
      <listitem><para>
   copied into i2c_client.dev.archdata
      </para></listitem>
    </varlistentry>
    <varlistentry>      <term>of_node</term>
      <listitem><para>
   pointer to OpenFirmware device node
      </para></listitem>
    </varlistentry>
    <varlistentry>      <term>irq</term>
      <listitem><para>
   stored in i2c_client.irq
      </para></listitem>
    </varlistentry>
  </variablelist>
 </refsect1>
<refsect1>
<title>Description</title>
<para>
   I2C doesn't actually support hardware probing, although controllers and
   devices may be able to use I2C_SMBUS_QUICK to tell whether or not there's
   a device at a given address.  Drivers commonly need more information than
   that, such as chip type, configuration, associated IRQ, and so on.
   </para><para>

   i2c_board_info is used to build tables of information listing I2C devices
   that are present.  This information is used to grow the driver model tree.
   For mainboards this is done statically using <function>i2c_register_board_info</function>;
   bus numbers identify adapters that aren't yet available.  For add-on boards,
   <function>i2c_new_device</function> does this dynamically with the adapter already known.
</para>
</refsect1>
</refentry>

<refentry id="API-I2C-BOARD-INFO">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>July 2015</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>I2C_BOARD_INFO</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.4.104</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>I2C_BOARD_INFO</refname>
 <refpurpose>
     macro used to list an i2c device and its address
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef> <function>I2C_BOARD_INFO </function></funcdef>
   <paramdef> <parameter>dev_type</parameter></paramdef>
   <paramdef> <parameter>dev_addr</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>dev_type</parameter></term>
   <listitem>
    <para>
     identifies the device type
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>dev_addr</parameter></term>
   <listitem>
    <para>
     the device's address on the bus.
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
<title>Description</title>
<para>
   This macro initializes essential fields of a struct i2c_board_info,
   declaring what has been provided on a particular board.  Optional
   fields (such as associated irq, or device-specific platform_data)
   are provided using conventional syntax.
</para>
</refsect1>
</refentry>

<refentry id="API-struct-i2c-msg">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>July 2015</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>struct i2c_msg</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.4.104</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>struct i2c_msg</refname>
 <refpurpose>
     an I2C transaction segment beginning with START
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <programlisting>
struct i2c_msg {
  __u16 addr;
  __u16 flags;
#define I2C_M_TEN		0x0010
#define I2C_M_RD		0x0001
#define I2C_M_NOSTART		0x4000
#define I2C_M_REV_DIR_ADDR	0x2000
#define I2C_M_IGNORE_NAK	0x1000
#define I2C_M_NO_RD_ACK		0x0800
#define I2C_M_RECV_LEN		0x0400
  __u16 len;
  __u8 * buf;
};  </programlisting>
</refsynopsisdiv>
 <refsect1>
  <title>Members</title>
  <variablelist>
    <varlistentry>      <term>addr</term>
      <listitem><para>
   Slave address, either seven or ten bits.  When this is a ten
   bit address, I2C_M_TEN must be set in <parameter>flags</parameter> and the adapter
   must support I2C_FUNC_10BIT_ADDR.
      </para></listitem>
    </varlistentry>
    <varlistentry>      <term>flags</term>
      <listitem><para>
   I2C_M_RD is handled by all adapters.  No other flags may be
   provided unless the adapter exported the relevant I2C_FUNC_*
   flags through <function>i2c_check_functionality</function>.
      </para></listitem>
    </varlistentry>
    <varlistentry>      <term>len</term>
      <listitem><para>
   Number of data bytes in <parameter>buf</parameter> being read from or written to the
   I2C slave address.  For read transactions where I2C_M_RECV_LEN
   is set, the caller guarantees that this buffer can hold up to
   32 bytes in addition to the initial length byte sent by the
   slave (plus, if used, the SMBus PEC); and this value will be
   incremented by the number of block data bytes received.
      </para></listitem>
    </varlistentry>
    <varlistentry>      <term>buf</term>
      <listitem><para>
   The buffer into which data is read, or from which it's written.
      </para></listitem>
    </varlistentry>
  </variablelist>
 </refsect1>
<refsect1>
<title>Description</title>
<para>
   An i2c_msg is the low level representation of one segment of an I2C
   transaction.  It is visible to drivers in the <parameter>i2c_transfer</parameter>() procedure,
   to userspace from i2c-dev, and to I2C adapter drivers through the
   <parameter>i2c_adapter</parameter>.<parameter>master_xfer</parameter>() method.
   </para><para>

   Except when I2C <quote>protocol mangling</quote> is used, all I2C adapters implement
   the standard rules for I2C transactions.  Each transaction begins with a
   START.  That is followed by the slave address, and a bit encoding read
   versus write.  Then follow all the data bytes, possibly including a byte
   with SMBus PEC.  The transfer terminates with a NAK, or when all those
   bytes have been transferred and ACKed.  If this is the last message in a
   group, it is followed by a STOP.  Otherwise it is followed by the next
   <parameter>i2c_msg</parameter> transaction segment, beginning with a (repeated) START.
   </para><para>

   Alternatively, when the adapter supports I2C_FUNC_PROTOCOL_MANGLING then
   passing certain <parameter>flags</parameter> may have changed those standard protocol behaviors.
   Those flags are only for use with broken/nonconforming slaves, and with
   adapters which are known to support the specific mangling options they
   need (one or more of IGNORE_NAK, NO_RD_ACK, NOSTART, and REV_DIR_ADDR).
</para>
</refsect1>
</refentry>

<refentry id="API-i2c-register-board-info">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>July 2015</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>i2c_register_board_info</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.4.104</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>i2c_register_board_info</refname>
 <refpurpose>
  statically declare I2C devices
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>int <function>i2c_register_board_info </function></funcdef>
   <paramdef>int <parameter>busnum</parameter></paramdef>
   <paramdef>struct i2c_board_info const * <parameter>info</parameter></paramdef>
   <paramdef>unsigned <parameter>len</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>busnum</parameter></term>
   <listitem>
    <para>
     identifies the bus to which these devices belong
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>info</parameter></term>
   <listitem>
    <para>
     vector of i2c device descriptors
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>len</parameter></term>
   <listitem>
    <para>
     how many descriptors in the vector; may be zero to reserve
     the specified bus number.
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
<title>Description</title>
<para>
   Systems using the Linux I2C driver stack can declare tables of board info
   while they initialize.  This should be done in board-specific init code
   near <function>arch_initcall</function> time, or equivalent, before any I2C adapter driver is
   registered.  For example, mainboard init code could define several devices,
   as could the init code for each daughtercard in a board stack.
   </para><para>

   The I2C devices will be created later, after the adapter for the relevant
   bus has been registered.  After that moment, standard driver model tools
   are used to bind <quote>new style</quote> I2C drivers to the devices.  The bus number
   for any device declared using this routine is not available for dynamic
   allocation.
   </para><para>

   The board info passed can safely be __initdata, but be careful of embedded
   pointers (for platform_data, functions, etc) since that won't be copied.
</para>
</refsect1>
</refentry>

<!-- drivers/i2c/i2c-core.c -->
<refentry id="API-i2c-verify-client">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>July 2015</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>i2c_verify_client</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.4.104</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>i2c_verify_client</refname>
 <refpurpose>
  return parameter as i2c_client, or NULL
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>struct i2c_client * <function>i2c_verify_client </function></funcdef>
   <paramdef>struct device * <parameter>dev</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>dev</parameter></term>
   <listitem>
    <para>
     device, probably from some driver model iterator
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
<title>Description</title>
<para>
   When traversing the driver model tree, perhaps using driver model
   iterators like @<function>device_for_each_child</function>, you can't assume very much
   about the nodes you find.  Use this function to avoid oopses caused
   by wrongly treating some non-I2C device as an i2c_client.
</para>
</refsect1>
</refentry>

<refentry id="API-i2c-lock-adapter">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>July 2015</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>i2c_lock_adapter</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.4.104</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>i2c_lock_adapter</refname>
 <refpurpose>
     Get exclusive access to an I2C bus segment
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>void <function>i2c_lock_adapter </function></funcdef>
   <paramdef>struct i2c_adapter * <parameter>adapter</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>adapter</parameter></term>
   <listitem>
    <para>
     Target I2C bus segment
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
</refentry>

<refentry id="API-i2c-unlock-adapter">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>July 2015</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>i2c_unlock_adapter</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.4.104</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>i2c_unlock_adapter</refname>
 <refpurpose>
     Release exclusive access to an I2C bus segment
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>void <function>i2c_unlock_adapter </function></funcdef>
   <paramdef>struct i2c_adapter * <parameter>adapter</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>adapter</parameter></term>
   <listitem>
    <para>
     Target I2C bus segment
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
</refentry>

<refentry id="API-i2c-new-device">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>July 2015</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>i2c_new_device</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.4.104</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>i2c_new_device</refname>
 <refpurpose>
     instantiate an i2c device
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>struct i2c_client * <function>i2c_new_device </function></funcdef>
   <paramdef>struct i2c_adapter * <parameter>adap</parameter></paramdef>
   <paramdef>struct i2c_board_info const * <parameter>info</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>adap</parameter></term>
   <listitem>
    <para>
     the adapter managing the device
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>info</parameter></term>
   <listitem>
    <para>
     describes one I2C device; bus_num is ignored
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
<title>Context</title>
<para>
   can sleep
</para>
</refsect1>
<refsect1>
<title>Description</title>
<para>
   Create an i2c device. Binding is handled through driver model
   <function>probe</function>/<function>remove</function> methods.  A driver may be bound to this device when we
   return from this function, or any later moment (e.g. maybe hotplugging will
   load the driver module).  This call is not appropriate for use by mainboard
   initialization logic, which usually runs during an <function>arch_initcall</function> long
   before any i2c_adapter could exist.
   </para><para>

   This returns the new i2c client, which may be saved for later use with
   <function>i2c_unregister_device</function>; or NULL to indicate an error.
</para>
</refsect1>
</refentry>

<refentry id="API-i2c-unregister-device">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>July 2015</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>i2c_unregister_device</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.4.104</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>i2c_unregister_device</refname>
 <refpurpose>
     reverse effect of <function>i2c_new_device</function>
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>void <function>i2c_unregister_device </function></funcdef>
   <paramdef>struct i2c_client * <parameter>client</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>client</parameter></term>
   <listitem>
    <para>
     value returned from <function>i2c_new_device</function>
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
<title>Context</title>
<para>
   can sleep
</para>
</refsect1>
</refentry>

<refentry id="API-i2c-new-dummy">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>July 2015</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>i2c_new_dummy</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.4.104</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>i2c_new_dummy</refname>
 <refpurpose>
     return a new i2c device bound to a dummy driver
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>struct i2c_client * <function>i2c_new_dummy </function></funcdef>
   <paramdef>struct i2c_adapter * <parameter>adapter</parameter></paramdef>
   <paramdef>u16 <parameter>address</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>adapter</parameter></term>
   <listitem>
    <para>
     the adapter managing the device
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>address</parameter></term>
   <listitem>
    <para>
     seven bit address to be used
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
<title>Context</title>
<para>
   can sleep
</para>
</refsect1>
<refsect1>
<title>Description</title>
<para>
   This returns an I2C client bound to the <quote>dummy</quote> driver, intended for use
   with devices that consume multiple addresses.  Examples of such chips
   include various EEPROMS (like 24c04 and 24c08 models).
   </para><para>

   These dummy devices have two main uses.  First, most I2C and SMBus calls
   except <function>i2c_transfer</function> need a client handle; the dummy will be that handle.
   And second, this prevents the specified address from being bound to a
   different driver.
   </para><para>

   This returns the new i2c client, which should be saved for later use with
   <function>i2c_unregister_device</function>; or NULL to indicate an error.
</para>
</refsect1>
</refentry>

<refentry id="API-i2c-add-adapter">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>July 2015</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>i2c_add_adapter</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.4.104</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>i2c_add_adapter</refname>
 <refpurpose>
     declare i2c adapter, use dynamic bus number
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>int <function>i2c_add_adapter </function></funcdef>
   <paramdef>struct i2c_adapter * <parameter>adapter</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>adapter</parameter></term>
   <listitem>
    <para>
     the adapter to add
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
<title>Context</title>
<para>
   can sleep
</para>
</refsect1>
<refsect1>
<title>Description</title>
<para>
   This routine is used to declare an I2C adapter when its bus number
   doesn't matter.  Examples: for I2C adapters dynamically added by
   USB links or PCI plugin cards.
   </para><para>

   When this returns zero, a new bus number was allocated and stored
   in adap-&gt;nr, and the specified adapter became available for clients.
   Otherwise, a negative errno value is returned.
</para>
</refsect1>
</refentry>

<refentry id="API-i2c-add-numbered-adapter">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>July 2015</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>i2c_add_numbered_adapter</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.4.104</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>i2c_add_numbered_adapter</refname>
 <refpurpose>
     declare i2c adapter, use static bus number
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>int <function>i2c_add_numbered_adapter </function></funcdef>
   <paramdef>struct i2c_adapter * <parameter>adap</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>adap</parameter></term>
   <listitem>
    <para>
     the adapter to register (with adap-&gt;nr initialized)
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
<title>Context</title>
<para>
   can sleep
</para>
</refsect1>
<refsect1>
<title>Description</title>
<para>
   This routine is used to declare an I2C adapter when its bus number
   matters.  For example, use it for I2C adapters from system-on-chip CPUs,
   or otherwise built in to the system's mainboard, and where i2c_board_info
   is used to properly configure I2C devices.
   </para><para>

   If the requested bus number is set to -1, then this function will behave
   identically to i2c_add_adapter, and will dynamically assign a bus number.
   </para><para>

   If no devices have pre-been declared for this bus, then be sure to
   register the adapter before any dynamically allocated ones.  Otherwise
   the required bus ID may not be available.
   </para><para>

   When this returns zero, the specified adapter became available for
   clients using the bus number provided in adap-&gt;nr.  Also, the table
   of I2C devices pre-declared using <function>i2c_register_board_info</function> is scanned,
   and the appropriate driver model device nodes are created.  Otherwise, a
   negative errno value is returned.
</para>
</refsect1>
</refentry>

<refentry id="API-i2c-del-adapter">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>July 2015</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>i2c_del_adapter</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.4.104</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>i2c_del_adapter</refname>
 <refpurpose>
     unregister I2C adapter
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>int <function>i2c_del_adapter </function></funcdef>
   <paramdef>struct i2c_adapter * <parameter>adap</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>adap</parameter></term>
   <listitem>
    <para>
     the adapter being unregistered
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
<title>Context</title>
<para>
   can sleep
</para>
</refsect1>
<refsect1>
<title>Description</title>
<para>
   This unregisters an I2C adapter which was previously registered
   by <parameter>i2c_add_adapter</parameter> or <parameter>i2c_add_numbered_adapter</parameter>.
</para>
</refsect1>
</refentry>

<refentry id="API-i2c-del-driver">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>July 2015</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>i2c_del_driver</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.4.104</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>i2c_del_driver</refname>
 <refpurpose>
     unregister I2C driver
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>void <function>i2c_del_driver </function></funcdef>
   <paramdef>struct i2c_driver * <parameter>driver</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>driver</parameter></term>
   <listitem>
    <para>
     the driver being unregistered
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
<title>Context</title>
<para>
   can sleep
</para>
</refsect1>
</refentry>

<refentry id="API-i2c-use-client">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>July 2015</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>i2c_use_client</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.4.104</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>i2c_use_client</refname>
 <refpurpose>
     increments the reference count of the i2c client structure
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>struct i2c_client * <function>i2c_use_client </function></funcdef>
   <paramdef>struct i2c_client * <parameter>client</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>client</parameter></term>
   <listitem>
    <para>
     the client being referenced
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
<title>Description</title>
<para>
   Each live reference to a client should be refcounted. The driver model does
   that automatically as part of driver binding, so that most drivers don't
</para>
</refsect1>
<refsect1>
<title>need to do this explicitly</title>
<para>
   they hold a reference until they're unbound
   from the device.
   </para><para>

   A pointer to the client with the incremented reference counter is returned.
</para>
</refsect1>
</refentry>

<refentry id="API-i2c-release-client">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>July 2015</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>i2c_release_client</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.4.104</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>i2c_release_client</refname>
 <refpurpose>
     release a use of the i2c client structure
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>void <function>i2c_release_client </function></funcdef>
   <paramdef>struct i2c_client * <parameter>client</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>client</parameter></term>
   <listitem>
    <para>
     the client being no longer referenced
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
<title>Description</title>
<para>
   Must be called when a user of a client is finished with it.
</para>
</refsect1>
</refentry>

<refentry id="API-i2c-transfer">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>July 2015</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>i2c_transfer</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.4.104</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>i2c_transfer</refname>
 <refpurpose>
     execute a single or combined I2C message
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>int <function>i2c_transfer </function></funcdef>
   <paramdef>struct i2c_adapter * <parameter>adap</parameter></paramdef>
   <paramdef>struct i2c_msg * <parameter>msgs</parameter></paramdef>
   <paramdef>int <parameter>num</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>adap</parameter></term>
   <listitem>
    <para>
     Handle to I2C bus
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>msgs</parameter></term>
   <listitem>
    <para>
     One or more messages to execute before STOP is issued to
     terminate the operation; each message begins with a START.
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>num</parameter></term>
   <listitem>
    <para>
     Number of messages to be executed.
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
<title>Description</title>
<para>
   Returns negative errno, else the number of messages executed.
   </para><para>

   Note that there is no requirement that each message be sent to
   the same slave address, although that is the most common model.
</para>
</refsect1>
</refentry>

<refentry id="API-i2c-master-send">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>July 2015</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>i2c_master_send</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.4.104</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>i2c_master_send</refname>
 <refpurpose>
     issue a single I2C message in master transmit mode
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>int <function>i2c_master_send </function></funcdef>
   <paramdef>const struct i2c_client * <parameter>client</parameter></paramdef>
   <paramdef>const char * <parameter>buf</parameter></paramdef>
   <paramdef>int <parameter>count</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>client</parameter></term>
   <listitem>
    <para>
     Handle to slave device
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>buf</parameter></term>
   <listitem>
    <para>
     Data that will be written to the slave
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>count</parameter></term>
   <listitem>
    <para>
     How many bytes to write, must be less than 64k since msg.len is u16
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
<title>Description</title>
<para>
   Returns negative errno, or else the number of bytes written.
</para>
</refsect1>
</refentry>

<refentry id="API-i2c-master-recv">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>July 2015</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>i2c_master_recv</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.4.104</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>i2c_master_recv</refname>
 <refpurpose>
     issue a single I2C message in master receive mode
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>int <function>i2c_master_recv </function></funcdef>
   <paramdef>const struct i2c_client * <parameter>client</parameter></paramdef>
   <paramdef>char * <parameter>buf</parameter></paramdef>
   <paramdef>int <parameter>count</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>client</parameter></term>
   <listitem>
    <para>
     Handle to slave device
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>buf</parameter></term>
   <listitem>
    <para>
     Where to store data read from slave
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>count</parameter></term>
   <listitem>
    <para>
     How many bytes to read, must be less than 64k since msg.len is u16
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
<title>Description</title>
<para>
   Returns negative errno, or else the number of bytes read.
</para>
</refsect1>
</refentry>

<refentry id="API-i2c-smbus-read-byte">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>July 2015</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>i2c_smbus_read_byte</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.4.104</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>i2c_smbus_read_byte</refname>
 <refpurpose>
     SMBus <quote>receive byte</quote> protocol
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>s32 <function>i2c_smbus_read_byte </function></funcdef>
   <paramdef>const struct i2c_client * <parameter>client</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>client</parameter></term>
   <listitem>
    <para>
     Handle to slave device
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
<title>Description</title>
<para>
   This executes the SMBus <quote>receive byte</quote> protocol, returning negative errno
   else the byte received from the device.
</para>
</refsect1>
</refentry>

<refentry id="API-i2c-smbus-write-byte">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>July 2015</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>i2c_smbus_write_byte</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.4.104</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>i2c_smbus_write_byte</refname>
 <refpurpose>
     SMBus <quote>send byte</quote> protocol
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>s32 <function>i2c_smbus_write_byte </function></funcdef>
   <paramdef>const struct i2c_client * <parameter>client</parameter></paramdef>
   <paramdef>u8 <parameter>value</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>client</parameter></term>
   <listitem>
    <para>
     Handle to slave device
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>value</parameter></term>
   <listitem>
    <para>
     Byte to be sent
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
<title>Description</title>
<para>
   This executes the SMBus <quote>send byte</quote> protocol, returning negative errno
   else zero on success.
</para>
</refsect1>
</refentry>

<refentry id="API-i2c-smbus-read-byte-data">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>July 2015</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>i2c_smbus_read_byte_data</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.4.104</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>i2c_smbus_read_byte_data</refname>
 <refpurpose>
     SMBus <quote>read byte</quote> protocol
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>s32 <function>i2c_smbus_read_byte_data </function></funcdef>
   <paramdef>const struct i2c_client * <parameter>client</parameter></paramdef>
   <paramdef>u8 <parameter>command</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>client</parameter></term>
   <listitem>
    <para>
     Handle to slave device
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>command</parameter></term>
   <listitem>
    <para>
     Byte interpreted by slave
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
<title>Description</title>
<para>
   This executes the SMBus <quote>read byte</quote> protocol, returning negative errno
   else a data byte received from the device.
</para>
</refsect1>
</refentry>

<refentry id="API-i2c-smbus-write-byte-data">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>July 2015</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>i2c_smbus_write_byte_data</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.4.104</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>i2c_smbus_write_byte_data</refname>
 <refpurpose>
     SMBus <quote>write byte</quote> protocol
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>s32 <function>i2c_smbus_write_byte_data </function></funcdef>
   <paramdef>const struct i2c_client * <parameter>client</parameter></paramdef>
   <paramdef>u8 <parameter>command</parameter></paramdef>
   <paramdef>u8 <parameter>value</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>client</parameter></term>
   <listitem>
    <para>
     Handle to slave device
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>command</parameter></term>
   <listitem>
    <para>
     Byte interpreted by slave
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>value</parameter></term>
   <listitem>
    <para>
     Byte being written
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
<title>Description</title>
<para>
   This executes the SMBus <quote>write byte</quote> protocol, returning negative errno
   else zero on success.
</para>
</refsect1>
</refentry>

<refentry id="API-i2c-smbus-read-word-data">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>July 2015</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>i2c_smbus_read_word_data</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.4.104</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>i2c_smbus_read_word_data</refname>
 <refpurpose>
     SMBus <quote>read word</quote> protocol
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>s32 <function>i2c_smbus_read_word_data </function></funcdef>
   <paramdef>const struct i2c_client * <parameter>client</parameter></paramdef>
   <paramdef>u8 <parameter>command</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>client</parameter></term>
   <listitem>
    <para>
     Handle to slave device
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>command</parameter></term>
   <listitem>
    <para>
     Byte interpreted by slave
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
<title>Description</title>
<para>
   This executes the SMBus <quote>read word</quote> protocol, returning negative errno
   else a 16-bit unsigned <quote>word</quote> received from the device.
</para>
</refsect1>
</refentry>

<refentry id="API-i2c-smbus-write-word-data">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>July 2015</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>i2c_smbus_write_word_data</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.4.104</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>i2c_smbus_write_word_data</refname>
 <refpurpose>
     SMBus <quote>write word</quote> protocol
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>s32 <function>i2c_smbus_write_word_data </function></funcdef>
   <paramdef>const struct i2c_client * <parameter>client</parameter></paramdef>
   <paramdef>u8 <parameter>command</parameter></paramdef>
   <paramdef>u16 <parameter>value</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>client</parameter></term>
   <listitem>
    <para>
     Handle to slave device
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>command</parameter></term>
   <listitem>
    <para>
     Byte interpreted by slave
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>value</parameter></term>
   <listitem>
    <para>
     16-bit <quote>word</quote> being written
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
<title>Description</title>
<para>
   This executes the SMBus <quote>write word</quote> protocol, returning negative errno
   else zero on success.
</para>
</refsect1>
</refentry>

<refentry id="API-i2c-smbus-process-call">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>July 2015</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>i2c_smbus_process_call</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.4.104</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>i2c_smbus_process_call</refname>
 <refpurpose>
     SMBus <quote>process call</quote> protocol
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>s32 <function>i2c_smbus_process_call </function></funcdef>
   <paramdef>const struct i2c_client * <parameter>client</parameter></paramdef>
   <paramdef>u8 <parameter>command</parameter></paramdef>
   <paramdef>u16 <parameter>value</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>client</parameter></term>
   <listitem>
    <para>
     Handle to slave device
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>command</parameter></term>
   <listitem>
    <para>
     Byte interpreted by slave
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>value</parameter></term>
   <listitem>
    <para>
     16-bit <quote>word</quote> being written
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
<title>Description</title>
<para>
   This executes the SMBus <quote>process call</quote> protocol, returning negative errno
   else a 16-bit unsigned <quote>word</quote> received from the device.
</para>
</refsect1>
</refentry>

<refentry id="API-i2c-smbus-read-block-data">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>July 2015</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>i2c_smbus_read_block_data</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.4.104</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>i2c_smbus_read_block_data</refname>
 <refpurpose>
     SMBus <quote>block read</quote> protocol
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>s32 <function>i2c_smbus_read_block_data </function></funcdef>
   <paramdef>const struct i2c_client * <parameter>client</parameter></paramdef>
   <paramdef>u8 <parameter>command</parameter></paramdef>
   <paramdef>u8 * <parameter>values</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>client</parameter></term>
   <listitem>
    <para>
     Handle to slave device
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>command</parameter></term>
   <listitem>
    <para>
     Byte interpreted by slave
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>values</parameter></term>
   <listitem>
    <para>
     Byte array into which data will be read; big enough to hold
     the data returned by the slave.  SMBus allows at most 32 bytes.
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
<title>Description</title>
<para>
   This executes the SMBus <quote>block read</quote> protocol, returning negative errno
   else the number of data bytes in the slave's response.
   </para><para>

   Note that using this function requires that the client's adapter support
   the I2C_FUNC_SMBUS_READ_BLOCK_DATA functionality.  Not all adapter drivers
   support this; its emulation through I2C messaging relies on a specific
   mechanism (I2C_M_RECV_LEN) which may not be implemented.
</para>
</refsect1>
</refentry>

<refentry id="API-i2c-smbus-write-block-data">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>July 2015</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>i2c_smbus_write_block_data</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.4.104</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>i2c_smbus_write_block_data</refname>
 <refpurpose>
     SMBus <quote>block write</quote> protocol
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>s32 <function>i2c_smbus_write_block_data </function></funcdef>
   <paramdef>const struct i2c_client * <parameter>client</parameter></paramdef>
   <paramdef>u8 <parameter>command</parameter></paramdef>
   <paramdef>u8 <parameter>length</parameter></paramdef>
   <paramdef>const u8 * <parameter>values</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>client</parameter></term>
   <listitem>
    <para>
     Handle to slave device
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>command</parameter></term>
   <listitem>
    <para>
     Byte interpreted by slave
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>length</parameter></term>
   <listitem>
    <para>
     Size of data block; SMBus allows at most 32 bytes
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>values</parameter></term>
   <listitem>
    <para>
     Byte array which will be written.
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
<title>Description</title>
<para>
   This executes the SMBus <quote>block write</quote> protocol, returning negative errno
   else zero on success.
</para>
</refsect1>
</refentry>

<refentry id="API-i2c-smbus-xfer">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>July 2015</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>i2c_smbus_xfer</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.4.104</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>i2c_smbus_xfer</refname>
 <refpurpose>
     execute SMBus protocol operations
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>s32 <function>i2c_smbus_xfer </function></funcdef>
   <paramdef>struct i2c_adapter * <parameter>adapter</parameter></paramdef>
   <paramdef>u16 <parameter>addr</parameter></paramdef>
   <paramdef>unsigned short <parameter>flags</parameter></paramdef>
   <paramdef>char <parameter>read_write</parameter></paramdef>
   <paramdef>u8 <parameter>command</parameter></paramdef>
   <paramdef>int <parameter>protocol</parameter></paramdef>
   <paramdef>union i2c_smbus_data * <parameter>data</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>adapter</parameter></term>
   <listitem>
    <para>
     Handle to I2C bus
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>addr</parameter></term>
   <listitem>
    <para>
     Address of SMBus slave on that bus
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>flags</parameter></term>
   <listitem>
    <para>
     I2C_CLIENT_* flags (usually zero or I2C_CLIENT_PEC)
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>read_write</parameter></term>
   <listitem>
    <para>
     I2C_SMBUS_READ or I2C_SMBUS_WRITE
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>command</parameter></term>
   <listitem>
    <para>
     Byte interpreted by slave, for protocols which use such bytes
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>protocol</parameter></term>
   <listitem>
    <para>
     SMBus protocol operation to execute, such as I2C_SMBUS_PROC_CALL
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>data</parameter></term>
   <listitem>
    <para>
     Data to be read or written
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
<title>Description</title>
<para>
   This executes an SMBus protocol operation, and returns a negative
   errno code else zero on success.
</para>
</refsect1>
</refentry>

  </chapter>

  <chapter id="hsi">
     <title>High Speed Synchronous Serial Interface (HSI)</title>

     <para>
	High Speed Synchronous Serial Interface (HSI) is a
	serial interface mainly used for connecting application
	engines (APE) with cellular modem engines (CMT) in cellular
	handsets.

	HSI provides multiplexing for up to 16 logical channels,
	low-latency and full duplex communication.
     </para>

<!-- include/linux/hsi/hsi.h -->
<refentry id="API-struct-hsi-config">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>July 2015</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>struct hsi_config</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.4.104</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>struct hsi_config</refname>
 <refpurpose>
  Configuration for RX/TX HSI modules
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <programlisting>
struct hsi_config {
  unsigned int mode;
  unsigned int channels;
  unsigned int speed;
  union {unnamed_union};
};  </programlisting>
</refsynopsisdiv>
 <refsect1>
  <title>Members</title>
  <variablelist>
    <varlistentry>      <term>mode</term>
      <listitem><para>
Bit transmission mode (STREAM or FRAME)
      </para></listitem>
    </varlistentry>
    <varlistentry>      <term>channels</term>
      <listitem><para>
Number of channels to use [1..16]
      </para></listitem>
    </varlistentry>
    <varlistentry>      <term>speed</term>
      <listitem><para>
Max bit transmission speed (Kbit/s)
      </para></listitem>
    </varlistentry>
    <varlistentry>      <term>{unnamed_union}</term>
      <listitem><para>
anonymous
      </para></listitem>
    </varlistentry>
  </variablelist>
 </refsect1>
</refentry>

<refentry id="API-struct-hsi-board-info">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>July 2015</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>struct hsi_board_info</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.4.104</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>struct hsi_board_info</refname>
 <refpurpose>
     HSI client board info
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <programlisting>
struct hsi_board_info {
  const char * name;
  unsigned int hsi_id;
  unsigned int port;
  struct hsi_config tx_cfg;
  struct hsi_config rx_cfg;
  void * platform_data;
  struct dev_archdata * archdata;
};  </programlisting>
</refsynopsisdiv>
 <refsect1>
  <title>Members</title>
  <variablelist>
    <varlistentry>      <term>name</term>
      <listitem><para>
   Name for the HSI device
      </para></listitem>
    </varlistentry>
    <varlistentry>      <term>hsi_id</term>
      <listitem><para>
   HSI controller id where the client sits
      </para></listitem>
    </varlistentry>
    <varlistentry>      <term>port</term>
      <listitem><para>
   Port number in the controller where the client sits
      </para></listitem>
    </varlistentry>
    <varlistentry>      <term>tx_cfg</term>
      <listitem><para>
   HSI TX configuration
      </para></listitem>
    </varlistentry>
    <varlistentry>      <term>rx_cfg</term>
      <listitem><para>
   HSI RX configuration
      </para></listitem>
    </varlistentry>
    <varlistentry>      <term>platform_data</term>
      <listitem><para>
   Platform related data
      </para></listitem>
    </varlistentry>
    <varlistentry>      <term>archdata</term>
      <listitem><para>
   Architecture-dependent device data
      </para></listitem>
    </varlistentry>
  </variablelist>
 </refsect1>
</refentry>

<refentry id="API-struct-hsi-client">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>July 2015</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>struct hsi_client</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.4.104</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>struct hsi_client</refname>
 <refpurpose>
     HSI client attached to an HSI port
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <programlisting>
struct hsi_client {
  struct device device;
  struct hsi_config tx_cfg;
  struct hsi_config rx_cfg;
};  </programlisting>
</refsynopsisdiv>
 <refsect1>
  <title>Members</title>
  <variablelist>
    <varlistentry>      <term>device</term>
      <listitem><para>
   Driver model representation of the device
      </para></listitem>
    </varlistentry>
    <varlistentry>      <term>tx_cfg</term>
      <listitem><para>
   HSI TX configuration
      </para></listitem>
    </varlistentry>
    <varlistentry>      <term>rx_cfg</term>
      <listitem><para>
   HSI RX configuration
      </para></listitem>
    </varlistentry>
  </variablelist>
 </refsect1>
</refentry>

<refentry id="API-struct-hsi-client-driver">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>July 2015</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>struct hsi_client_driver</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.4.104</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>struct hsi_client_driver</refname>
 <refpurpose>
     Driver associated to an HSI client
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <programlisting>
struct hsi_client_driver {
  struct device_driver driver;
};  </programlisting>
</refsynopsisdiv>
 <refsect1>
  <title>Members</title>
  <variablelist>
    <varlistentry>      <term>driver</term>
      <listitem><para>
   Driver model representation of the driver
      </para></listitem>
    </varlistentry>
  </variablelist>
 </refsect1>
</refentry>

<refentry id="API-struct-hsi-msg">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>July 2015</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>struct hsi_msg</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.4.104</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>struct hsi_msg</refname>
 <refpurpose>
     HSI message descriptor
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <programlisting>
struct hsi_msg {
  struct list_head link;
  struct hsi_client * cl;
  struct sg_table sgt;
  void * context;
  void (* complete) (struct hsi_msg *msg);
  void (* destructor) (struct hsi_msg *msg);
  int status;
  unsigned int actual_len;
  unsigned int channel;
  unsigned int ttype:1;
  unsigned int break_frame:1;
};  </programlisting>
</refsynopsisdiv>
 <refsect1>
  <title>Members</title>
  <variablelist>
    <varlistentry>      <term>link</term>
      <listitem><para>
   Free to use by the current descriptor owner
      </para></listitem>
    </varlistentry>
    <varlistentry>      <term>cl</term>
      <listitem><para>
   HSI device client that issues the transfer
      </para></listitem>
    </varlistentry>
    <varlistentry>      <term>sgt</term>
      <listitem><para>
   Head of the scatterlist array
      </para></listitem>
    </varlistentry>
    <varlistentry>      <term>context</term>
      <listitem><para>
   Client context data associated to the transfer
      </para></listitem>
    </varlistentry>
    <varlistentry>      <term>complete</term>
      <listitem><para>
   Transfer completion callback
      </para></listitem>
    </varlistentry>
    <varlistentry>      <term>destructor</term>
      <listitem><para>
   Destructor to free resources when flushing
      </para></listitem>
    </varlistentry>
    <varlistentry>      <term>status</term>
      <listitem><para>
   Status of the transfer when completed
      </para></listitem>
    </varlistentry>
    <varlistentry>      <term>actual_len</term>
      <listitem><para>
   Actual length of data transfered on completion
      </para></listitem>
    </varlistentry>
    <varlistentry>      <term>channel</term>
      <listitem><para>
   Channel were to TX/RX the message
      </para></listitem>
    </varlistentry>
    <varlistentry>      <term>ttype</term>
      <listitem><para>
   Transfer type (TX if set, RX otherwise)
      </para></listitem>
    </varlistentry>
    <varlistentry>      <term>break_frame</term>
      <listitem><para>
   if true HSI will send/receive a break frame. Data buffers are
   ignored in the request.
      </para></listitem>
    </varlistentry>
  </variablelist>
 </refsect1>
</refentry>

<refentry id="API-struct-hsi-port">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>July 2015</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>struct hsi_port</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.4.104</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>struct hsi_port</refname>
 <refpurpose>
     HSI port device
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <programlisting>
struct hsi_port {
  struct device device;
  struct hsi_config tx_cfg;
  struct hsi_config rx_cfg;
  unsigned int num;
  unsigned int shared:1;
  int claimed;
  struct mutex lock;
  int (* async) (struct hsi_msg *msg);
  int (* setup) (struct hsi_client *cl);
  int (* flush) (struct hsi_client *cl);
  int (* start_tx) (struct hsi_client *cl);
  int (* stop_tx) (struct hsi_client *cl);
  int (* release) (struct hsi_client *cl);
  struct atomic_notifier_head n_head;
};  </programlisting>
</refsynopsisdiv>
 <refsect1>
  <title>Members</title>
  <variablelist>
    <varlistentry>      <term>device</term>
      <listitem><para>
   Driver model representation of the device
      </para></listitem>
    </varlistentry>
    <varlistentry>      <term>tx_cfg</term>
      <listitem><para>
   Current TX path configuration
      </para></listitem>
    </varlistentry>
    <varlistentry>      <term>rx_cfg</term>
      <listitem><para>
   Current RX path configuration
      </para></listitem>
    </varlistentry>
    <varlistentry>      <term>num</term>
      <listitem><para>
   Port number
      </para></listitem>
    </varlistentry>
    <varlistentry>      <term>shared</term>
      <listitem><para>
   Set when port can be shared by different clients
      </para></listitem>
    </varlistentry>
    <varlistentry>      <term>claimed</term>
      <listitem><para>
   Reference count of clients which claimed the port
      </para></listitem>
    </varlistentry>
    <varlistentry>      <term>lock</term>
      <listitem><para>
   Serialize port claim
      </para></listitem>
    </varlistentry>
    <varlistentry>      <term>async</term>
      <listitem><para>
   Asynchronous transfer callback
      </para></listitem>
    </varlistentry>
    <varlistentry>      <term>setup</term>
      <listitem><para>
   Callback to set the HSI client configuration
      </para></listitem>
    </varlistentry>
    <varlistentry>      <term>flush</term>
      <listitem><para>
   Callback to clean the HW state and destroy all pending transfers
      </para></listitem>
    </varlistentry>
    <varlistentry>      <term>start_tx</term>
      <listitem><para>
   Callback to inform that a client wants to TX data
      </para></listitem>
    </varlistentry>
    <varlistentry>      <term>stop_tx</term>
      <listitem><para>
   Callback to inform that a client no longer wishes to TX data
      </para></listitem>
    </varlistentry>
    <varlistentry>      <term>release</term>
      <listitem><para>
   Callback to inform that a client no longer uses the port
      </para></listitem>
    </varlistentry>
    <varlistentry>      <term>n_head</term>
      <listitem><para>
   Notifier chain for signaling port events to the clients.
      </para></listitem>
    </varlistentry>
  </variablelist>
 </refsect1>
</refentry>

<refentry id="API-struct-hsi-controller">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>July 2015</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>struct hsi_controller</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.4.104</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>struct hsi_controller</refname>
 <refpurpose>
     HSI controller device
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <programlisting>
struct hsi_controller {
  struct device device;
  struct module * owner;
  unsigned int id;
  unsigned int num_ports;
  struct hsi_port ** port;
};  </programlisting>
</refsynopsisdiv>
 <refsect1>
  <title>Members</title>
  <variablelist>
    <varlistentry>      <term>device</term>
      <listitem><para>
   Driver model representation of the device
      </para></listitem>
    </varlistentry>
    <varlistentry>      <term>owner</term>
      <listitem><para>
   Pointer to the module owning the controller
      </para></listitem>
    </varlistentry>
    <varlistentry>      <term>id</term>
      <listitem><para>
   HSI controller ID
      </para></listitem>
    </varlistentry>
    <varlistentry>      <term>num_ports</term>
      <listitem><para>
   Number of ports in the HSI controller
      </para></listitem>
    </varlistentry>
    <varlistentry>      <term>port</term>
      <listitem><para>
   Array of HSI ports
      </para></listitem>
    </varlistentry>
  </variablelist>
 </refsect1>
</refentry>

<refentry id="API-hsi-id">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>July 2015</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>hsi_id</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.4.104</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>hsi_id</refname>
 <refpurpose>
     Get HSI controller ID associated to a client
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>unsigned int <function>hsi_id </function></funcdef>
   <paramdef>struct hsi_client * <parameter>cl</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>cl</parameter></term>
   <listitem>
    <para>
     Pointer to a HSI client
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
<title>Description</title>
<para>
   Return the controller id where the client is attached to
</para>
</refsect1>
</refentry>

<refentry id="API-hsi-port-id">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>July 2015</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>hsi_port_id</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.4.104</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>hsi_port_id</refname>
 <refpurpose>
     Gets the port number a client is attached to
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>unsigned int <function>hsi_port_id </function></funcdef>
   <paramdef>struct hsi_client * <parameter>cl</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>cl</parameter></term>
   <listitem>
    <para>
     Pointer to HSI client
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
<title>Description</title>
<para>
   Return the port number associated to the client
</para>
</refsect1>
</refentry>

<refentry id="API-hsi-setup">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>July 2015</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>hsi_setup</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.4.104</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>hsi_setup</refname>
 <refpurpose>
     Configure the client's port
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>int <function>hsi_setup </function></funcdef>
   <paramdef>struct hsi_client * <parameter>cl</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>cl</parameter></term>
   <listitem>
    <para>
     Pointer to the HSI client
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
<title>Description</title>
<para>
   When sharing ports, clients should either relay on a single
   client setup or have the same setup for all of them.
   </para><para>

   Return -errno on failure, 0 on success
</para>
</refsect1>
</refentry>

<refentry id="API-hsi-flush">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>July 2015</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>hsi_flush</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.4.104</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>hsi_flush</refname>
 <refpurpose>
     Flush all pending transactions on the client's port
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>int <function>hsi_flush </function></funcdef>
   <paramdef>struct hsi_client * <parameter>cl</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>cl</parameter></term>
   <listitem>
    <para>
     Pointer to the HSI client
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
<title>Description</title>
<para>
   This function will destroy all pending hsi_msg in the port and reset
   the HW port so it is ready to receive and transmit from a clean state.
   </para><para>

   Return -errno on failure, 0 on success
</para>
</refsect1>
</refentry>

<refentry id="API-hsi-async-read">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>July 2015</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>hsi_async_read</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.4.104</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>hsi_async_read</refname>
 <refpurpose>
     Submit a read transfer
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>int <function>hsi_async_read </function></funcdef>
   <paramdef>struct hsi_client * <parameter>cl</parameter></paramdef>
   <paramdef>struct hsi_msg * <parameter>msg</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>cl</parameter></term>
   <listitem>
    <para>
     Pointer to the HSI client
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>msg</parameter></term>
   <listitem>
    <para>
     HSI message descriptor of the transfer
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
<title>Description</title>
<para>
   Return -errno on failure, 0 on success
</para>
</refsect1>
</refentry>

<refentry id="API-hsi-async-write">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>July 2015</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>hsi_async_write</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.4.104</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>hsi_async_write</refname>
 <refpurpose>
     Submit a write transfer
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>int <function>hsi_async_write </function></funcdef>
   <paramdef>struct hsi_client * <parameter>cl</parameter></paramdef>
   <paramdef>struct hsi_msg * <parameter>msg</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>cl</parameter></term>
   <listitem>
    <para>
     Pointer to the HSI client
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>msg</parameter></term>
   <listitem>
    <para>
     HSI message descriptor of the transfer
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
<title>Description</title>
<para>
   Return -errno on failure, 0 on success
</para>
</refsect1>
</refentry>

<refentry id="API-hsi-start-tx">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>July 2015</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>hsi_start_tx</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.4.104</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>hsi_start_tx</refname>
 <refpurpose>
     Signal the port that the client wants to start a TX
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>int <function>hsi_start_tx </function></funcdef>
   <paramdef>struct hsi_client * <parameter>cl</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>cl</parameter></term>
   <listitem>
    <para>
     Pointer to the HSI client
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
<title>Description</title>
<para>
   Return -errno on failure, 0 on success
</para>
</refsect1>
</refentry>

<refentry id="API-hsi-stop-tx">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>July 2015</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>hsi_stop_tx</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.4.104</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>hsi_stop_tx</refname>
 <refpurpose>
     Signal the port that the client no longer wants to transmit
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>int <function>hsi_stop_tx </function></funcdef>
   <paramdef>struct hsi_client * <parameter>cl</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>cl</parameter></term>
   <listitem>
    <para>
     Pointer to the HSI client
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
<title>Description</title>
<para>
   Return -errno on failure, 0 on success
</para>
</refsect1>
</refentry>

<!-- drivers/hsi/hsi.c -->
<refentry id="API-hsi-unregister-controller">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>July 2015</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>hsi_unregister_controller</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.4.104</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>hsi_unregister_controller</refname>
 <refpurpose>
  Unregister an HSI controller
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>void <function>hsi_unregister_controller </function></funcdef>
   <paramdef>struct hsi_controller * <parameter>hsi</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>hsi</parameter></term>
   <listitem>
    <para>
     The HSI controller to register
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
</refentry>

<refentry id="API-hsi-register-controller">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>July 2015</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>hsi_register_controller</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.4.104</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>hsi_register_controller</refname>
 <refpurpose>
     Register an HSI controller and its ports
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>int <function>hsi_register_controller </function></funcdef>
   <paramdef>struct hsi_controller * <parameter>hsi</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>hsi</parameter></term>
   <listitem>
    <para>
     The HSI controller to register
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
<title>Description</title>
<para>
   Returns -errno on failure, 0 on success.
</para>
</refsect1>
</refentry>

<refentry id="API-hsi-register-client-driver">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>July 2015</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>hsi_register_client_driver</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.4.104</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>hsi_register_client_driver</refname>
 <refpurpose>
     Register an HSI client to the HSI bus
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>int <function>hsi_register_client_driver </function></funcdef>
   <paramdef>struct hsi_client_driver * <parameter>drv</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>drv</parameter></term>
   <listitem>
    <para>
     HSI client driver to register
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
<title>Description</title>
<para>
   Returns -errno on failure, 0 on success.
</para>
</refsect1>
</refentry>

<refentry id="API-hsi-put-controller">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>July 2015</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>hsi_put_controller</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.4.104</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>hsi_put_controller</refname>
 <refpurpose>
     Free an HSI controller
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>void <function>hsi_put_controller </function></funcdef>
   <paramdef>struct hsi_controller * <parameter>hsi</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>hsi</parameter></term>
   <listitem>
    <para>
     Pointer to the HSI controller to freed
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
<title>Description</title>
<para>
   HSI controller drivers should only use this function if they need
   to free their allocated hsi_controller structures before a successful
   call to hsi_register_controller. Other use is not allowed.
</para>
</refsect1>
</refentry>

<refentry id="API-hsi-alloc-controller">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>July 2015</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>hsi_alloc_controller</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.4.104</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>hsi_alloc_controller</refname>
 <refpurpose>
     Allocate an HSI controller and its ports
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>struct hsi_controller * <function>hsi_alloc_controller </function></funcdef>
   <paramdef>unsigned int <parameter>n_ports</parameter></paramdef>
   <paramdef>gfp_t <parameter>flags</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>n_ports</parameter></term>
   <listitem>
    <para>
     Number of ports on the HSI controller
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>flags</parameter></term>
   <listitem>
    <para>
     Kernel allocation flags
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
<title>Description</title>
<para>
   Return NULL on failure or a pointer to an hsi_controller on success.
</para>
</refsect1>
</refentry>

<refentry id="API-hsi-free-msg">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>July 2015</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>hsi_free_msg</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.4.104</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>hsi_free_msg</refname>
 <refpurpose>
     Free an HSI message
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>void <function>hsi_free_msg </function></funcdef>
   <paramdef>struct hsi_msg * <parameter>msg</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>msg</parameter></term>
   <listitem>
    <para>
     Pointer to the HSI message
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
<title>Description</title>
<para>
   Client is responsible to free the buffers pointed by the scatterlists.
</para>
</refsect1>
</refentry>

<refentry id="API-hsi-alloc-msg">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>July 2015</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>hsi_alloc_msg</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.4.104</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>hsi_alloc_msg</refname>
 <refpurpose>
     Allocate an HSI message
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>struct hsi_msg * <function>hsi_alloc_msg </function></funcdef>
   <paramdef>unsigned int <parameter>nents</parameter></paramdef>
   <paramdef>gfp_t <parameter>flags</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>nents</parameter></term>
   <listitem>
    <para>
     Number of memory entries
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>flags</parameter></term>
   <listitem>
    <para>
     Kernel allocation flags
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
<title>Description</title>
<para>
   nents can be 0. This mainly makes sense for read transfer.
   In that case, HSI drivers will call the complete callback when
   there is data to be read without consuming it.
   </para><para>

   Return NULL on failure or a pointer to an hsi_msg on success.
</para>
</refsect1>
</refentry>

<refentry id="API-hsi-async">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>July 2015</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>hsi_async</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.4.104</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>hsi_async</refname>
 <refpurpose>
     Submit an HSI transfer to the controller
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>int <function>hsi_async </function></funcdef>
   <paramdef>struct hsi_client * <parameter>cl</parameter></paramdef>
   <paramdef>struct hsi_msg * <parameter>msg</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>cl</parameter></term>
   <listitem>
    <para>
     HSI client sending the transfer
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>msg</parameter></term>
   <listitem>
    <para>
     The HSI transfer passed to controller
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
<title>Description</title>
<para>
   The HSI message must have the channel, ttype, complete and destructor
   fields set beforehand. If nents &gt; 0 then the client has to initialize
   also the scatterlists to point to the buffers to write to or read from.
   </para><para>

   HSI controllers relay on pre-allocated buffers from their clients and they
   do not allocate buffers on their own.
   </para><para>

   Once the HSI message transfer finishes, the HSI controller calls the
   complete callback with the status and actual_len fields of the HSI message
   updated. The complete callback can be called before returning from
   hsi_async.
   </para><para>

   Returns -errno on failure or 0 on success
</para>
</refsect1>
</refentry>

<refentry id="API-hsi-claim-port">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>July 2015</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>hsi_claim_port</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.4.104</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>hsi_claim_port</refname>
 <refpurpose>
     Claim the HSI client's port
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>int <function>hsi_claim_port </function></funcdef>
   <paramdef>struct hsi_client * <parameter>cl</parameter></paramdef>
   <paramdef>unsigned int <parameter>share</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>cl</parameter></term>
   <listitem>
    <para>
     HSI client that wants to claim its port
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>share</parameter></term>
   <listitem>
    <para>
     Flag to indicate if the client wants to share the port or not.
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
<title>Description</title>
<para>
   Returns -errno on failure, 0 on success.
</para>
</refsect1>
</refentry>

<refentry id="API-hsi-release-port">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>July 2015</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>hsi_release_port</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.4.104</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>hsi_release_port</refname>
 <refpurpose>
     Release the HSI client's port
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>void <function>hsi_release_port </function></funcdef>
   <paramdef>struct hsi_client * <parameter>cl</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>cl</parameter></term>
   <listitem>
    <para>
     HSI client which previously claimed its port
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
</refentry>

<refentry id="API-hsi-register-port-event">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>July 2015</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>hsi_register_port_event</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.4.104</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>hsi_register_port_event</refname>
 <refpurpose>
     Register a client to receive port events
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>int <function>hsi_register_port_event </function></funcdef>
   <paramdef>struct hsi_client * <parameter>cl</parameter></paramdef>
   <paramdef>void (*<parameter>handler</parameter>)
     <funcparams>struct hsi_client *, unsigned long</funcparams></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>cl</parameter></term>
   <listitem>
    <para>
     HSI client that wants to receive port events
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>handler</parameter></term>
   <listitem>
    <para>
     -- undescribed --
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
<title>Description</title>
<para>
   Clients should register a callback to be able to receive
   events from the ports. Registration should happen after
   claiming the port.
   The handler can be called in interrupt context.
   </para><para>

   Returns -errno on error, or 0 on success.
</para>
</refsect1>
</refentry>

<refentry id="API-hsi-unregister-port-event">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>July 2015</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>hsi_unregister_port_event</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.4.104</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>hsi_unregister_port_event</refname>
 <refpurpose>
     Stop receiving port events for a client
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>int <function>hsi_unregister_port_event </function></funcdef>
   <paramdef>struct hsi_client * <parameter>cl</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>cl</parameter></term>
   <listitem>
    <para>
     HSI client that wants to stop receiving port events
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
<title>Description</title>
<para>
   Clients should call this function before releasing their associated
   port.
   </para><para>

   Returns -errno on error, or 0 on success.
</para>
</refsect1>
</refentry>

<refentry id="API-hsi-event">
<refentryinfo>
 <title>LINUX</title>
 <productname>Kernel Hackers Manual</productname>
 <date>July 2015</date>
</refentryinfo>
<refmeta>
 <refentrytitle><phrase>hsi_event</phrase></refentrytitle>
 <manvolnum>9</manvolnum>
 <refmiscinfo class="version">3.4.104</refmiscinfo>
</refmeta>
<refnamediv>
 <refname>hsi_event</refname>
 <refpurpose>
     Notifies clients about port events
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis><funcprototype>
   <funcdef>int <function>hsi_event </function></funcdef>
   <paramdef>struct hsi_port * <parameter>port</parameter></paramdef>
   <paramdef>unsigned long <parameter>event</parameter></paramdef>
  </funcprototype></funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>port</parameter></term>
   <listitem>
    <para>
     Port where the event occurred
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>event</parameter></term>
   <listitem>
    <para>
     The event type
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
<title>Description</title>
<para>
   Clients should not be concerned about wake line behavior. However, due
   to a race condition in HSI HW protocol, clients need to be notified
   about wake line changes, so they can implement a workaround for it.
</para>
</refsect1>
<refsect1>
<title>Events</title>
<para>
   HSI_EVENT_START_RX - Incoming wake line high
   HSI_EVENT_STOP_RX - Incoming wake line down
   </para><para>

   Returns -errno on error, or 0 on success.
</para>
</refsect1>
</refentry>

  </chapter>

</book>
